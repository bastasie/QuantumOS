<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <meta name="theme-color" content="#0b0f14" />
  <title>BAZ TRX (P2P Audio/Video + Data)</title>
  <style>
    :root{--bg:#0b0f14;--muted:#9fb0c3;--text:#e9f2ff;--accent:#6ae4ff;--ok:#4dff88;--warn:#ffdf6a;--bad:#ff6a6a;}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1200px;margin:0 auto;padding:16px;}
    h1{margin:8px 0 4px;font-size:20px;font-weight:820;letter-spacing:.2px}
    .sub{color:var(--muted);margin:0 0 14px;font-size:13px;line-height:1.35}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:14px;box-shadow:0 14px 40px rgba(0,0,0,.35)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
    label{font-size:12px;color:var(--muted)}
    input,button,select,textarea{
      border-radius:12px;border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);color:var(--text);padding:10px 12px;font-size:14px;outline:none;
    }
    textarea{width:100%;min-height:120px;resize:vertical;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    input::placeholder,textarea::placeholder{color:rgba(159,176,195,.65)}
    button{cursor:pointer;background:rgba(106,228,255,.10);border-color:rgba(106,228,255,.35)}
    button:hover{background:rgba(106,228,255,.14)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .pill{display:inline-flex;align-items:center;gap:8px;border-radius:999px;padding:6px 10px;font-size:12px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);color:var(--muted)}
    .pill b{color:var(--text);font-weight:760}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .small{font-size:12px;color:var(--muted);line-height:1.45}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    .videos{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width: 700px){.videos{grid-template-columns:1fr}}
    video{width:100%;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18)}
    .log{height:170px;overflow:auto;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.16);padding:10px;font-size:12px;color:#cfe0ff}
    .log .dim{color:rgba(233,242,255,.6)}
  
    /* Tabs */
    .tabs{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin:10px 0 14px}
    .tabBtn{padding:9px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.04);color:inherit;font-weight:700}
    .tabBtn.active{background:rgba(106,228,255,.14);border-color:rgba(106,228,255,.45)}
    .tabBtn:disabled{opacity:.55}

    /* Monograph */
    #viewMONO{display:none}

    /* LLM */
    #viewLLM{display:none}
    .chatLog{height:320px;overflow:auto;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.16);padding:10px;font-size:12px;color:#cfe0ff}
    .chatMsg{margin:0 0 10px}
    .chatMsg .who{font-weight:800;color:var(--text)}
    .chatMsg .txt{white-space:pre-wrap;color:#cfe0ff}

    .monoPanel{display:grid;grid-template-columns:1fr;gap:12px}
    .monoStage{
      border-radius:18px;border:1px solid rgba(255,255,255,.10);
      background:#000; overflow:hidden;
      box-shadow:0 18px 60px rgba(0,0,0,.35);
    }
    #monoCanvas{display:block;width:100%;height:70vh;background:#000}
    @media (max-width: 700px){#monoCanvas{height:72vh}}
    .tilt45{transform:perspective(900px) rotateX(45deg);transform-origin:center;}
    .monoText{white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;line-height:1.35;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:12px}


    /* --- AQC overlay + mask designer --- */
    .videoWrap{position:relative;display:block}
    .videoWrap video{width:100%;height:auto;display:block;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.10)}
    .overlayCanvas{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;border-radius:12px}
    .drawCanvas{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;border-radius:12px;touch-action:none}
    .overlayBtn{position:absolute;right:10px;top:10px;z-index:5}
    .overlayPanel{position:fixed;left:12px;right:12px;bottom:12px;z-index:1000;background:rgba(15,20,28,.96);border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:12px;box-shadow:0 14px 40px rgba(0,0,0,.55)}
    .overlayPanel.hidden{display:none}
    .overlayPanel h3{margin:2px 0 8px;font-size:14px}
    .overlayGrid{display:grid;grid-template-columns:1fr;gap:10px}
    .overlayRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .overlayRow .pill{cursor:default}
    .aqcCanvas{width:100%;max-width:520px;aspect-ratio:3/2;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18)}
    .aqcAscii{white-space:pre;overflow:auto;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);padding:10px}

  
  .gridLayouts{ display:grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap:10px; }
  .layoutCard{ border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background:rgba(255,255,255,.03); cursor:pointer; }
  .layoutCard:hover{ background:rgba(255,255,255,.06); }
  .layoutCard.active{ outline:2px solid rgba(120,180,255,.55); }
  .layoutThumb{ width:100%; height:120px; border-radius:10px; background:rgba(0,0,0,.25); display:block; }


    /* Mobile responsiveness / tap reliability */
    *{-webkit-tap-highlight-color: transparent;}
    button, .tabBtn, summary, .pill{touch-action:manipulation;}
    button, .tabBtn, summary{user-select:none;-webkit-user-select:none}

    /* Panic stop */
    #panicStop{
      display:none;
      position:fixed; right:12px; top:12px; z-index:10000;
      border-radius:999px; padding:10px 14px;
      border:1px solid rgba(255,106,106,.55);
      background:rgba(255,106,106,.18);
      color:var(--text); font-weight:900;
      box-shadow:0 14px 40px rgba(0,0,0,.55);
    }
    
    .panicOn #panicStop{display:block}
#panicStop:active{transform:scale(.98)}
    #statusToast{
      position:fixed; left:12px; top:12px; z-index:10000;
      border-radius:999px; padding:8px 12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.35);
      color:rgba(233,242,255,.85); font-size:12px;
      max-width:calc(100vw - 160px);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      pointer-events:none;
    }

</style>
</head>
<body>
<div id="statusToast">ready</div>
<button id="panicStop" title="Stop all loops / heavy compute">STOP</button>

<div class="wrap">
  <h1>BAZ TRX (P2P Audio/Video + Data)</h1>
  <p class="sub">
    Practical transmitter/receiver: uses <span class="mono">WebRTC</span> to send camera + mic + a data channel
    between two phones running the same file. This is normal network transport (Wi‑Fi/cellular) with encrypted WebRTC media.
  </p>

  
  <div class="tabs">
    <button id="tabTrx" class="tabBtn active">TRX</button>
    <button id="tabMono" class="tabBtn">Monograph</button>
    <button id="tabLlm" class="tabBtn">LLM</button>
    <button id="tabAqc" class="tabBtn">AQC</button>
    <button id="tabLayouts" class="tabBtn">Layouts</button>
    <span class="pill"><b>Sync</b> <span id="syncState">off</span></span>
  </div>

  <div id="viewTRX">

<div class="grid">
    <div class="card">
      <div class="row">
        <div>
          <label>Role</label><br/>
          <select id="role">
            <option value="a" selected>Device A (creates Offer)</option>
            <option value="b">Device B (creates Answer)</option>
          </select>
        </div>
        <div>
          <label>STUN</label><br/>
          <select id="stun">
            <option value="google" selected>stun:stun.l.google.com:19302</option>
            <option value="twilio">stun:global.stun.twilio.com:3478</option>
            <option value="none">None (LAN only)</option>
          </select>
        </div>
        <div style="min-width:170px">
          <label>ICE timeout</label><br/>
          <select id="iceTimeout">
            <option value="3000">3s (fast)</option>
            <option value="6000" selected>6s (default)</option>
            <option value="12000">12s (slow networks)</option>
          </select>
        </div>
        <div><label>&nbsp;</label><br/><button id="init">Init TRX</button></div>
        <div><label>&nbsp;</label><br/><button id="hangup" disabled>Hang up</button></div>
        <span class="pill"><b>RTC</b> <span id="rtcState">idle</span></span>
        <span class="pill"><b>ICE</b> <span id="iceState">—</span></span>
        <span class="pill"><b>Cands</b> <span id="candCount">0</span></span>
        <span class="pill"><b>DC</b> <span id="dcState">—</span></span>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div>
          <label>Camera</label><br/>
          <select id="camMode">
            <option value="none" selected>Off</option>
            <option value="user">Front</option>
            <option value="env">Back</option>
          </select>
        </div>
        <div>
          <label>Mic</label><br/>
          <select id="micMode">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
        <div style="min-width:180px">
          <label>Proof overlay</label><br/>
          <select id="overlayMode">
            <option value="on" selected>Timestamp overlay (real-time)</option>
            <option value="off">Off (raw camera)</option>
          </select>
        </div>
        <div><label>&nbsp;</label><br/><button id="startMedia" disabled>Start media</button></div>
        <div><label>&nbsp;</label><br/><button id="stopMedia" disabled>Stop media</button></div>
        <span class="pill"><b>Media</b> <span id="mediaState">off</span></span>
      </div>

      <div class="videos" style="margin-top:10px">
        <div>
          <label>Local</label>
          <div class="videoWrap" id="localWrap">
            <video id="local" autoplay playsinline muted></video>
            <canvas id="localOverlay" class="overlayCanvas"></canvas>
            <canvas id="localDraw" class="drawCanvas"></canvas>
            <button id="overlayBtn" class="overlayBtn" disabled>Layout</button>
          <button id="computeBtn" class="overlayBtn" disabled>Compute</button>
          </div>
          <div id="overlayPanel" class="overlayPanel hidden">
            <div class="overlayGrid">
              <div class="overlayRow" style="justify-content:space-between">
                <h3 style="margin:0">Local camera overlay</h3>
                <button id="overlayClose">Close</button>
              </div>

              <div class="overlayRow">
                <span class="pill"><b>Mode</b></span>
                <button id="ovNone">None</button>
                <button id="ovCup">Cup</button>
                <button id="ovPhase">Phase</button>
                <button id="ovFoam">Foam</button>
                <button id="ovMore">More…</button>
                <button id="ovArch">Architect</button>
                <span class="pill"><b>QC</b> <span id="ovQcState">idle</span></span>
              </div>

              <div class="overlayRow">
                <label class="pill"><b>Size</b> <span id="ovSizeLabel">20mm</span></label>
                <input id="ovSize" type="range" min="8" max="40" step="1" value="20" style="flex:1;min-width:160px" />
                <label class="pill"><b>Opacity</b> <span id="ovOpLabel">70%</span></label>
                <input id="ovOpacity" type="range" min="10" max="95" step="1" value="70" style="flex:1;min-width:140px" />
              </div>

              <div class="overlayRow">
                <span class="pill"><b>Draw</b> <span id="ovDrawState">off</span></span>
                <button id="ovBrush">Brush</button>
                <button id="ovEraser">Eraser</button>
                <button id="ovClear">Clear</button>
                <label class="pill"><b>Brush</b> <span id="ovBrushLabel">8px</span></label>
                <input id="ovBrushSize" type="range" min="2" max="30" step="1" value="8" style="flex:1;min-width:140px" />
              </div>

              <div class="overlayRow">
                <span class="pill"><b>4f sim</b> <span id="ovRunState">idle</span></span>
                <label class="pill"><b>Res</b></label>
                <select id="ovSimRes">
                  <option value="64">64</option>
                  <option value="96">96</option>
                  <option value="128" selected>128</option>
                  <option value="160">160</option>
                  <option value="192">192</option>
                  <option value="256">256</option>
                </select>
                <label class="pill"><b>Stages</b></label>
                <input id="ovStages" type="number" min="1" max="8" step="1" value="1" style="width:90px" />
                <button id="ovRun">Run</button>
                <button id="ovCompute">Compute</button>
              <button id="ovComputeStop" style="border-color:rgba(255,106,106,.55);background:rgba(255,106,106,.10)">Stop</button>
              </div>

              <details id="ovResultDetails" style="margin-top:6px">
                <summary class="pill" style="cursor:pointer;user-select:none"><b>Result</b> (simulated pattern)</summary>
                <div style="margin-top:10px">
                  <canvas id="ovResult" class="aqcCanvas"></canvas>
                </div>
                <div class="small" id="ovResultInfo" style="margin-top:8px"></div>
              </details>

              <details id="ovComputeDetails" style="margin-top:6px">
                <summary class="pill" style="cursor:pointer;user-select:none"><b>Compute</b> (camera + paper mask)</summary>
                <div class="row" style="margin-top:10px;align-items:flex-start">
                  <div style="flex:1;min-width:220px">
                    <div class="small">Observed (camera crop)</div>
                    <canvas id="ovObs" class="aqcCanvas"></canvas>
                  </div>
                  <div style="flex:1;min-width:220px">
                    <div class="small">FFT magnitude (log)</div>
                    <canvas id="ovFFT" class="aqcCanvas"></canvas>
                  </div>
                  <div style="flex:1;min-width:220px">
                    <div class="small">Predicted (4f)</div>
                    <canvas id="ovPred" class="aqcCanvas"></canvas>
                  </div>
                </div>

                <div class="overlayRow" style="margin-top:8px;flex-wrap:wrap">
                  <label class="pill"><b>N</b></label>
                  <select id="ovCN" style="min-width:90px">
                    <option value="128">128</option>
                    <option value="192">192</option>
                    <option value="256" selected>256</option>
                    <option value="320">320</option>
                    <option value="384">384</option>
                    <option value="512">512</option>
                  </select>

                  <label class="pill"><b>ROI</b></label>
                  <input id="ovRoi" type="range" min="0.25" max="1.0" step="0.01" value="0.75" style="width:160px" />
                  <span class="pill" id="ovRoiLabel">0.75×</span>

                  <label class="pill"><b>Threshold</b></label>
                  <input id="ovThresh" type="range" min="0" max="255" step="1" value="140" style="width:170px" />
                  <span class="pill" id="ovThreshLabel">140</span>

                  <label class="pill"><b>Invert</b></label>
                  <input id="ovInvert" type="checkbox" />

                  <label class="pill"><b>Include overlay</b></label>
                  <input id="ovInclOverlay" type="checkbox" />

                  <label class="pill"><b>Input</b></label>
                  <select id="ovInput" style="min-width:120px">
                    <option value="gaussian" selected>Gaussian</option>
                    <option value="plane">Plane</option>
                  </select>

                  <label class="pill"><b>Use as</b></label>
                  <select id="ovMaskDomain" style="min-width:140px">
                    <option value="fourier" selected>Fourier mask</option>
                    <option value="object">Object aperture</option>
                  </select>
                </div>

                <div class="small" id="ovComputeInfo" style="margin-top:8px"></div>
              </details>

              <div class="overlayRow">
                <button id="ovToggleQc">Quantum compute mode (hide overlay)</button>
                <span class="small" id="ovHint">Tip: Use overlay while aligning. Turn on QC mode to remove overlays for capture.</span>
              </div>
            </div>
          </div>
        </div>
        <div>
          <label>Remote</label>
          <video id="remote" autoplay playsinline></video>
        </div>
      
      <div class="hr"></div>
      <label>Live proof (WebRTC stats)</label>
      <div class="small">
        Pulled from <span class="mono">pc.getStats()</span>: bitrate, packets, jitter, RTT, ICE pair.
        This reflects real media + network flow.
      </div>
      <div class="row" style="margin-top:10px">
        <span class="pill"><b>TX video</b> <span id="stTxV">—</span></span>
        <span class="pill"><b>RX video</b> <span id="stRxV">—</span></span>
        <span class="pill"><b>TX audio</b> <span id="stTxA">—</span></span>
        <span class="pill"><b>RX audio</b> <span id="stRxA">—</span></span>
        <span class="pill"><b>RTT</b> <span id="stRtt">—</span></span>
        <span class="pill"><b>Jitter</b> <span id="stJit">—</span></span>
      </div>
      <div class="row" style="margin-top:8px">
        <span class="pill"><b>ICE pair</b> <span id="stPair">—</span></span>
        <span class="pill"><b>Avail out</b> <span id="stAvail">—</span></span>
      </div>
</div>

      <div class="hr"></div>

      <label>Signaling (manual copy/paste)</label>
      <p class="small">
        This build uses <b>non-trickle ICE</b>: you copy a single JSON blob after ICE gathering completes.
      </p>

      <div class="row">
        <div style="flex:1;min-width:240px">
          <label>Local JSON</label><br/>
          <textarea id="localSDP" readonly placeholder="Press Create Offer/Answer…"></textarea>
          <div class="row">
            <button id="createOffer" disabled>Create Offer</button>
            <button id="createAnswer" disabled>Create Answer</button>
            <button id="copyLocal" disabled>Copy</button>
            <button id="showLocalQR" disabled>Show as QR</button>
          </div>
        </div>
        <div style="flex:1;min-width:240px">
          <label>Remote JSON</label><br/>
          <textarea id="remoteSDP" placeholder="Paste remote Offer/Answer JSON here…"></textarea>
          <div class="row">
            <button id="setRemote" disabled>Set Remote</button>
            <button id="scanRemoteQR">Scan QR</button>
            <button id="clearRemote">Clear</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <label>Data channel (messages)</label>
      <div class="row">
        <div style="flex:1;min-width:240px">
          <input id="msg" type="text" placeholder="Type message…" style="width:100%" />
        </div>
        <div><label>&nbsp;</label><br/><button id="send" disabled>Send</button></div>
        <div><label>&nbsp;</label><br/><button id="sendBurst" disabled>Send “pole burst”</button></div>
      </div>

      <div class="hr"></div>
      <label>Log</label>
      <div class="log mono" id="log"></div>
    </div>

    <div class="card">
      <h1 style="font-size:16px;margin-top:0">How to connect two phones</h1>
      <ol class="small">
        <li>Open this file on both phones (prefer installed PWA / https).</li>
        <li>On <b>Phone A</b>: Role = Device A → Init TRX → Start media → Create Offer → Copy JSON.</li>
        <li>Send JSON to <b>Phone B</b> and paste into Remote JSON → Set Remote.</li>
        <li>On <b>Phone B</b>: Create Answer → Copy JSON back to Phone A.</li>
        <li>On <b>Phone A</b>: paste Answer → Set Remote. Wait for “connected”.</li>
      </ol>

      <div class="hr"></div>

      <h1 style="font-size:16px;margin-top:0">About “quantum TRX”</h1>
      <p class="small">
        You can treat your pole-grid/BasUni math as an <i>encoding layer</i> over the data channel (spreading, transforms, ECC).
        But the transport still uses normal radios (Wi‑Fi/cellular). Browsers do not expose raw antenna control or direct “RF dBm” access.
      </p>

      <div class="hr"></div>

      <h1 style="font-size:16px;margin-top:0">“Pole burst”</h1>
      <p class="small">
        Sends a deterministic burst pattern based on a time slice. Useful for measuring latency/jitter and future modulation experiments.
      </p>
    </div>
  </div>
</div>



  </div> <!-- /viewTRX -->

  <div id="viewMONO">
    <div class="monoPanel">
      <div class="card">
        <div class="row" style="flex-wrap:wrap">
          <button id="monoStart">Start</button>
          <button id="monoStop" disabled>Stop</button>
          <button id="monoFull">Fullscreen</button>
          <button id="monoTilt">Tilt 45°</button>
        </div>
        <div class="row" style="flex-wrap:wrap">
          <div>
            <label>Pole count (≥3)</label><br/>
            <select id="monoPoles">
              <option value="3" selected>3</option>
              <option value="4">4</option>
              <option value="6">6</option>
              <option value="8">8</option>
              <option value="12">12</option>
            </select>
          </div>
          <div>
            <label>Matrix (resolution)</label><br/>
            <select id="monoRes">
              <option value="96">96×96</option>
              <option value="128" selected>128×128</option>
              <option value="160">160×160</option>
              <option value="192">192×192</option>
              <option value="256">256×256</option>
            </select>
          </div>
          <div>
            <label>Sync over DataChannel</label><br/>
            <select id="monoSync">
              <option value="off" selected>off</option>
              <option value="tx">TX (broadcast)</option>
              <option value="rx">RX (follow)</option>
            </select>
          </div>
          <div style="flex:1;min-width:220px">
            <label>Notes</label><br/>
            <div class="small">This is a controllable pixel/photon emitter-field visualization. “Floating” needs real optics; the field is what you align at 45°.</div>
          </div>
        </div>
      </div>


      <div class="card" style="margin-top:12px">
        <div class="row" style="flex-wrap:wrap;align-items:flex-end">
          <div>
            <label>Engine</label><br/>
            <select id="monoEngine">
              <option value="poles" selected>Pole-field (BasUni)</option>
              <option value="eqv">Equation-video (Pixel-Life)</option>
            </select>
          </div>

          <div>
            <label>EQV preset</label><br/>
            <select id="eqvPreset">
              <option value="stable" selected>Stable reconstruction</option>
              <option value="living">Living dynamics</option>
              <option value="encode">Encode from camera</option>
            </select>
          </div>

          <div>
            <label>EQV base C₀</label><br/>
            <div class="row" style="gap:8px">
              <button id="eqvSnap">Snap from camera</button>
              <button id="eqvLoadImg">Load image…</button>
              <input id="eqvImg" type="file" accept="image/*" style="display:none"/>
            </div>
          </div>

          <div>
            <label>EQV link</label><br/>
            <div class="row" style="gap:8px">
              <button id="eqvSend" disabled>Send to peer</button>
              <button id="eqvRecv" disabled>Request from peer</button>
            </div>
          </div>

          <span class="pill"><b>EQV</b> <span id="eqvState">off</span></span>
          <span class="pill"><b>Entropy</b> <span id="eqvEntropy">—</span></span>
        </div>

        <details style="margin-top:10px">
          <summary class="pill" style="cursor:pointer;user-select:none"><b>EQV parameters</b> (advanced)</summary>
          <div class="row" style="flex-wrap:wrap;margin-top:10px">
            <div>
              <label>Δt</label><br/>
              <input id="eqvDt" type="number" step="0.001" min="0.001" max="0.1" value="0.016" />
            </div>
            <div>
              <label>D (diffusion)</label><br/>
              <input id="eqvD" type="number" step="0.01" min="0" max="5" value="0.35" />
            </div>
            <div>
              <label>k₁ k₂ k₃</label><br/>
              <input id="eqvK1" type="number" step="0.01" min="0" max="5" value="0.90" style="width:74px"/>
              <input id="eqvK2" type="number" step="0.01" min="0" max="5" value="0.80" style="width:74px"/>
              <input id="eqvK3" type="number" step="0.01" min="0" max="5" value="0.70" style="width:74px"/>
            </div>
            <div>
              <label>β (homeostasis)</label><br/>
              <input id="eqvBeta" type="number" step="0.01" min="0" max="10" value="1.20" />
            </div>
            <div>
              <label>λ, µ (memory)</label><br/>
              <input id="eqvLam" type="number" step="0.01" min="0" max="10" value="0.90" style="width:74px"/>
              <input id="eqvMu" type="number" step="0.01" min="0" max="10" value="0.40" style="width:74px"/>
            </div>
            <div>
              <label>κ, Tperiod</label><br/>
              <input id="eqvKap" type="number" step="0.01" min="0" max="10" value="0.35" style="width:74px"/>
              <input id="eqvPer" type="number" step="0.1" min="0.1" max="60" value="4.0" style="width:74px"/>
            </div>
          </div>

          <div style="margin-top:10px">
            <label>Modes (a, ω, kx, ky, φ₀) one per line</label><br/>
            <textarea id="eqvModes" placeholder="0.25, 6.0, 4.0, 1.0, 0.0&#10;0.18, 9.0, -2.0, 3.0, 1.0"></textarea>
          </div>
        </details>
      </div>

      <div id="monoTiltWrap" class="monoStage">
        <canvas id="monoCanvas"></canvas>
      </div>


      <div class="card" style="margin-top:12px">
        <details id="monoHeavyDetails">
<summary class="pill" style="cursor:pointer;user-select:none"><b>Visualizations</b> (heavy compute)</summary>
                <div class="overlayRow" style="margin-top:10px;flex-wrap:wrap">
                  <label class="pill"><b>Task</b></label>
                  <select id="hvMode" style="min-width:190px">
                    
                    <option value="butterfly" selected>Chaotic butterfly (Lorenz)</option>
                    <option value="navier">Navier–Stokes (2D fluids)</option>
                    <option value="blackdisk">Airy diffraction (black disk)</option>
                    <option value="bh_shadow">Black hole shadow + accretion</option>
                    <option value="bh_lens">Black hole lensing starfield</option>
                    <option value="bh_geodesics">Photon geodesics around BH</option>
                    <option value="bh_ringdown">Ringdown waveform + spectrogram</option>
                    <option value="bh_disk">Accretion disk turbulence</option>
                  
                  </select>

                  <label class="pill"><b>Res</b></label>
                  <select id="hvRes" style="min-width:110px">
                    <option value="96">96</option>
                    <option value="128">128</option>
                    <option value="160">160</option>
                    <option value="192" selected>192</option>
                    <option value="256">256</option>
                    <option value="320">320</option>
                    <option value="384">384</option>
                    <option value="512">512</option>
                  </select>

                  <label class="pill"><b>Intensity</b></label>
                  <select id="hvPower" style="min-width:120px">
                    <option value="low">Low</option>
                    <option value="med" selected>Medium</option>
                    <option value="high">High</option>
                    <option value="max">Max</option>
                  </select>

                  <label class="pill"><b>Auto-start on Compute (camera)</b></label>
                  <input id="hvAuto" type="checkbox" />

                  <button id="hvStart">Start</button>
                  <button id="hvStop">Stop</button>

                  <span class="pill"><b>Status</b> <span id="hvState">idle</span>
                <div class="overlayRow" id="hvExtra" style="margin-top:10px;flex-wrap:wrap">
                  <span class="pill"><b>Disk radius</b></span>
                  <input id="hvBDRad" type="range" min="0.08" max="0.45" step="0.01" value="0.22" style="width:140px" />
                  <span class="pill"><b>BH tilt</b></span>
                  <input id="hvBHTilt" type="range" min="0" max="80" step="1" value="35" style="width:140px" />
                  <span class="pill"><b>BH spin</b></span>
                  <input id="hvBHSpin" type="range" min="0" max="0.99" step="0.01" value="0.35" style="width:140px" />
                  <span class="pill"><b>BH scale</b></span>
                  <input id="hvBHScale" type="range" min="2" max="18" step="0.1" value="8.0" style="width:140px" />
                  <label class="pill"><b>Stars</b></label>
                  <input id="hvBHStars" type="checkbox" checked />
                  <label class="pill"><b>Disk</b></label>
                  <input id="hvBHDisk" type="checkbox" checked />
                </div>
</span>
                </div>

                <div class="small" style="margin-top:6px">
                  Navier–Stokes supports touch/drag injection on the canvas. Black disk uses FFT and can reuse the current camera crop as a phase seed.
                </div>

                <div style="margin-top:10px">
                  <canvas id="hvCanvas" class="aqcCanvas"></canvas>
                </div>
                <div class="small" id="hvInfo" style="margin-top:8px"></div>
        </details>
      </div>

      <div class="monoText">
        <div class="row" style="flex-wrap:wrap;align-items:center">
          <button id="monoLoadText">Load monograph excerpt</button>
          <button id="monoClearText">Clear</button>
          <span class="pill"><b>State</b> <span id="monoState">idle</span></span>
        </div>
        <div id="monoText"></div>
      </div>
    </div>
  </div>



  <div id="viewLLM">
    <div class="grid">
      <div class="card">
        <div class="row" style="align-items:flex-end">
          <div style="flex:1;min-width:240px">
            <label>System / instructions</label><br/>
            <textarea id="llmSystem" placeholder="Optional: system prompt or constraints (stored locally)…"></textarea>
          </div>
          <div style="min-width:220px">
            <label>Backend</label><br/>
            <select id="llmBackend">
              <option value="local" selected>Local stub (offline)</option>
              <option value="openai">OpenAI-compatible endpoint</option>
              <option value="aqai">On-device AQAI LLM (trained here)</option>
            </select>
            <div class="small" style="margin-top:8px">
              The endpoint option calls a URL you provide with your key. This is a static HTML file — don’t paste a key here unless you accept the risk.
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end">
          <div style="flex:1;min-width:260px">
            <label>Endpoint URL (OpenAI-compatible)</label><br/>
            <input id="llmUrl" placeholder="https://example.com/v1/chat/completions" style="width:100%"/>
          </div>
          <div style="min-width:220px">
            <label>Model</label><br/>
            <input id="llmModel" placeholder="gpt-4.1-mini (or your server model)" style="width:100%"/>
          </div>
          <div style="min-width:260px">
            <label>API key (optional)</label><br/>
            <input id="llmKey" placeholder="Bearer token" style="width:100%"/>
          </div>
        </div>

        <div class="hr"></div>

        <label>Chat</label>
        <div id="llmLog" class="chatLog" aria-label="LLM chat log"></div>

        <div class="row" style="margin-top:10px;align-items:flex-end">
          <div style="flex:1;min-width:240px">
            <label>Message</label><br/>
            <textarea id="llmInput" placeholder="Type a message… (Shift+Enter for newline)"></textarea>
          </div>
          <div>
            <label>&nbsp;</label><br/>
            <button id="llmSend">Send</button>
          </div>
          <div>
            <label>&nbsp;</label><br/>
            <button id="llmSendPeer">Send to peer</button>
          </div>
          <span class="pill"><b>LLM</b> <span id="llmState">idle</span></span>
        </div>

        <div class="small" style="margin-top:8px">
          Tip: “Send to peer” uses the WebRTC DataChannel to mirror the message on the other phone (handy if one device does the endpoint call).
        </div>
      </div>

      <div class="card">
        <div style="font-weight:820;margin-bottom:8px">Quick actions</div>
        <div class="row">
          <button id="llmClear">Clear chat</button>
          <button id="llmSave">Save (local)</button>
          <button id="llmLoad">Load (local)</button>
        </div>
        <div class="hr"></div>
        <div class="small">
          This tab is intentionally minimal: it gives you a place to bolt in your preferred LLM (local or remote) and route requests over the DataChannel.
        </div>
      </div>
      <div class="card">
        <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div>
            <div class="h">Quantum AI Trainer</div>
            <div class="small">
              Phase/trigonometric model (complex amplitudes + unitary-like mixing) trained in-browser on the Iris CSV dataset.
              Source: <a id="qdsSource" href="https://storage.googleapis.com/download.tensorflow.org/data/iris_training.csv" target="_blank" rel="noopener">iris_training.csv</a>
              (test: <a id="qdsTest" href="https://storage.googleapis.com/download.tensorflow.org/data/iris_test.csv" target="_blank" rel="noopener">iris_test.csv</a>)
            </div>
          </div>
          <div class="pill" id="qtrainPill">idle</div>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end;flex-wrap:wrap">
          <div style="flex:1;min-width:260px">
            <label>Dataset</label><br/>
            <select id="qtrainDataset" style="width:100%">
              <option value="tf_iris" selected>TensorFlow Iris (120 train / 30 test)</option>
            </select>
            <div class="small" style="margin-top:6px">
              If the dataset fetch fails due to browser/network policy, a tiny embedded fallback will be used so the trainer still runs.
            </div>
          </div>
          <div style="min-width:320px">
            <label>Data actions</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <button id="qtrainVerify">Verify dataset links</button>
              <button id="qtrainLoad">Load dataset</button>
              <button id="qtrainShow">Show sample</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end;flex-wrap:wrap">
          <div style="flex:1;min-width:340px">
            <label>Hyperparameters</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <div class="kv"><span>Epochs</span><input id="qtrainEpochs" type="number" min="1" max="500" value="60" style="width:90px"/></div>
              <div class="kv"><span>Batch</span><input id="qtrainBatch" type="number" min="1" max="150" value="16" style="width:90px"/></div>
              <div class="kv"><span>LR</span><input id="qtrainLR" type="number" step="0.001" value="0.03" style="width:90px"/></div>
              <div class="kv"><span>Depth</span><input id="qtrainDepth" type="number" min="1" max="8" value="4" style="width:90px"/></div>
              <div class="kv"><span>Seed</span><input id="qtrainSeed" type="number" min="0" max="999999" value="1337" style="width:110px"/></div>
            </div>
          </div>
          <div style="min-width:360px">
            <label>Train / eval</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <button id="qtrainInit">Init model</button>
              <button id="qtrainRun">Train</button>
              <button id="qtrainStop">Stop</button>
              <button id="qtrainEval">Evaluate</button>
              <button id="qtrainExport">Export weights</button>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row" style="gap:10px;flex-wrap:wrap">
          <div class="kv"><span>Train acc</span><b id="qtrainAcc">—</b></div>
          <div class="kv"><span>Test acc</span><b id="qtestAcc">—</b></div>
          <div class="kv"><span>Loss</span><b id="qtrainLoss">—</b></div>
          <div class="kv"><span>Steps</span><b id="qtrainSteps">—</b></div>
          <div class="kv"><span>Status</span><b id="qtrainStatus">idle</b></div>
        </div>

        <pre id="qtrainLog" class="log" style="max-height:240px;margin-top:10px"></pre>

        <div class="hr"></div>

        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div class="small">
            Diagnostics: checks that all buttons exist, that key click-handlers are wired, and that dataset links are fetchable.
          </div>
          <div class="row" style="flex-wrap:wrap">
            <button id="qdiagRun">Run diagnostics</button>
            <button id="qdiagCopy">Copy report</button>
          </div>
        </div>

        <pre id="qdiagOut" class="log" style="max-height:200px;margin-top:10px"></pre>
      </div>


      <div class="card">
        <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div>
            <div class="h">AQAI LLM (on-device Transformer)</div>
            <div class="small">
              Train a small causal Transformer in-browser on a larger text corpus (Project Gutenberg books).
              Uses <b>quantum phase rotation</b> (RoPE-style complex rotation) and an optional <b>modular entropy</b> regularizer.
              Default corpus links:
              <a id="aqaiLinkWP" href="https://raw.githubusercontent.com/GITenberg/War-and-Peace_2600/master/2600-0.txt" target="_blank" rel="noopener">War and Peace</a>,
              <a id="aqaiLinkMD" href="https://raw.githubusercontent.com/GITenberg/Moby-Dick--Or-The-Whale_2701/master/2701-0.txt" target="_blank" rel="noopener">Moby-Dick</a>,
              <a id="aqaiLinkCP" href="https://raw.githubusercontent.com/GITenberg/Crime-and-Punishment_2554/master/2554-0.txt" target="_blank" rel="noopener">Crime and Punishment</a>,
              <a id="aqaiLinkPP" href="https://raw.githubusercontent.com/GITenberg/Pride-and-Prejudice_1342/master/1342-0.txt" target="_blank" rel="noopener">Pride and Prejudice</a>,
              <a id="aqaiLinkFR" href="https://raw.githubusercontent.com/GITenberg/Frankenstein--Or-The-Modern-Prometheus_84/master/84-0.txt" target="_blank" rel="noopener">Frankenstein</a>.
            </div>
          </div>
          <div class="pill" id="aqaiPill">idle</div>
        </div>

        <div class="hr"></div>

        <div class="row" style="align-items:flex-end;flex-wrap:wrap">
          <div style="min-width:260px">
            <label>TensorFlow.js</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <button id="aqaiLoadTf">Load TF.js</button>
              <button id="aqaiBackendWebgl">Use WebGL</button>
              <button id="aqaiBackendCpu">Use CPU</button>
            </div>
            <div class="small" style="margin-top:6px">
              TF.js loads from jsDelivr (pinned). If you run this file offline, load won’t work.
            </div>
          </div>

          <div style="flex:1;min-width:300px">
            <label>Corpus</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <label class="pill" style="cursor:pointer"><input type="checkbox" id="aqaiCkWP" checked/> War &amp; Peace</label>
              <label class="pill" style="cursor:pointer"><input type="checkbox" id="aqaiCkMD" checked/> Moby-Dick</label>
              <label class="pill" style="cursor:pointer"><input type="checkbox" id="aqaiCkCP" checked/> Crime &amp; Punishment</label>
              <label class="pill" style="cursor:pointer"><input type="checkbox" id="aqaiCkPP" /> Pride &amp; Prejudice</label>
              <label class="pill" style="cursor:pointer"><input type="checkbox" id="aqaiCkFR" /> Frankenstein</label>
            </div>
            <div class="row" style="align-items:flex-end;flex-wrap:wrap;margin-top:8px">
              <div class="kv"><span>Max MB / book</span><input id="aqaiMaxMB" type="number" min="1" max="200" value="25" style="width:90px"/></div>
              <div class="kv"><span>Total cap MB</span><input id="aqaiTotalMB" type="number" min="1" max="400" value="80" style="width:90px"/></div>
              <button id="aqaiVerifyLinks">Verify links</button>
              <button id="aqaiDownload">Download corpus</button>
              <span class="pill"><b>Bytes</b> <span id="aqaiBytes">0</span></span>
            </div>
            <div class="small" style="margin-top:6px">
              Note: some browsers block <span class="mono">fetch()</span> from <span class="mono">file://</span>. If downloads fail, open the file through a local HTTP server.
            </div>
          </div>
        </div>

        
        <div class="hr"></div>

        <div style="margin-top:10px">
          <div style="font-weight:820;margin-bottom:6px">Hugging Face Parquet corpus (large)</div>
          <div class="small">
            Lists parquet shards via the HF datasets-server <span class="mono">/parquet</span> endpoint and streams <span class="mono">text</span>-like rows into the AQAI byte-buffer (256-token byte-level LLM).
          </div>

          <div class="row" style="flex-wrap:wrap;align-items:flex-end;margin-top:8px">
            <div class="kv"><span>Dataset</span><input id="aqaiHfDataset" value="HuggingFaceFW/fineweb-edu" style="min-width:320px;width:360px"/></div>
            <button id="aqaiHfList">List shards</button>
            <button id="aqaiHfVerify">Verify</button>
            <button id="aqaiHfStop">Stop</button>
            <span class="pill" id="aqaiHfPill">idle</span>
          </div>

          <div class="row" style="flex-wrap:wrap;align-items:flex-end;margin-top:8px">
            <div class="kv"><span>Config</span>
              <select id="aqaiHfConfig"><option value="*">all</option></select>
            </div>
            <div class="kv"><span>Split</span>
              <select id="aqaiHfSplit">
                <option value="train" selected>train</option>
                <option value="validation">validation</option>
                <option value="test">test</option>
                <option value="*">all</option>
              </select>
            </div>
            <div class="kv"><span>Text col</span>
              <select id="aqaiHfTextCol"><option value="auto" selected>auto</option></select>
            </div>
            <div class="kv"><span>Max rows</span><input id="aqaiHfMaxRows" type="number" min="100" max="5000000" value="50000" style="width:130px"/></div>
            <div class="kv"><span>Batch rows</span><input id="aqaiHfBatchRows" type="number" min="32" max="4096" value="256" style="width:110px"/></div>
            <div class="kv"><span>Buffer MB</span><input id="aqaiHfBufMB" type="number" min="16" max="512" value="128" style="width:100px"/></div>

            <button id="aqaiHfLoad">Stream → Buffer</button>
            <button id="aqaiHfAuto">Auto: Stream + Init + Train</button>
          </div>

          <div class="small" style="margin-top:6px">
            <span class="mono" id="aqaiHfStatus">—</span>
          </div>

          <div id="aqaiHfFiles" class="small" style="margin-top:6px;max-height:220px;overflow:auto;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px;background:rgba(0,0,0,.12)"></div>
        </div>


        <div class="row" style="align-items:flex-end;flex-wrap:wrap">
          <div style="flex:1;min-width:360px">
            <label>Model + training</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <div class="kv"><span>Seq</span><input id="aqaiSeq" type="number" min="16" max="512" value="96" style="width:90px"/></div>
              <div class="kv"><span>Batch</span><input id="aqaiBatch" type="number" min="1" max="128" value="16" style="width:90px"/></div>
              <div class="kv"><span>d_model</span><input id="aqaiD" type="number" min="32" max="512" value="128" style="width:90px"/></div>
              <div class="kv"><span>Heads</span><input id="aqaiH" type="number" min="1" max="16" value="4" style="width:90px"/></div>
              <div class="kv"><span>Layers</span><input id="aqaiL" type="number" min="1" max="12" value="3" style="width:90px"/></div>
              <div class="kv"><span>d_ff</span><input id="aqaiFF" type="number" min="64" max="2048" value="256" style="width:90px"/></div>
              <div class="kv"><span>LR</span><input id="aqaiLR" type="number" step="0.0001" min="0.0001" max="0.02" value="0.002" style="width:90px"/></div>
              <div class="kv"><span>Steps</span><input id="aqaiSteps" type="number" min="1" max="200000" value="2000" style="width:110px"/></div>
            </div>

            <div class="row" style="flex-wrap:wrap;margin-top:8px">
              <label class="pill" style="cursor:pointer"><input id="aqaiUseRoPE" type="checkbox" checked/> Quantum phase (RoPE)</label>
              <label class="pill" style="cursor:pointer"><input id="aqaiUseME" type="checkbox" checked/> Modular entropy</label>
              <div class="kv"><span>prime p</span><input id="aqaiPrime" type="number" min="2" max="251" value="17" style="width:90px"/></div>
              <div class="kv"><span>λ</span><input id="aqaiLam" type="number" step="0.001" min="0" max="5" value="0.05" style="width:90px"/></div>
              <select id="aqaiMeMode">
                <option value="max" selected>maximize entropy</option>
                <option value="min">minimize entropy</option>
              </select>
            </div>

            <div class="row" style="flex-wrap:wrap;margin-top:10px">
              <button id="aqaiInit">Init model</button>
              <button id="aqaiTrain">Train</button>
              <button id="aqaiStop">Stop</button>
              <button id="aqaiEval">Evaluate</button>
              <button id="aqaiUse">Use in chat</button>
              <button id="aqaiExport">Export checkpoint</button>
              <label class="pill" style="cursor:pointer">
                Import <input id="aqaiImport" type="file" accept="application/json" style="display:none"/>
              </label>
            </div>
          </div>

          <div style="min-width:320px;flex:1">
            <label>Generation</label><br/>
            <div class="row" style="flex-wrap:wrap">
              <div class="kv"><span>Temp</span><input id="aqaiTemp" type="number" step="0.05" min="0.05" max="2.0" value="0.7" style="width:90px"/></div>
              <div class="kv"><span>Top-k</span><input id="aqaiTopk" type="number" min="0" max="200" value="20" style="width:90px"/></div>
              <div class="kv"><span>Max new</span><input id="aqaiMaxNew" type="number" min="1" max="400" value="160" style="width:110px"/></div>
              
              <div class="kv"><span>Decode</span>
                <select id="aqaiDecodeMode" style="width:120px">
                  <option value="escaped" selected>Escaped</option>
                  <option value="utf8">UTF‑8</option>
                  <option value="latin1">Latin‑1</option>
                  <option value="hex">Hex</option>
                </select>
              </div>
              <label class="pill" title="Keep generation printable (helps on undertrained models)"><input type="checkbox" id="aqaiAsciiOnly" checked style="margin-right:6px">ASCII only</label>
<button id="aqaiGenerate">Generate</button>
              <button id="aqaiClearGen">Clear</button>
            </div>
            <textarea id="aqaiPrompt" placeholder="Prompt for AQAI generation…" style="height:84px;margin-top:8px"></textarea>
            <pre id="aqaiGenOut" class="log" style="max-height:220px;margin-top:10px"></pre>
          </div>
        </div>

        <div class="hr"></div>

        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div class="small">
            AQAI diagnostics: verifies required buttons are wired, TF.js is available, and dataset links respond.
          </div>
          <div class="row" style="flex-wrap:wrap">
            <button id="aqaiDiag">Run AQAI checks</button>
            <button id="aqaiDiagCopy">Copy AQAI report</button>
          </div>
        </div>
        <pre id="aqaiDiagOut" class="log" style="max-height:200px;margin-top:10px"></pre>

        <pre id="aqaiLog" class="log" style="max-height:240px;margin-top:10px"></pre>
      </div>

    </div>
  </div>


<!-- QR Modal -->
<div id="qrModal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.72);z-index:9999;padding:16px">
  <div style="max-width:760px;width:100%;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:14px;box-shadow:0 18px 60px rgba(0,0,0,.45)">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
      <div>
        <div style="font-weight:820">QR Handshake</div>
        <div class="small" id="qrHelp">—</div>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="qrClose">Close</button>
      </div>
    </div>
    <div class="hr"></div>
    <div id="qrShowPane" style="display:none">
      <div class="row" style="align-items:center">
        <span class="pill"><b>Mode</b> show</span>
        <span class="pill"><b>Chunk</b> <span id="qrChunk">—</span></span>
        <span class="pill"><b>ID</b> <span id="qrId" class="mono">—</span></span>
      </div>
      <div style="display:flex;justify-content:center;margin-top:12px">
        <canvas id="qrCanvas" width="360" height="360" style="border-radius:14px;border:1px solid rgba(255,255,255,.10);background:#fff"></canvas>
      </div>
      <div class="row" style="justify-content:center;margin-top:10px">
        <button id="qrPrev">◀ Prev</button>
        <button id="qrPlay">Auto</button>
        <button id="qrNext">Next ▶</button>
      </div>
    </div>

    <div id="qrScanPane" style="display:none">
      <div class="row" style="align-items:center">
        <span class="pill"><b>Mode</b> scan</span>
        <span class="pill"><b>Got</b> <span id="qrGot">0</span>/<span id="qrTot">0</span></span>
        <span class="pill"><b>ID</b> <span id="qrScanId" class="mono">—</span></span>
        <span class="pill"><b>Status</b> <span id="qrScanStatus">—</span></span>
      </div>
      <div style="display:flex;justify-content:center;margin-top:12px">
        <video id="qrVideo" autoplay playsinline muted style="width:min(560px,100%);border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18)"></video>
      </div>
      <div class="small" style="margin-top:10px">
        Tip: point your camera at the QR. For multi‑chunk payloads, keep scanning as the other phone flips chunks.
      </div>
    </div>
  </div>
</div>


<div id="viewAQC" style="display:none">
  <div class="grid">
    <div class="card">
      <h2 style="margin:0 0 6px">Pen‑and‑lens AQC masks</h2>
      <div class="small">
        Generate printable masks for a 4f optical system (mask at the Fourier plane) and preview them as an overlay on your phone’s local camera.
      </div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <div>
          <label>Template</label><br/>
          <select id="aqcTemplate">
            <option value="cup" selected>Basic resonance cup</option>
            <option value="phase">Phase gate (parity mask)</option>
            <option value="foam">Foam perturbation test</option>
          </select>
        </div>
        <div>
          <label>Width (mm)</label><br/>
          <input id="aqcWmm" type="number" min="10" max="60" step="1" value="30" style="width:120px"/>
        </div>
        <div>
          <label>Height (mm)</label><br/>
          <input id="aqcHmm" type="number" min="10" max="60" step="1" value="20" style="width:120px"/>
        </div>
        <div>
          <label>DPI</label><br/>
          <input id="aqcDpi" type="number" min="150" max="2400" step="50" value="600" style="width:120px"/>
        </div>
      </div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <div>
          <label>y₀</label><br/>
          <input id="aqcY0" type="number" min="1.1" max="10" step="0.1" value="2.0" style="width:120px"/>
        </div>
        <div>
          <label>R (mm)</label><br/>
          <input id="aqcR" type="number" min="2" max="25" step="0.5" value="10" style="width:120px"/>
        </div>
        <div>
          <label>k</label><br/>
          <input id="aqcK" type="number" min="2" max="10" step="1" value="3" style="width:120px"/>
        </div>
        <div>
          <label>Slit d (mm)</label><br/>
          <input id="aqcD" type="number" min="0.5" max="10" step="0.1" value="2.0" style="width:120px"/>
        </div>
        <div>
          <label>Slit w (mm)</label><br/>
          <input id="aqcSlitW" type="number" min="0.05" max="2" step="0.05" value="0.2" style="width:120px"/>
        </div>
        <div>
          <label>Seed</label><br/>
          <input id="aqcSeed" type="number" min="0" max="999999" step="1" value="2025" style="width:120px"/>
        </div>
      </div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <button id="aqcRender">Render</button>
        <button id="aqcToOverlay">Use as local overlay</button>
        <button id="aqcExportPng">Export PNG</button>
        <button id="aqcExportSvg">Export SVG</button>
        <button id="aqcCopyAscii">Copy ASCII</button>
      </div>

      <div style="margin-top:10px">
        <canvas id="aqcCanvas" class="aqcCanvas"></canvas>
      </div>

      <div class="hr"></div>
      <label>ASCII templates (quick trace reference)</label>
      <pre id="aqcAscii" class="aqcAscii"></pre>

      <div class="hr"></div>
      <label>Phone-camera alignment checklist</label>
      <div class="small">
        1) Start media in TRX. 2) Tap “Layout” on Local and choose an overlay. 3) Align your physical mask until the live fringe/pattern matches. 4) Enable “Quantum compute mode” to remove overlays for capture.
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 6px">Quick overlay controls</h2>
      <div class="small">These mirror the Local “Layout” panel, but stay available here while you design.</div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <button id="aqcOvNone">Overlay: None</button>
        <button id="aqcOvCup">Overlay: Cup</button>
        <button id="aqcOvPhase">Overlay: Phase</button>
        <button id="aqcOvFoam">Overlay: Foam</button>
      </div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <label class="pill"><b>Overlay size</b> <span id="aqcOvSizeLabel">20mm</span></label>
        <input id="aqcOvSize" type="range" min="8" max="40" step="1" value="20" style="flex:1;min-width:160px"/>
      </div>
      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <label class="pill"><b>Overlay opacity</b> <span id="aqcOvOpLabel">70%</span></label>
        <input id="aqcOvOpacity" type="range" min="10" max="95" step="1" value="70" style="flex:1;min-width:160px"/>
      </div>

      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <button id="aqcToggleQc">Quantum compute mode (hide overlay)</button>
        <span class="pill"><b>Status</b> <span id="aqcQcState">idle</span></span>
      </div>

      <div class="hr"></div>
      <h2 style="margin:0 0 6px">Checks</h2>
      <div class="small">Verifies AQC buttons, overlay wiring, and that downloads are not blocked.</div>
      <div class="row" style="flex-wrap:wrap;margin-top:10px">
        <button id="aqcDiag">Run AQC checks</button>
        <button id="aqcDiagCopy">Copy report</button>
      </div>
      <pre id="aqcDiagOut" class="aqcAscii" style="margin-top:10px;max-height:260px"></pre>

      <div class="hr"></div>
      <label>Notes</label>
      <div class="small">
        The mask math here follows the paper’s 4f operator form and the cup ceiling interpolation definition.
        Keep your printing scale at 100% (no “fit to page”).
      </div>
    </div>
  </div>
</div>


  <div id="viewLAYOUTS" style="display:none">
    <div class="card">
      <h2>Layouts & Photonics Architectures</h2>
      <div class="small">
        Pick a layout and push it to the TRX camera overlay. Use <b>Compute</b> to analyze real paper masks (graphene drawings, slits, gratings) directly from the live camera feed.
      </div>

      <div class="row" style="margin-top:10px;flex-wrap:wrap">
        <input id="layoutsSearch" placeholder="Search layouts…" style="flex:1;min-width:220px" />
        <select id="layoutsCategory" style="min-width:180px">
          <option value="all" selected>All categories</option>
          <option value="cup">Cups / horizons</option>
          <option value="gates">Gates / circuits</option>
          <option value="interference">Interference</option>
          <option value="diffractive">Diffractive optics</option>
          <option value="vortex">Vortex / OAM</option>
          <option value="lattices">Lattices (graphene)</option>
        </select>
        <button id="layoutsApply">Apply to camera overlay</button>
        <button id="layoutsOpenOverlay">Open overlay panel</button>
        <button id="layoutsCompute">Compute from camera</button>
      </div>

      <div class="row" style="margin-top:12px;align-items:flex-start">
        <div style="flex:0 0 320px;min-width:240px">
          <div class="small" id="layoutsSelectedName">Selected: (none)</div>
          <canvas id="layoutsPreview" class="aqcCanvas"></canvas>
          <div class="small" id="layoutsInfo" style="margin-top:8px"></div>
        </div>
        <div style="flex:1;min-width:260px">
          <div id="layoutsGrid" class="gridLayouts"></div>
        </div>
      </div>

      <details style="margin-top:12px">
        <summary class="pill" style="cursor:pointer;user-select:none"><b>Tips for phone camera</b></summary>
        <div class="small" style="margin-top:8px">
          <ul>
            <li>Keep the paper flat, fill most of the frame, and lock exposure/focus if your camera app supports it.</li>
            <li>Use the <b>ROI</b> slider in Compute to crop to the mask area and reduce background clutter.</li>
            <li>For graphite “graphene” shading, raise <b>Threshold</b> and try <b>Invert</b> if the mask is light-on-dark.</li>
          </ul>
        </div>
      </details>
    </div>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  function setStatusToast(msg){ const el=$("statusToast"); if(el) el.textContent=String(msg||""); }
  window.addEventListener("error", (e)=>{ try{ const msg = (e?.message || e?.error?.message || String(e?.error||e||"unknown")); setStatusToast("JS error: " + msg); }catch{} try{ stopAllNow("JS error"); }catch{} });
  window.addEventListener("unhandledrejection", (e)=>{ try{ setStatusToast("Promise error: " + (e.reason?.message||e.reason||"unknown")); }catch{} });

  function parseJsonLoose(txt){
    const s = String(txt||"").trim().replace(/\u0000/g,"");
    if(!s) throw new Error("empty JSON");
    try{ return JSON.parse(s); }catch(e){}
    // try slicing the first balanced object (handles trailing garbage)
    const a = s.indexOf("{");
    const b = s.lastIndexOf("}");
    if(a!==-1 && b!==-1 && b>a){
      try{ return JSON.parse(s.slice(a,b+1)); }catch(e){}
    }
    // try array slice
    const aa = s.indexOf("[");
    const bb = s.lastIndexOf("]");
    if(aa!==-1 && bb!==-1 && bb>aa){
      try{ return JSON.parse(s.slice(aa,bb+1)); }catch(e){}
    }
    throw new Error("invalid JSON");
  }

  const logEl = $("log");
  const localV = $("local");
  const remoteV = $("remote");

  let pc = null;
  let dc = null;
  let localStream = null;      // raw getUserMedia stream
  let sendStream = null;       // stream attached to RTCPeerConnection (raw or overlay)
  let overlayStream = null;
  let overlayRaf = null;
  let rawVideoEl = null;
  let overlayCanvas = null;
  let statsTimer = null;
  const statsPrev = {ts:0, outVBytes:0, inVBytes:0, outABytes:0, inABytes:0};
  let candN = 0;

  function log(msg, dim=false){
    const div=document.createElement("div");
    if(dim) div.className="dim";
    div.textContent = msg;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // Global stop / abort flags
  const RUNCTL = { stopAll:false, computeAbort:false };

  
  function panicVisible(on){ try{ document.body.classList.toggle("panicOn", !!on); }catch{} }
function stopAllNow(reason){
    RUNCTL.stopAll = true;
    RUNCTL.computeAbort = true;
    setStatusToast("STOP: " + (reason||""));
    panicVisible(false);
    try{ if(window.tf && tf.engine) {} }catch{}
    // stop heavy viz
    try{ hvVizStop(); }catch{}
    // stop AQAI training
    try{ if(typeof aqaiStopTraining==="function") aqaiStopTraining(); }catch{}
    try{ if(typeof aqaiStop==="function") aqaiStop(); }catch{}
    // stop monograph / overlay loops
    try{ if(typeof monoStop==="function") monoStop(); }catch{}
    try{ if(overlayRaf){ cancelAnimationFrame(overlayRaf); overlayRaf=null; } }catch{}
    try{ if(statsTimer){ clearInterval(statsTimer); statsTimer=null; } }catch{}
    // release compute busy flags
    try{ AQC.computeBusy=false; AQC.qcActive=false; }catch{}
    try{ setQuantumComputingActive(false); aqcApplyOverlayState(); }catch{}
  }

  // wire panic stop button
  setTimeout(()=>{
    const b = $("panicStop");
    if(b) b.addEventListener("click", ()=>stopAllNow("user"));
  }, 0);


  function fmtKbps(bps){
    if(!Number.isFinite(bps)) return "—";
    const kb = bps/1000;
    if(kb < 1000) return kb.toFixed(0) + " kbps";
    return (kb/1000).toFixed(2) + " Mbps";
  }

  function stopOverlay(){
    if(overlayRaf){ cancelAnimationFrame(overlayRaf); overlayRaf=null; }
    if(overlayStream){
      try{ overlayStream.getTracks().forEach(t=>t.stop()); }catch{}
      overlayStream=null;
    }
    rawVideoEl = null;
    overlayCanvas = null;
  }

  function buildOverlayStream(rawStream){
    const vTrack = rawStream.getVideoTracks()[0];
    if(!vTrack) return null;

    rawVideoEl = document.createElement("video");
    rawVideoEl.srcObject = new MediaStream([vTrack]);
    rawVideoEl.muted = true;
    rawVideoEl.playsInline = true;

    overlayCanvas = document.createElement("canvas");
    const st = vTrack.getSettings ? vTrack.getSettings() : {};
    const W = st.width || 640;
    const H = st.height || 360;
    overlayCanvas.width = W;
    overlayCanvas.height = H;
    const ctx = overlayCanvas.getContext("2d");

    const draw = ()=>{
      try{
        if(rawVideoEl.readyState >= 2){
          ctx.drawImage(rawVideoEl, 0, 0, W, H);
          const now = new Date();
          const ts = now.toISOString().replace("T"," ").replace("Z"," UTC");
          ctx.fillStyle = "rgba(0,0,0,.45)";
          ctx.fillRect(10, 10, 430, 56);
          ctx.fillStyle = "rgba(233,242,255,.92)";
          ctx.font = "20px ui-monospace, Menlo, Consolas, monospace";
          ctx.fillText(ts, 18, 42);
          ctx.font = "14px ui-monospace, Menlo, Consolas, monospace";
          ctx.fillStyle = "rgba(106,228,255,.92)";
          ctx.fillText("LIVE CAMERA → CANVAS → WebRTC", 18, 62);
        }
      } catch {}
      overlayRaf = requestAnimationFrame(draw);
    };

    rawVideoEl.play().then(()=>{
      overlayRaf = requestAnimationFrame(draw);
    }).catch(()=>{
      overlayRaf = requestAnimationFrame(draw);
    });

    const stream = overlayCanvas.captureStream ? overlayCanvas.captureStream(30) : null;
    return stream;
  }

  function attachSendTracks(stream){
    if(!pc) return;
    try{
      const senders = pc.getSenders ? pc.getSenders() : [];
      for(const s of senders){
        if(s && s.track){
          try{ pc.removeTrack(s); }catch{}
        }
      }
    }catch{}
    for(const track of stream.getTracks()){
      pc.addTrack(track, stream);
    }
  }

  function startStatsLoop(){
    if(statsTimer) clearInterval(statsTimer);
    statsTimer = setInterval(async ()=>{
      if(!pc) return;
      try{
        const reports = await pc.getStats();
        let outV=null, inV=null, outA=null, inA=null, candPair=null;

        reports.forEach(r=>{
          if(r.type==="outbound-rtp" && !r.isRemote){
            if(r.kind==="video") outV = r;
            if(r.kind==="audio") outA = r;
          }
          if(r.type==="inbound-rtp" && !r.isRemote){
            if(r.kind==="video") inV = r;
            if(r.kind==="audio") inA = r;
          }
          if(r.type==="candidate-pair" && r.state==="succeeded" && r.nominated){
            candPair = r;
          }
        });

        const now = performance.now();
        const dt = (statsPrev.ts>0) ? (now - statsPrev.ts)/1000 : 0;
        let txVbps=null, rxVbps=null, txAbps=null, rxAbps=null;

        if(dt>0 && outV && Number.isFinite(outV.bytesSent)){
          txVbps = (outV.bytesSent - statsPrev.outVBytes)*8/dt;
          statsPrev.outVBytes = outV.bytesSent;
        }
        if(dt>0 && inV && Number.isFinite(inV.bytesReceived)){
          rxVbps = (inV.bytesReceived - statsPrev.inVBytes)*8/dt;
          statsPrev.inVBytes = inV.bytesReceived;
        }
        if(dt>0 && outA && Number.isFinite(outA.bytesSent)){
          txAbps = (outA.bytesSent - statsPrev.outABytes)*8/dt;
          statsPrev.outABytes = outA.bytesSent;
        }
        if(dt>0 && inA && Number.isFinite(inA.bytesReceived)){
          rxAbps = (inA.bytesReceived - statsPrev.inABytes)*8/dt;
          statsPrev.inABytes = inA.bytesReceived;
        }
        statsPrev.ts = now;

        const jitter = (inA && Number.isFinite(inA.jitter)) ? inA.jitter : null;
        let rtt=null, availOut=null;
        if(candPair){
          if(Number.isFinite(candPair.currentRoundTripTime)) rtt = candPair.currentRoundTripTime;
          if(Number.isFinite(candPair.availableOutgoingBitrate)) availOut = candPair.availableOutgoingBitrate;

          const l = candPair.localCandidateId ? reports.get(candPair.localCandidateId) : null;
          const r = candPair.remoteCandidateId ? reports.get(candPair.remoteCandidateId) : null;
          const lp = l ? `${l.protocol||"?"}/${l.candidateType||"?"}` : "?";
          const rp = r ? `${r.protocol||"?"}/${r.candidateType||"?"}` : "?";
          $("stPair").textContent = `${lp} ↔ ${rp}`;
        } else {
          $("stPair").textContent = "—";
        }

        $("stTxV").textContent = `${fmtKbps(txVbps)} • pkts ${outV?.packetsSent ?? "—"} • lost ${outV?.packetsLost ?? "—"}`;
        $("stRxV").textContent = `${fmtKbps(rxVbps)} • pkts ${inV?.packetsReceived ?? "—"} • lost ${inV?.packetsLost ?? "—"}`;
        $("stTxA").textContent = `${fmtKbps(txAbps)} • pkts ${outA?.packetsSent ?? "—"} • lost ${outA?.packetsLost ?? "—"}`;
        $("stRxA").textContent = `${fmtKbps(rxAbps)} • pkts ${inA?.packetsReceived ?? "—"} • lost ${inA?.packetsLost ?? "—"}`;
        $("stRtt").textContent = (rtt!=null) ? `${(rtt*1000).toFixed(1)} ms` : "—";
        $("stJit").textContent = (jitter!=null) ? `${(jitter*1000).toFixed(1)} ms` : "—";
        $("stAvail").textContent = (availOut!=null) ? fmtKbps(availOut) : "—";
      }catch{}
    }, 900);
  }

  function stopStatsLoop(){
    if(statsTimer) clearInterval(statsTimer);
    statsTimer = null;
  }
  

  // ---------------- QR (multi-chunk) handshake ----------------
  // SDP blobs can be big; a single QR often can't hold it. We chunk + animate.
  // Encoding: BAZQR1/<id>/<tot>/<idx>/<flags>:<payload>
  // flags: 'g' if gzip, '-' otherwise.
  const QR = (() => {
    function make(typeNumber, errorCorrectionLevel) { return QRCode(typeNumber, errorCorrectionLevel); }

    function QRCode(typeNumber, errorCorrectionLevel) {
      const PAD0 = 0xEC, PAD1 = 0x11;
      const _typeNumber = typeNumber;
      const _errorCorrectionLevel = errorCorrectionLevel;
      let _modules = null;
      let _moduleCount = 0;
      let _dataList = [];

      function utf8Bytes(str){ return new TextEncoder().encode(str); }
      function QR8bitByte(data){
        const _data = utf8Bytes(data);
        return { getMode:()=>4, getLength:()=>_data.length, write:(buffer)=>{ for(let i=0;i<_data.length;i++) buffer.put(_data[i],8); } };
      }
      function BitBuffer(){
        let _buffer=[], _length=0;
        return {
          getBuffer:()=>_buffer,
          put:(num,len)=>{ for(let i=0;i<len;i++) this.putBit(((num >>> (len-i-1)) & 1)===1); },
          putBit:(bit)=>{
            const bufIndex = Math.floor(_length/8);
            if(_buffer.length <= bufIndex) _buffer.push(0);
            if(bit) _buffer[bufIndex] |= (0x80 >>> (_length % 8));
            _length++;
          },
          getLengthInBits:()=>_length
        };
      }

      // GF(256)
      const EXP=new Array(512), LOG=new Array(256);
      (function(){
        let x=1;
        for(let i=0;i<256;i++){
          EXP[i]=x; LOG[x]=i;
          x <<= 1;
          if(x & 0x100) x ^= 0x11d;
        }
        for(let i=256;i<512;i++) EXP[i]=EXP[i-256];
      })();
      function gfMul(a,b){ if(a===0||b===0) return 0; return EXP[LOG[a]+LOG[b]]; }
      function Poly(num, shift){
        let _num=num.slice();
        for(let i=0;i<shift;i++) _num.push(0);
        return {
          getLength:()=>_num.length,
          get:(i)=>_num[i],
          mul:(e)=>{
            const out=new Array(_num.length+e.getLength()-1).fill(0);
            for(let i=0;i<_num.length;i++) for(let j=0;j<e.getLength();j++) out[i+j] ^= gfMul(_num[i], e.get(j));
            return Poly(out,0);
          },
          mod:(e)=>{
            if(this.getLength()-e.getLength()<0) return this;
            const ratio = LOG[this.get(0)] - LOG[e.get(0)];
            const out=_num.slice();
            for(let i=0;i<e.getLength();i++) out[i] ^= EXP[LOG[e.get(i)] + ratio];
            return Poly(out,0).mod(e);
          }
        };
      }
      function rsGeneratorPoly(ecLen){
        let poly=Poly([1],0);
        for(let i=0;i<ecLen;i++) poly = poly.mul(Poly([1,EXP[i]],0));
        return poly;
      }

      const EC_LEVELS={L:1,M:0,Q:3,H:2};
      function getBCHDigit(data){ let digit=0; while(data!==0){ digit++; data >>>=1; } return digit; }
      function getBCHTypeInfo(data){
        let d = data << 10;
        const g = 0b10100110111;
        while(getBCHDigit(d)-getBCHDigit(g)>=0) d ^= (g << (getBCHDigit(d)-getBCHDigit(g)));
        return ((data<<10)|d) ^ 0b101010000010010;
      }
      function getPatternPosition(tn){
        const table=[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54]];
        return table[tn] || table[10];
      }
      function getMask(mp,i,j){
        switch(mp){
          case 0:return (i+j)%2===0;
          case 1:return i%2===0;
          case 2:return j%3===0;
          case 3:return (i+j)%3===0;
          case 4:return (Math.floor(i/2)+Math.floor(j/3))%2===0;
          case 5:return ((i*j)%2)+((i*j)%3)===0;
          case 6:return (((i*j)%2)+((i*j)%3))%2===0;
          case 7:return (((i+j)%2)+((i*j)%3))%2===0;
          default:return false;
        }
      }

      function setupPositionProbePattern(row,col){
        for(let r=-1;r<=7;r++){
          if(row+r<=-1||_moduleCount<=row+r) continue;
          for(let c=-1;c<=7;c++){
            if(col+c<=-1||_moduleCount<=col+c) continue;
            if((0<=r&&r<=6&&(c===0||c===6))||(0<=c&&c<=6&&(r===0||r===6))||(2<=r&&r<=4&&2<=c&&c<=4)) _modules[row+r][col+c]=true;
            else _modules[row+r][col+c]=false;
          }
        }
      }
      function setupTimingPattern(){
        for(let i=8;i<_moduleCount-8;i++){
          if(_modules[i][6]===null) _modules[i][6]=(i%2===0);
          if(_modules[6][i]===null) _modules[6][i]=(i%2===0);
        }
      }
      function setupPositionAdjustPattern(){
        const pos=getPatternPosition(_typeNumber);
        for(let i=0;i<pos.length;i++){
          for(let j=0;j<pos.length;j++){
            const row=pos[i], col=pos[j];
            if(_modules[row][col]!==null) continue;
            for(let r=-2;r<=2;r++){
              for(let c=-2;c<=2;c++){
                if(r===-2||r===2||c===-2||c===2||(r===0&&c===0)) _modules[row+r][col+c]=true;
                else _modules[row+r][col+c]=false;
              }
            }
          }
        }
      }
      function setupTypeInfo(test, maskPattern){
        const data=(EC_LEVELS[_errorCorrectionLevel]<<3)|maskPattern;
        const bits=getBCHTypeInfo(data);
        for(let i=0;i<15;i++){
          const mod=(!test && ((bits>>i)&1)===1);
          if(i<6) _modules[i][8]=mod;
          else if(i<8) _modules[i+1][8]=mod;
          else _modules[_moduleCount-15+i][8]=mod;

          if(i<8) _modules[8][_moduleCount-i-1]=mod;
          else if(i<9) _modules[8][15-i-1+1]=mod;
          else _modules[8][15-i-1]=mod;
        }
        _modules[_moduleCount-8][8]=(!test);
      }
      function mapData(data, maskPattern){
        let inc=-1, row=_moduleCount-1, bitIndex=7, byteIndex=0;
        for(let col=_moduleCount-1;col>0;col-=2){
          if(col===6) col--;
          while(true){
            for(let c=0;c<2;c++){
              if(_modules[row][col-c]===null){
                let dark=false;
                if(byteIndex < data.length) dark = ((data[byteIndex]>>>bitIndex)&1)===1;
                const mask=getMask(maskPattern,row,col-c);
                _modules[row][col-c]= mask ? !dark : dark;
                bitIndex--;
                if(bitIndex===-1){ byteIndex++; bitIndex=7; }
              }
            }
            row += inc;
            if(row<0||_moduleCount<=row){ row -= inc; inc = -inc; break; }
          }
        }
      }

      const RS_BLOCK_TABLE_L={
        1:[{totalCount:26,dataCount:19}],
        2:[{totalCount:44,dataCount:34}],
        3:[{totalCount:70,dataCount:55}],
        4:[{totalCount:100,dataCount:80}],
        5:[{totalCount:134,dataCount:108}],
        6:[{totalCount:172,dataCount:136}],
        7:[{totalCount:196,dataCount:156}],
        8:[{totalCount:242,dataCount:194}],
        9:[{totalCount:292,dataCount:232}],
        10:[{totalCount:346,dataCount:274}],
      };
      function getRSBlocks(typeNumber, ecl){
        if(ecl!=="L") throw new Error("Only EC level L supported in this compact QR build");
        return RS_BLOCK_TABLE_L[Math.min(Math.max(typeNumber,1),10)];
      }
      function createData(typeNumber, ecl, dataList){
        const buffer=BitBuffer();
        for(const d of dataList){
          buffer.put(d.getMode(),4);
          const lenBits = (typeNumber<=9)?8:16;
          buffer.put(d.getLength(),lenBits);
          d.write(buffer);
        }
        const totalDataCount=getRSBlocks(typeNumber,ecl).reduce((a,b)=>a+b.dataCount,0);
        if(buffer.getLengthInBits()+4 <= totalDataCount*8) buffer.put(0,4);
        while(buffer.getLengthInBits()%8!==0) buffer.putBit(false);
        while(true){
          if(buffer.getLengthInBits()>=totalDataCount*8) break;
          buffer.put(PAD0,8);
          if(buffer.getLengthInBits()>=totalDataCount*8) break;
          buffer.put(PAD1,8);
        }
        return createBytes(buffer, getRSBlocks(typeNumber,ecl));
      }
      function createBytes(buffer, rsBlocks){
        let offset=0, maxDc=0, maxEc=0;
        const dcdata=[], ecdata=[];
        for(const rb of rsBlocks){
          const dcCount=rb.dataCount;
          const ecCount=rb.totalCount-dcCount;
          maxDc=Math.max(maxDc,dcCount);
          maxEc=Math.max(maxEc,ecCount);
          const dc=new Array(dcCount);
          for(let i=0;i<dcCount;i++) dc[i]=0xff & buffer.getBuffer()[i+offset];
          offset += dcCount;
          dcdata.push(dc);

          const rsPoly = rsGeneratorPoly(ecCount);
          const rawPoly = Poly(dc, ecCount);
          const modPoly = rawPoly.mod(rsPoly);
          const ec=new Array(ecCount);
          for(let i=0;i<ecCount;i++){
            const modIndex = i + modPoly.getLength() - ecCount;
            ec[i] = (modIndex>=0) ? modPoly.get(modIndex) : 0;
          }
          ecdata.push(ec);
        }
        const totalCodeCount = rsBlocks.reduce((a,b)=>a+b.totalCount,0);
        const data=new Array(totalCodeCount);
        let index=0;
        for(let i=0;i<maxDc;i++) for(let r=0;r<rsBlocks.length;r++) if(i<dcdata[r].length) data[index++]=dcdata[r][i];
        for(let i=0;i<maxEc;i++) for(let r=0;r<rsBlocks.length;r++) if(i<ecdata[r].length) data[index++]=ecdata[r][i];
        return data;
      }

      function makeImpl(){
        _moduleCount = _typeNumber*4 + 17;
        _modules=new Array(_moduleCount);
        for(let row=0;row<_moduleCount;row++) _modules[row]=new Array(_moduleCount).fill(null);
        setupPositionProbePattern(0,0);
        setupPositionProbePattern(_moduleCount-7,0);
        setupPositionProbePattern(0,_moduleCount-7);
        setupTimingPattern();
        setupPositionAdjustPattern();

        const data=createData(_typeNumber,_errorCorrectionLevel,_dataList);
        const mask=0; // compact build: fixed mask 0 for stability
        setupTypeInfo(false, mask);
        mapData(data, mask);
      }

      return {
        addData:(data)=>{ _dataList.push(QR8bitByte(data)); },
        make:()=>{ if(_modules===null) makeImpl(); },
        isDark:(r,c)=>_modules[r][c],
        getModuleCount:()=>_moduleCount
      };
    }

    function renderToCanvas(text, canvas, scale=6, margin=2){
      const len=text.length;
      let type=4;
      if(len>200) type=6;
      if(len>350) type=8;
      if(len>520) type=10;
      const qr=make(type,"L");
      qr.addData(text);
      qr.make();
      const count=qr.getModuleCount();
      const size=(count+margin*2)*scale;
      canvas.width=size; canvas.height=size;
      const ctx=canvas.getContext("2d");
      ctx.fillStyle="#fff"; ctx.fillRect(0,0,size,size);
      ctx.fillStyle="#000";
      for(let r=0;r<count;r++) for(let c=0;c<count;c++) if(qr.isDark(r,c)) ctx.fillRect((c+margin)*scale,(r+margin)*scale,scale,scale);
    }

    return { renderToCanvas };
  })();

  function b64urlEncode(bytes){
    let bin="";
    const chunk=0x8000;
    for(let i=0;i<bytes.length;i+=chunk) bin += String.fromCharCode.apply(null, bytes.subarray(i,i+chunk));
    return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function b64urlDecode(str){
    const s=str.replace(/-/g,'+').replace(/_/g,'/');
    const pad = s.length%4 ? "=".repeat(4-(s.length%4)) : "";
    const bin=atob(s+pad);
    const out=new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
    return out;
  }
  async function gzipMaybe(bytes){
    if(!("CompressionStream" in window)) return {bytes, flag:"-"};
    try{
      const cs=new CompressionStream("gzip");
      const w=cs.writable.getWriter();
      await w.write(bytes); await w.close();
      const ab=await new Response(cs.readable).arrayBuffer();
      return {bytes:new Uint8Array(ab), flag:"g"};
    }catch{
      return {bytes, flag:"-"};
    }
  }
  async function gunzipMaybe(bytes, flag){
    if(flag!=="g") return bytes;
    if(!("DecompressionStream" in window)) return bytes;
    try{
      const ds=new DecompressionStream("gzip");
      const w=ds.writable.getWriter();
      await w.write(bytes); await w.close();
      const ab=await new Response(ds.readable).arrayBuffer();
      return new Uint8Array(ab);
    }catch{
      return bytes;
    }
  }

  async function packToQrChunks(text){
    const raw=new TextEncoder().encode(text);
    const g=await gzipMaybe(raw);
    const b64=b64urlEncode(g.bytes);

    const id = (crypto?.getRandomValues ? Array.from(crypto.getRandomValues(new Uint8Array(6))) : Array.from({length:6},()=>Math.floor(Math.random()*256)))
      .map(x=>x.toString(16).padStart(2,"0")).join("");

    const maxChunk=180; // keep within QR v10-L capacity (conservative)
    const chunks=[];
    for(let i=0;i<b64.length;i+=maxChunk) chunks.push(b64.slice(i,i+maxChunk));
    const tot=chunks.length;
    const frames=chunks.map((payload, idx)=>`BAZQR1/${id}/${tot}/${idx+1}/${g.flag}:${payload}`);
    return {id, tot, frames};
  }

  const qrState = {
    showFrames: [], showIndex: 0, showTimer: null,
    scanStream: null, scanTimer: null, scanTarget: null,
    scanId: null, scanTot: 0, scanFlag: "-", scanParts: new Map(),
  };

  function openQrModal(mode){
    $("qrModal").style.display="flex";
    $("qrShowPane").style.display = (mode==="show") ? "block" : "none";
    $("qrScanPane").style.display = (mode==="scan") ? "block" : "none";
  }
  function stopQrShow(){
    if(qrState.showTimer){ clearInterval(qrState.showTimer); qrState.showTimer=null; }
    $("qrPlay").textContent="Auto";
  }
  function stopQrScan(){
    if(qrState.scanTimer){ clearInterval(qrState.scanTimer); qrState.scanTimer=null; }
    try{ if(qrState.scanStream) qrState.scanStream.getTracks().forEach(t=>t.stop()); }catch{}
    qrState.scanStream=null;
    $("qrVideo").srcObject=null;
  }
  function closeQrModal(){
    stopQrShow(); stopQrScan();
    $("qrModal").style.display="none";
  }
  function renderQrFrame(){
    const f=qrState.showFrames[qrState.showIndex];
    if(!f) return;
    $("qrChunk").textContent = `${qrState.showIndex+1}/${qrState.showFrames.length}`;
    $("qrId").textContent = (f.match(/^BAZQR1\/([^\/]+)/)?.[1]) || "—";
    QR.renderToCanvas(f, $("qrCanvas"), 6, 2);
  }
  function startQrShowAuto(){
    stopQrShow();
    $("qrPlay").textContent="Stop";
    qrState.showTimer=setInterval(()=>{
      qrState.showIndex = (qrState.showIndex+1) % qrState.showFrames.length;
      renderQrFrame();
    }, 450);
  }
  async function showLocalAsQr(){
    const txt=($("localSDP").value||"").trim();
    if(!txt){ log("No Local JSON to show"); return; }
    const pack=await packToQrChunks(txt);
    qrState.showFrames=pack.frames;
    qrState.showIndex=0;
    $("qrHelp").textContent = (pack.frames.length===1)
      ? "Show this QR to the other phone, then scan to fill Remote JSON."
      : `Multi‑QR (${pack.frames.length} chunks). Keep the other phone scanning while this cycles.`;
    openQrModal("show");
    renderQrFrame();
    startQrShowAuto();
  }

  async function startQrScanInto(textareaEl){
    if(!("mediaDevices" in navigator) || !navigator.mediaDevices.getUserMedia){
      log("No camera access in this browser."); return;
    }
    if(!("BarcodeDetector" in window)){
      $("qrHelp").textContent = "BarcodeDetector not available. Use Chrome Android or a compatible browser.";
      openQrModal("scan");
      $("qrScanStatus").textContent = "no BarcodeDetector";
      return;
    }
    qrState.scanTarget=textareaEl;
    qrState.scanId=null; qrState.scanTot=0; qrState.scanFlag="-"; qrState.scanParts=new Map();
    $("qrScanId").textContent="—";
    $("qrTot").textContent="0";
    $("qrGot").textContent="0";
    $("qrScanStatus").textContent="starting…";
    $("qrHelp").textContent="Grant camera permission, then point at the QR. Keep scanning for all chunks.";
    openQrModal("scan");

    const video=$("qrVideo");
    try{
      qrState.scanStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
      video.srcObject = qrState.scanStream;
    }catch(e){
      $("qrScanStatus").textContent="camera denied";
      log("QR scan camera error: "+(e.message||String(e)));
      return;
    }
    const detector = new BarcodeDetector({formats:["qr_code"]});
    qrState.scanTimer=setInterval(async ()=>{
      try{
        const barcodes = await detector.detect(video);
        if(!barcodes || !barcodes.length) return;
        const raw = String(barcodes[0].rawValue || "");
        if(!raw.startsWith("BAZQR1/")) return;
        const m = raw.match(/^BAZQR1\/([^\/]+)\/(\d+)\/(\d+)\/([g\-]):(.+)$/);
        if(!m) return;
        const id=m[1], tot=Number(m[2]), idx=Number(m[3]), flag=m[4], payload=m[5];
        if(qrState.scanId && id !== qrState.scanId) return;
        qrState.scanId=id; qrState.scanTot=tot; qrState.scanFlag=flag;
        $("qrScanId").textContent=id;
        $("qrTot").textContent=String(tot);

        if(!qrState.scanParts.has(idx)){
          qrState.scanParts.set(idx, payload);
          $("qrGot").textContent=String(qrState.scanParts.size);
          $("qrScanStatus").textContent="receiving…";
          log(`QR chunk ${idx}/${tot} received`, true);
        }
        if(qrState.scanParts.size === tot){
          $("qrScanStatus").textContent="assembling…";
          let b64="";
          for(let i=1;i<=tot;i++) b64 += (qrState.scanParts.get(i) || "");
          const packed=b64urlDecode(b64);
          const unz=await gunzipMaybe(packed, flag);
          const json=new TextDecoder().decode(unz);
          textareaEl.value=json;
          $("qrScanStatus").textContent="done";
          log("QR handshake payload assembled", true);
          setTimeout(()=>closeQrModal(), 450);
        }
      }catch{}
    }, 140);
  }

function setRtcState(s){
    $("rtcState").textContent = s;
    $("rtcState").className = (s==="connected") ? "ok" : (s==="failed" ? "bad" : "warn");
  }
  function setIceState(s){ $("iceState").textContent = s; }
  function setDcState(s){
    $("dcState").textContent = s;
    $("dcState").className = (s==="open") ? "ok" : (s==="closed" ? "bad" : "warn");
  }
  function setMediaState(s){
    $("mediaState").textContent = s;
    $("mediaState").className = (s==="on") ? "ok" : "warn";
  }

  function rtcConfig(){
    const stun = $("stun").value;
    const iceServers = [];
    if(stun==="google") iceServers.push({urls:["stun:stun.l.google.com:19302","stun:stun1.l.google.com:19302"]});
    if(stun==="twilio") iceServers.push({urls:["stun:global.stun.twilio.com:3478"]});
    return {iceServers};
  }

  function clearSDP(){
    $("localSDP").value = "";
    $("remoteSDP").value = "";
    $("copyLocal").disabled = true;
    $("showLocalQR").disabled = true;
  }

  function enableButtonsForInit(){
    $("startMedia").disabled = false;
    $("stopMedia").disabled = false;
    $("hangup").disabled = false;

    const role = $("role").value;
    $("createOffer").disabled = (role !== "a");
    $("createAnswer").disabled = (role !== "b");
    $("setRemote").disabled = false;
  }

  function disableButtonsForHangup(){
    $("startMedia").disabled = true;
    $("stopMedia").disabled = true;
    $("hangup").disabled = true;
    $("createOffer").disabled = true;
    $("createAnswer").disabled = true;
    $("setRemote").disabled = true;
    $("send").disabled = true;
    $("sendBurst").disabled = true;
    $("copyLocal").disabled = true;
  }

  function wirePcEvents(){
    pc.onconnectionstatechange = ()=>{
      const s = pc.connectionState || "unknown";
      setRtcState(s);
      log("pc.connectionState → " + s, true);
    };
    pc.oniceconnectionstatechange = ()=>{
      const s = pc.iceConnectionState || "unknown";
      setIceState(s);
      log("pc.iceConnectionState → " + s, true);
    };
    pc.onicegatheringstatechange = ()=>{
      log("pc.iceGatheringState → " + (pc.iceGatheringState||"unknown"), true);
    };
    pc.onicecandidate = (ev)=>{
      if(ev.candidate){
        candN++;
        $("candCount").textContent = String(candN);
        // Keep logs light: show candidate type and protocol when possible
        try{
          const c = ev.candidate.candidate || "";
          let typ = "cand";
          const mt = c.match(/ typ (host|srflx|relay) /);
          if(mt) typ = mt[1];
          const pr = c.match(/ udp | tcp /) ? (c.includes(" tcp ") ? "tcp" : "udp") : "?";
          log(`icecandidate +1 (${typ}/${pr})`, true);
        }catch{}
      } else {
        log("icecandidate: null (gathering complete)", true);
      }
    };

    pc.ontrack = (ev)=>{
      log("remote track received", true);
      const [stream] = ev.streams;
      if(stream) remoteV.srcObject = stream;
    };
    pc.ondatachannel = (ev)=>{
      log("data channel received", true);
      dc = ev.channel;
      wireDcEvents();
    };
  }

  function wireDcEvents(){
    if(!dc) return;
    dc.onopen = ()=>{
      setDcState("open");
      $("send").disabled = false;
      $("sendBurst").disabled = false;
      if($("eqvRecv")) $("eqvRecv").disabled = false;
      if($("eqvSend")) $("eqvSend").disabled = !eqv.baseReady;
      if($("llmSendPeer")) $("llmSendPeer").disabled = false;
      log("dc.open", true);
    };
    dc.onclose = ()=>{
      setDcState("closed");
      $("send").disabled = true;
      $("sendBurst").disabled = true;
      if($("eqvRecv")) $("eqvRecv").disabled = true;
      if($("eqvSend")) $("eqvSend").disabled = true;
      if($("llmSendPeer")) $("llmSendPeer").disabled = true;
      log("dc.closed", true);
    };
    dc.onerror = (e)=>{
      setDcState("error");
      log("dc.error: " + (e.message||String(e)));
    };
    dc.onmessage = (ev)=>{
      const data = String(ev.data||"");
      try{
        const obj = JSON.parse(data);

        if(obj && obj.t==="mono" && obj.s){ applyMonoState(obj.s); return; }

        if(obj && obj.t==="eqv"){
          if(obj.kind==="init" && obj.s){ eqvApplyState(obj.s); return; }
          if(obj.kind==="tick" && obj.s && mono.sync==="rx"){
            // light phase alignment
            if(typeof obj.s.t === "number") eqv.t = Number(obj.s.t)||eqv.t;
            return;
          }
          if(obj.kind==="req"){
            // Peer requested EQV init
            if(eqv.baseReady && dc && dc.readyState==="open"){
              try{ dc.send(JSON.stringify({t:"eqv", kind:"init", s:eqvSerialize(true)})); }catch{}
            }
            return;
          }
        }

        if(obj && obj.t==="llm" && obj.kind==="msg"){
          llmAddMsg("peer", String(obj.m||""));
          return;
        }

        if(obj && obj.t==="msg"){ log("RX: " + String(obj.m)); return; }
      }catch{}
      log("RX: " + data);
    };
    setDcState(dc.readyState || "connecting");
  }

  async function initTRX(){
    if(pc) return;
    clearSDP();
    candN = 0;
    $("candCount").textContent = "0";
    log("Init TRX…", true);

    pc = new RTCPeerConnection(rtcConfig());
    wirePcEvents();
    startStatsLoop();

    if($("role").value === "a"){
      dc = pc.createDataChannel("baz", {ordered:true});
      wireDcEvents();
    }

    enableButtonsForInit();
    setRtcState("new");
    setIceState("new");
    setDcState(dc ? (dc.readyState || "connecting") : "—");
  }

  async function startMedia(){
    if(!pc){
      log("Init TRX first.");
      return;
    }
    if(localStream){
      log("media already on", true);
      return;
    }

    const cam = $("camMode").value;
    const mic = $("micMode").value;
    const overlayMode = $("overlayMode").value;

    const constraints = {
      audio: (mic==="on") ? {echoCancellation:true, noiseSuppression:true, autoGainControl:true} : false,
      video: (cam==="none") ? false : {facingMode: (cam==="env" ? "environment" : "user")}
    };

    try{
      localStream = await navigator.mediaDevices.getUserMedia(constraints);

      const vTrack = localStream.getVideoTracks()[0] || null;
      const aTrack = localStream.getAudioTracks()[0] || null;

      if(vTrack && overlayMode === "on"){
        const ov = buildOverlayStream(localStream);
        if(ov && ov.getVideoTracks().length){
          overlayStream = ov;
          sendStream = new MediaStream();
          sendStream.addTrack(overlayStream.getVideoTracks()[0]);
          if(aTrack) sendStream.addTrack(aTrack);
          localV.srcObject = sendStream;
          log("overlay enabled: LIVE camera → canvas → WebRTC", true);
        } else {
          sendStream = localStream;
          localV.srcObject = localStream;
          log("overlay failed; using raw camera", true);
        }
      } else {
        sendStream = localStream;
        localV.srcObject = localStream;
        log("using raw camera (no overlay)", true);
      }

      attachSendTracks(sendStream);

      setMediaState("on");
      try{ aqcOnMedia(true); }catch(e){}
      log("media started", true);
    }catch(e){
      setMediaState("error");
      try{ aqcOnMedia(false); }catch(e){}
      log("media error: " + (e.message||String(e)));
    }
  }

  async function stopMedia(){
    try{
      if(sendStream){
        try{ sendStream.getTracks().forEach(t=>t.stop()); }catch{}
        sendStream = null;
      }
      stopOverlay();
      if(localStream){
        try{ localStream.getTracks().forEach(t=>t.stop()); }catch{}
        localStream = null;
      }
    }catch{}
    localV.srcObject = null;
    setMediaState("off");
    try{ aqcOnMedia(false); }catch(e){}
    log("media stopped", true);
  }

  function waitForIceComplete(){
    return new Promise((resolve)=>{
      if(!pc) return resolve();
      const timeoutMs = Number($("iceTimeout")?.value || 6000);
      let done = false;

      const finish = (why)=>{
        if(done) return;
        done = true;
        try{ pc.removeEventListener("icegatheringstatechange", onState); }catch{}
        try{ pc.removeEventListener("icecandidate", onCand); }catch{}
        if(why) log(why, true);
        resolve();
      };

      const onState = ()=>{
        if(pc.iceGatheringState === "complete"){
          finish("ICE gathering complete");
        }
      };

      const onCand = (ev)=>{
        if(!ev.candidate){
          finish("ICE gathering complete (null candidate)");
        }
      };

      if(pc.iceGatheringState === "complete"){
        return finish("ICE already complete");
      }

      pc.addEventListener("icegatheringstatechange", onState);
      pc.addEventListener("icecandidate", onCand);

      setTimeout(()=>{
        // Some networks never reach "complete" quickly; don't hang the UI.
        finish("ICE gather timeout → exporting partial ICE (should still work on many networks)");
      }, timeoutMs);
    });
  }

  async function createOffer(){
    if(!pc) return;
    try{
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log("local offer set; gathering ICE…", true);
      await waitForIceComplete();
      const blob = {type: pc.localDescription.type, sdp: pc.localDescription.sdp};
      $("localSDP").value = JSON.stringify(blob);
      $("copyLocal").disabled = false;
      $("showLocalQR").disabled = false;
      log("Offer ready (copy Local JSON)", true);
    }catch(e){
      log("createOffer error: " + (e.message||String(e)));
    }
  }

  async function setRemote(){
    if(!pc) return;
    const txt = ($("remoteSDP").value||"").trim();
    if(!txt){ log("paste Remote JSON first"); return; }
    try{
      const blob = parseJsonLoose(txt);
      await pc.setRemoteDescription(blob);
      log("remote description set (" + blob.type + ")", true);
      if($("role").value === "b"){
        $("createAnswer").disabled = false;
      }
    }catch(e){
      log("setRemote error: " + (e.message||String(e)));
    }
  }

  async function createAnswer(){
    if(!pc) return;
    try{
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      log("local answer set; gathering ICE…", true);
      await waitForIceComplete();
      const blob = {type: pc.localDescription.type, sdp: pc.localDescription.sdp};
      $("localSDP").value = JSON.stringify(blob);
      $("copyLocal").disabled = false;
      $("showLocalQR").disabled = false;
      log("Answer ready (copy Local JSON)", true);
    }catch(e){
      log("createAnswer error: " + (e.message||String(e)));
    }
  }

  async function hangup(){
    try{ await stopMedia(); }catch{}
    try{ stopStatsLoop(); }catch{}
    try{
      if(dc){ try{ dc.close(); }catch{} }
      dc = null;
      if(pc){ try{ pc.close(); }catch{} }
      pc = null;
    }catch{}
    remoteV.srcObject = null;
    clearSDP();
    disableButtonsForHangup();
    setRtcState("idle");
    setIceState("—");
    setDcState("—");
    setMediaState("off");
    try{ aqcOnMedia(false); }catch(e){}
    log("hung up", true);
  }

  function sendMsg(text){
    if(!dc || dc.readyState!=="open"){ log("data channel not open"); return; }
    const payload = JSON.stringify({t:"msg", m:String(text)});
    dc.send(payload);
    log("TX: " + String(text));
  }

  function poleBurst(){
    const t = Math.floor(Date.now()/250);
    const seed = (t ^ 0x9e3779b9) >>> 0;
    let x = seed;
    const bits = [];
    for(let i=0;i<256;i++){
      x ^= (x << 13) >>> 0;
      x ^= (x >> 17) >>> 0;
      x ^= (x << 5) >>> 0;
      bits.push((x & 1) ? "1":"0");
    }
    return "POLEBURST t=" + t + " " + bits.join("");
  }

  $("init").onclick = initTRX;
  $("hangup").onclick = hangup;
  $("startMedia").onclick = startMedia;
  $("stopMedia").onclick = stopMedia;

  $("createOffer").onclick = createOffer;
  $("createAnswer").onclick = createAnswer;
  $("setRemote").onclick = setRemote;

  $("clearRemote").onclick = ()=>{ $("remoteSDP").value=""; };

  $("copyLocal").onclick = async ()=>{
    const txt = $("localSDP").value;
    if(!txt) return;
    try{
      await navigator.clipboard.writeText(txt);
      log("copied Local JSON", true);
    }catch(e){
      $("localSDP").focus();
      $("localSDP").select();
      log("clipboard blocked; selected text instead", true);
    }

  $("showLocalQR").onclick = ()=>{ showLocalAsQr(); };
  $("scanRemoteQR").onclick = ()=>{ startQrScanInto($("remoteSDP")); };

  $("qrClose").onclick = ()=> closeQrModal();
  $("qrPrev").onclick = ()=>{
    if(!qrState.showFrames.length) return;
    stopQrShow();
    qrState.showIndex = (qrState.showIndex - 1 + qrState.showFrames.length) % qrState.showFrames.length;
    renderQrFrame();
  };
  $("qrNext").onclick = ()=>{
    if(!qrState.showFrames.length) return;
    stopQrShow();
    qrState.showIndex = (qrState.showIndex + 1) % qrState.showFrames.length;
    renderQrFrame();
  };
  $("qrPlay").onclick = ()=>{
    if(!qrState.showFrames.length) return;
    if(qrState.showTimer) stopQrShow(); else startQrShowAuto();
  };
  };

  $("send").onclick = ()=>{
    const m = ($("msg").value||"").trim();
    if(!m) return;
    sendMsg(m);
    $("msg").value="";
  };
  $("sendBurst").onclick = ()=> sendMsg(poleBurst());

  disableButtonsForHangup();
  setRtcState("idle");
  setIceState("—");
  setDcState("—");
  setMediaState("off");
    try{ aqcOnMedia(false); }catch(e){}

  // ---------------- Monograph (pixel/photon emitter field) ----------------
  const mono = {
    running:false, raf:0, last:0,
    N:128, poles:[], sync:"off", tilt:false,
    engine:"poles",
    txTimer:0
  };

  // ---------------- Equation-Video (Pixel-Life) Engine ----------------
  // PDE-like update: ∂C/∂t = S·r(C) + DΔC + F(C) + Qmod(x,y,t)  (C is RGB field in [0,1])
  const eqv = {
    enabled:false,
    N:128,
    t:0,
    baseReady:false,
    dirty:true,
    params:{
      dt:0.016,
      D:0.35,
      k1:0.90, k2:0.80, k3:0.70,
      beta:1.20,
      lam:0.90,
      mu:0.40,
      kap:0.35,
      period:4.0,
      noise:0.0
    },
    modes:[],
    C:null, Cn:null, C0:null, M:null,
    lastEntropy:0,
    _entT:0
  };

  function clamp01(x){ return x<0?0:(x>1?1:x); }

  function parseModesText(){
    const ta = $("eqvModes");
    if(!ta) return [];
    const lines = String(ta.value||"").split(/\n/).map(s=>s.replace(/\r/g,"").trim()).filter(Boolean);
    const out=[];
    for(const ln of lines){
      const parts = ln.split(/[, ]+/).map(x=>x.trim()).filter(Boolean).map(Number);
      if(parts.length<5) continue;
      out.push({a:parts[0], w:parts[1], kx:parts[2], ky:parts[3], p0:parts[4]});
    }
    return out.slice(0,6);
  }

  function eqvReadParamsFromUI(){
    const p = eqv.params;
    p.dt = Math.max(0.001, Math.min(0.1, Number($("eqvDt")?.value||p.dt)));
    p.D = Math.max(0, Math.min(5, Number($("eqvD")?.value||p.D)));
    p.k1 = Math.max(0, Math.min(5, Number($("eqvK1")?.value||p.k1)));
    p.k2 = Math.max(0, Math.min(5, Number($("eqvK2")?.value||p.k2)));
    p.k3 = Math.max(0, Math.min(5, Number($("eqvK3")?.value||p.k3)));
    p.beta = Math.max(0, Math.min(10, Number($("eqvBeta")?.value||p.beta)));
    p.lam = Math.max(0, Math.min(10, Number($("eqvLam")?.value||p.lam)));
    p.mu = Math.max(0, Math.min(10, Number($("eqvMu")?.value||p.mu)));
    p.kap = Math.max(0, Math.min(10, Number($("eqvKap")?.value||p.kap)));
    p.period = Math.max(0.1, Math.min(60, Number($("eqvPer")?.value||p.period)));
    eqv.modes = parseModesText();
    eqv.dirty = false;
  }

  function eqvEnsureAlloc(){
    const N = mono.N;
    if(eqv.N === N && eqv.C && eqv.C.length === N*N*3) return;
    eqv.N = N;
    const n3 = N*N*3;
    eqv.C = new Float32Array(n3);
    eqv.Cn = new Float32Array(n3);
    eqv.C0 = new Float32Array(n3);
    eqv.M = new Float32Array(n3);
    eqv.t = 0;
    eqv.baseReady = false;
    eqv.lastEntropy = 0;
    if($("eqvState")) $("eqvState").textContent = "off";
    if($("eqvEntropy")) $("eqvEntropy").textContent = "—";
  }

  function eqvSetBaseFromImageData(img){
    eqvEnsureAlloc();
    const N = eqv.N;
    const d = img.data;
    for(let i=0;i<N*N;i++){
      const r = d[4*i+0]/255, g=d[4*i+1]/255, b=d[4*i+2]/255;
      const j = 3*i;
      eqv.C0[j+0]=r; eqv.C0[j+1]=g; eqv.C0[j+2]=b;
      eqv.C[j+0]=r;  eqv.C[j+1]=g;  eqv.C[j+2]=b;
      eqv.M[j+0]=0;  eqv.M[j+1]=0;  eqv.M[j+2]=0;
    }
    eqv.baseReady = true;
    eqv.enabled = true;
    if($("eqvState")) $("eqvState").textContent = "ready";
    if($("eqvSend")) $("eqvSend").disabled = false;
  }

  async function eqvSnapFromCamera(){
    const v = $("local");
    if(!v || v.readyState < 2){
      log("EQV snap: start Media first (TRX tab → Start Media).");
      return;
    }
    eqvEnsureAlloc();
    const N = eqv.N;
    const off = document.createElement("canvas");
    off.width = N; off.height = N;
    const ox = off.getContext("2d", {willReadFrequently:true});
    ox.drawImage(v, 0,0, N,N);
    eqvSetBaseFromImageData(ox.getImageData(0,0,N,N));
  }

  async function eqvLoadImageFile(file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    try{
      const img = new Image();
      img.decoding = "async";
      img.src = url;
      await img.decode();
      eqvEnsureAlloc();
      const N = eqv.N;
      const off = document.createElement("canvas");
      off.width=N; off.height=N;
      const ox = off.getContext("2d", {willReadFrequently:true});
      ox.drawImage(img, 0,0, N,N);
      eqvSetBaseFromImageData(ox.getImageData(0,0,N,N));
    }catch(e){
      log("EQV load image failed: " + (e.message||String(e)));
    }finally{
      URL.revokeObjectURL(url);
    }
  }

  function eqvApplyPreset(name){
    name = String(name||"stable");
    if(name==="living"){
      $("eqvD").value="0.55";
      $("eqvK1").value="1.30"; $("eqvK2").value="1.10"; $("eqvK3").value="0.90";
      $("eqvBeta").value="0.45";
      $("eqvLam").value="0.65"; $("eqvMu").value="0.30";
      $("eqvKap").value="0.55"; $("eqvPer").value="3.0";
      $("eqvModes").value=`0.35, 5.0, 5.0, 1.0, 0.0
0.22, 9.0, -3.0, 4.0, 1.2
0.16, 14.0, 2.0, -5.0, 2.4`;
    }else if(name==="encode"){
      $("eqvD").value="0.25";
      $("eqvK1").value="0.70"; $("eqvK2").value="0.70"; $("eqvK3").value="0.70";
      $("eqvBeta").value="1.80";
      $("eqvLam").value="0.90"; $("eqvMu").value="0.45";
      $("eqvKap").value="0.20"; $("eqvPer").value="4.0";
      $("eqvModes").value=`0.18, 6.0, 3.0, 0.0, 0.0
0.12, 10.0, 0.0, 3.0, 1.0`;
    }else{
      $("eqvD").value="0.35";
      $("eqvK1").value="0.90"; $("eqvK2").value="0.80"; $("eqvK3").value="0.70";
      $("eqvBeta").value="1.20";
      $("eqvLam").value="0.90"; $("eqvMu").value="0.40";
      $("eqvKap").value="0.35"; $("eqvPer").value="4.0";
      $("eqvModes").value=`0.25, 6.0, 4.0, 1.0, 0.0
0.18, 9.0, -2.0, 3.0, 1.0
0.12, 13.0, 1.0, -4.0, 2.0`;
    }
    eqv.dirty = true;
  }

  function eqvEntropy64(){
    const N = eqv.N;
    const bins = new Uint32Array(64);
    let count=0;
    for(let i=0;i<N*N;i++){
      const j = 3*i;
      const lum = 0.2126*eqv.C[j] + 0.7152*eqv.C[j+1] + 0.0722*eqv.C[j+2];
      const b = Math.max(0, Math.min(63, (lum*63)|0));
      bins[b]++; count++;
    }
    let H=0;
    for(let b=0;b<64;b++){
      const c=bins[b];
      if(!c) continue;
      const p=c/count;
      H -= p*Math.log(p);
    }
    return H/Math.log(2);
  }

  function eqvStep(){
    if(!eqv.enabled || !eqv.baseReady) return;
    if(eqv.dirty) eqvReadParamsFromUI();

    const p = eqv.params;
    const dt = p.dt;
    const N = eqv.N;
    const C = eqv.C, Cn = eqv.Cn, C0 = eqv.C0, M = eqv.M;

    const Fp = p.kap * Math.sin(2*Math.PI*eqv.t / p.period);
    const modes = eqv.modes || [];
    const twoPi = 2*Math.PI;

    const idx = (x,y)=> (y*N + x);
    const wrap = (v)=> (v<0 ? v+N : (v>=N ? v-N : v));

    for(let y=0;y<N;y++){
      const yn = y/(N-1);
      const ym = twoPi*yn;
      for(let x=0;x<N;x++){
        const xn = x/(N-1);
        const xm = twoPi*xn;
        const i = idx(x,y);
        const j = 3*i;

        const R = C[j], G=C[j+1], B=C[j+2];

        const dRr = -p.k1*R + p.k3*B;
        const dGr =  p.k1*R - p.k2*G;
        const dBr =  p.k2*G - p.k3*B;

        const xl = wrap(x-1), xr=wrap(x+1), yu=wrap(y-1), yd=wrap(y+1);
        const il = idx(xl,y), ir=idx(xr,y), iu=idx(x,yu), id=idx(x,yd);
        const jl = 3*il, jr=3*ir, ju=3*iu, jd=3*id;

        const lapR = (C[jl] + C[jr] + C[ju] + C[jd] - 4*R);
        const lapG = (C[jl+1] + C[jr+1] + C[ju+1] + C[jd+1] - 4*G);
        const lapB = (C[jl+2] + C[jr+2] + C[ju+2] + C[jd+2] - 4*B);

        const eR = R - C0[j], eG = G - C0[j+1], eB = B - C0[j+2];
        M[j]   += dt * p.lam * eR;
        M[j+1] += dt * p.lam * eG;
        M[j+2] += dt * p.lam * eB;

        const FhR = -p.beta*eR, FhG=-p.beta*eG, FhB=-p.beta*eB;
        const FmR = -p.mu*M[j], FmG=-p.mu*M[j+1], FmB=-p.mu*M[j+2];

        let q = 0;
        for(let m=0;m<modes.length;m++){
          const md = modes[m];
          q += md.a * Math.sin(md.w*eqv.t + md.kx*xm + md.ky*ym + md.p0);
        }
        const qR = q * C0[j];
        const qG = q * C0[j+1];
        const qB = q * C0[j+2];

        const nz = p.noise ? (p.noise * (Math.random()*2-1) * Math.sqrt(dt)) : 0;

        Cn[j]   = clamp01(R + dt*(dRr + p.D*lapR + FhR + FmR + Fp + qR) + nz);
        Cn[j+1] = clamp01(G + dt*(dGr + p.D*lapG + FhG + FmG + Fp + qG) + nz);
        Cn[j+2] = clamp01(B + dt*(dBr + p.D*lapB + FhB + FmB + Fp + qB) + nz);
      }
    }

    eqv.C = Cn;
    eqv.Cn = C;
    eqv.t += dt;

    if($("eqvEntropy")){
      if(!eqv._entT || (performance.now()-eqv._entT) > 160){
        eqv._entT = performance.now();
        eqv.lastEntropy = eqvEntropy64();
        $("eqvEntropy").textContent = eqv.lastEntropy.toFixed(2);
      }
    }
  }

  function drawEqv(){
    if(!mono.running) return;
    if(!eqv.enabled){
      if($("eqvState")) $("eqvState").textContent = "off";
      return;
    }
    eqvEnsureAlloc();

    const c = $("monoCanvas");
    const ctx = c.getContext("2d", {alpha:false});
    const W=c.width, H=c.height;
    const N = eqv.N;

    const img = ctx.createImageData(N,N);
    const d = img.data;
    const C = eqv.C;

    for(let i=0;i<N*N;i++){
      const j = 3*i;
      d[4*i+0] = Math.max(0, Math.min(255, (C[j]*255)|0));
      d[4*i+1] = Math.max(0, Math.min(255, (C[j+1]*255)|0));
      d[4*i+2] = Math.max(0, Math.min(255, (C[j+2]*255)|0));
      d[4*i+3] = 255;
    }

    const off = document.createElement("canvas");
    off.width=N; off.height=N;
    off.getContext("2d", {alpha:false}).putImageData(img,0,0);

    ctx.imageSmoothingEnabled = true;
    ctx.clearRect(0,0,W,H);
    ctx.drawImage(off, 0,0, W,H);

    $("monoState").textContent = (mono.sync==="tx") ? "running (TX)" : (mono.sync==="rx" ? "running (RX)" : "running");
  }

  function eqvSerialize(includeBase){
    eqvReadParamsFromUI();
    const p = eqv.params;
    const s = {
      N:eqv.N,
      t:eqv.t,
      params:{dt:p.dt,D:p.D,k1:p.k1,k2:p.k2,k3:p.k3,beta:p.beta,lam:p.lam,mu:p.mu,kap:p.kap,period:p.period},
      modes:(eqv.modes||[]).map(m=>({a:m.a,w:m.w,kx:m.kx,ky:m.ky,p0:m.p0}))
    };
    if(includeBase && eqv.baseReady){
      const off = document.createElement("canvas");
      off.width=eqv.N; off.height=eqv.N;
      const ox = off.getContext("2d", {alpha:false});
      const img = ox.createImageData(eqv.N,eqv.N);
      const d = img.data;
      for(let i=0;i<eqv.N*eqv.N;i++){
        const j = 3*i;
        d[4*i+0] = Math.max(0, Math.min(255, (eqv.C0[j]*255)|0));
        d[4*i+1] = Math.max(0, Math.min(255, (eqv.C0[j+1]*255)|0));
        d[4*i+2] = Math.max(0, Math.min(255, (eqv.C0[j+2]*255)|0));
        d[4*i+3] = 255;
      }
      ox.putImageData(img,0,0);
      s.base = off.toDataURL("image/png");
    }
    return s;
  }

  async function eqvApplyState(s){
    if(!s) return;
    mono.engine = "eqv";
    if($("monoEngine")) $("monoEngine").value = "eqv";
    if($("eqvState")) $("eqvState").textContent = "rx";

    if(typeof s.N === "number"){
      mono.N = Math.max(48, Math.min(256, Math.floor(s.N)));
      $("monoRes").value = String(mono.N);
    }
    eqvEnsureAlloc();

    if(s.params){
      const p=s.params;
      const map = [
        ["dt","eqvDt"], ["D","eqvD"],
        ["k1","eqvK1"], ["k2","eqvK2"], ["k3","eqvK3"],
        ["beta","eqvBeta"], ["lam","eqvLam"], ["mu","eqvMu"],
        ["kap","eqvKap"], ["period","eqvPer"]
      ];
      for(const [k,id] of map){
        if(p[k] != null && $(id)) $(id).value = String(p[k]);
      }
    }
    if(Array.isArray(s.modes) && $("eqvModes")){
      $("eqvModes").value = s.modes.map(m=>[m.a,m.w,m.kx,m.ky,m.p0].join(", ")).join("\n");
    }
    eqv.dirty = true;

    if(typeof s.t === "number") eqv.t = Number(s.t)||0;

    if(s.base){
      try{
        const img = new Image();
        img.decoding = "async";
        img.src = String(s.base);
        await img.decode();
        const N = eqv.N;
        const off = document.createElement("canvas");
        off.width=N; off.height=N;
        const ox = off.getContext("2d", {willReadFrequently:true});
        ox.drawImage(img, 0,0, N,N);
        eqvSetBaseFromImageData(ox.getImageData(0,0,N,N));
      }catch(e){
        log("EQV RX: base decode failed: " + (e.message||String(e)));
      }
    }else{
      eqv.enabled = true;
    }

    if(!mono.running) monoStart();
  }

  function eqvSendToPeer(){
    if(!dc || dc.readyState!=="open"){ log("EQV send: data channel not open"); return; }
    if(!eqv.baseReady){ log("EQV send: snap/load base C0 first"); return; }
    const s = eqvSerialize(true);
    try{
      dc.send(JSON.stringify({t:"eqv", kind:"init", s}));
      log("TX: EQV init ("+eqv.N+"×"+eqv.N+")", true);
    }catch(e){
      log("EQV send failed: " + (e.message||String(e)));
    }
  }

  function eqvRequestFromPeer(){
    if(!dc || dc.readyState!=="open"){ log("EQV request: data channel not open"); return; }
    try{
      dc.send(JSON.stringify({t:"eqv", kind:"req"}));
      log("TX: EQV request", true);
    }catch{}
  }


  
  function setActiveTab(which){
    const trx = $("viewTRX"), monoV = $("viewMONO"), llmV = $("viewLLM"), aqcV = $("viewAQC"), layV = $("viewLAYOUTS");
    trx.style.display = (which==="trx") ? "block" : "none";
    monoV.style.display = (which==="mono") ? "block" : "none";
    llmV.style.display = (which==="llm") ? "block" : "none";
    if(aqcV) aqcV.style.display = (which==="aqc") ? "block" : "none";
    if(layV) layV.style.display = (which==="layouts") ? "block" : "none";

    $("tabTrx").classList.toggle("active", which==="trx");
    $("tabMono").classList.toggle("active", which==="mono");
    if($("tabLlm")) $("tabLlm").classList.toggle("active", which==="llm");
    if($("tabAqc")) $("tabAqc").classList.toggle("active", which==="aqc");
    if($("tabLayouts")) $("tabLayouts").classList.toggle("active", which==="layouts");
  }


  function updateSyncPill(){
    const s = $("monoSync")?.value || "off";
    $("syncState").textContent = s;
    mono.sync = s;
  }

  function monoResize(){
    const c = $("monoCanvas");
    const rect = c.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    c.width = Math.floor(rect.width * dpr);
    c.height = Math.floor(rect.height * dpr);
  }

  function monoRebuildPoles(){
    const k = Math.max(3, parseInt($("monoPoles").value||"3",10));
    mono.poles = [];
    for(let i=0;i<k;i++){
      mono.poles.push({
        x: Math.random(), y: Math.random(),
        ph: Math.random()*Math.PI*2,
        w: (0.004 + 0.006*Math.random()) * (i%2?1:-1),
        a: 0.85 + 0.35*Math.random()
      });
    }
  }

  function fieldAt(u,v){
    // u,v in [0,1]
    let s0=0, s1=0, s2=0;
    for(let i=0;i<mono.poles.length;i++){
      const p=mono.poles[i];
      const dx=u-p.x, dy=v-p.y;
      const r=Math.sqrt(dx*dx+dy*dy) + 1e-3;
      const k = 10.0; // spatial frequency
      const t = p.ph + k*r;
      const w = p.a/(1.0 + 4.0*r);
      s0 += w*Math.sin(t);
      s1 += w*Math.cos(t*0.9 + 0.7*i);
      s2 += w*Math.sin(t*1.1 - 0.4*i);
    }
    return [s0,s1,s2];
  }

  function stepPoles(dt){
    // Kuramoto-like coupling + slight drift => “3-pole minimum” chaos-ish
    const P=mono.poles;
    const K=1.8;
    for(let i=0;i<P.length;i++){
      let coup=0;
      for(let j=0;j<P.length;j++){
        if(i===j) continue;
        coup += Math.sin(P[j].ph - P[i].ph);
      }
      P[i].ph += (P[i].w + (K/P.length)*coup) * (dt*60);
      // drift by local gradient-ish
      const vx = 0.08*Math.cos(P[i].ph*0.9 + i);
      const vy = 0.08*Math.sin(P[i].ph*1.1 - i);
      P[i].x = (P[i].x + vx*dt*0.08 + 1) % 1;
      P[i].y = (P[i].y + vy*dt*0.08 + 1) % 1;
    }
  }

  function drawMono(){
    if(!mono.running) return;
    if(mono.engine==="eqv"){ drawEqv(); return; }
    const c = $("monoCanvas");
    const ctx = c.getContext("2d", {alpha:false});
    const W=c.width, H=c.height;
    const N = mono.N;

    const img = ctx.createImageData(N,N);
    const d = img.data;

    for(let y=0;y<N;y++){
      const v = y/(N-1);
      for(let x=0;x<N;x++){
        const u = x/(N-1);
        const f = fieldAt(u,v);
        // squashing
        const r = 0.5 + 0.5*Math.tanh(1.2*f[0]);
        const g = 0.5 + 0.5*Math.tanh(1.2*f[1]);
        const b = 0.5 + 0.5*Math.tanh(1.2*f[2]);
        const i = 4*(y*N+x);
        d[i+0] = Math.max(0,Math.min(255, Math.floor(255*r)));
        d[i+1] = Math.max(0,Math.min(255, Math.floor(255*g)));
        d[i+2] = Math.max(0,Math.min(255, Math.floor(255*b)));
        d[i+3] = 255;
      }
    }

    // scale to canvas
    const off = document.createElement("canvas");
    off.width=N; off.height=N;
    off.getContext("2d", {alpha:false}).putImageData(img,0,0);

    ctx.imageSmoothingEnabled = true;
    ctx.clearRect(0,0,W,H);
    ctx.drawImage(off, 0,0, W,H);

    $("monoState").textContent = (mono.sync==="tx") ? "running (TX)" : (mono.sync==="rx" ? "running (RX)" : "running");
  }

  function monoLoop(ts){
    if(!mono.running) return;
    const t = ts || performance.now();
    const dt = mono.last ? Math.min(0.05, (t-mono.last)/1000) : 0.016;
    mono.last = t;

    
    if(mono.engine==="poles"){
      if(mono.sync !== "rx"){ stepPoles(dt); }
    }else{
      eqvStep();
    }
    drawMono();

    // TX: broadcast state at ~8Hz (poles) or ~6Hz (EQV tick)
    if(mono.sync==="tx" && dc && dc.readyState==="open"){
      const period = (mono.engine==="poles") ? 120 : 180;
      if(!mono.txTimer || (t - mono.txTimer) > period){
        mono.txTimer = t;
        try{
          if(mono.engine==="poles"){
            dc.send(JSON.stringify({t:"mono", s:{N:mono.N, poles:mono.poles}}));
          }else{
            dc.send(JSON.stringify({t:"eqv", kind:"tick", s:{t:eqv.t, N:eqv.N}}));
          }
        }catch{}
      }
    }

    mono.raf = requestAnimationFrame(monoLoop);
  }

  function monoStart(){
    if(mono.running) return;
    mono.running = true;
    $("monoStart").disabled = true;
    $("monoStop").disabled = false;
    monoResize();
    mono.N = Math.max(48, Math.min(256, parseInt($("monoRes").value||"128",10)));
    mono.engine = ($("monoEngine") && $("monoEngine").value) ? $("monoEngine").value : "poles";
    if(mono.engine==="eqv"){
      eqvEnsureAlloc();
      if($("eqvState") && !eqv.baseReady) $("eqvState").textContent = "need base";
    }
    if(mono.engine==="poles" && (!mono.poles || mono.poles.length<3)) monoRebuildPoles();
    mono.last = 0;
    mono.raf = requestAnimationFrame(monoLoop);
  }
  function monoStop(){
    mono.running = false;
    $("monoStart").disabled = false;
    $("monoStop").disabled = true;
    if(mono.raf){ cancelAnimationFrame(mono.raf); mono.raf=0; }
    $("monoState").textContent = "idle";
  }
  function monoToggleTilt(){
    mono.tilt = !mono.tilt;
    const wrap = $("monoTiltWrap");
    if(mono.tilt) wrap.classList.add("tilt45"); else wrap.classList.remove("tilt45");
  }
  function monoFullscreen(){
    const el = $("monoTiltWrap");
    if(!document.fullscreenElement){
      (el.requestFullscreen ? el.requestFullscreen() : $("monoCanvas").requestFullscreen?.()).catch(()=>{});
    }else{
      document.exitFullscreen?.().catch(()=>{});
    }
  }

  function applyMonoState(s){
    if(!s || mono.sync!=="rx") return;
    if(typeof s.N === "number"){
      mono.N = Math.max(48, Math.min(256, Math.floor(s.N)));
      $("monoRes").value = String(mono.N);
    }
    if(Array.isArray(s.poles) && s.poles.length>=3){
      mono.poles = s.poles.map(p=>({
        x: (Number(p.x)||0)%1, y:(Number(p.y)||0)%1,
        ph: Number(p.ph)||0, w: Number(p.w)||0,
        a: Math.max(0.05, Math.min(2.5, Number(p.a)||1))
      }));
    }
    if(!mono.running) monoStart();
  }

  function loadMonoText(){
    const txt =
`BAS‑Uni / origami‑QM screen monograph (on‑screen excerpt)

Goal: treat the screen as a controllable emitter array and use multi‑pole operator dynamics to generate phase‑structured fields.

• “Three‑pole minimum”: with ≥3 interacting poles, phase‑coupled feedback can destabilize simple periodic motion and produce rich, chaotic‑like textures.

• Origami principle: geometry (fold/angle) sets a boundary condition. Here we expose a 45° tilt transform so two screens can be physically aligned under an optic fixture.

• TRX link: when Sync=TX, the pole state broadcasts over the DataChannel. When Sync=RX, the other phone follows the same pole‑operator state, producing matched fields on both screens.

Next: you can replace this excerpt with full text extracted from your PDFs and scroll it while the field runs underneath.`;
    $("monoText").textContent = txt;
  }

  // Wire UI
  $("tabTrx").onclick = ()=> setActiveTab("trx");
  $("tabMono").onclick = ()=> setActiveTab("mono");
  if($("tabLlm")) $("tabLlm").onclick = ()=> setActiveTab("llm");
  if($("tabAqc")) $("tabAqc").onclick = ()=> setActiveTab("aqc");
  if($("tabLayouts")) $("tabLayouts").onclick = ()=> { setActiveTab("layouts"); layoutsBuildGrid(); layoutsRenderPreview(); };

  $("monoStart").onclick = ()=> monoStart();
  $("monoStop").onclick = ()=> monoStop();
  $("monoTilt").onclick = ()=> monoToggleTilt();
  $("monoFull").onclick = ()=> monoFullscreen();
  $("monoPoles").onchange = ()=> { monoRebuildPoles(); if(mono.running) drawMono(); };
  $("monoRes").onchange = ()=> { mono.N = parseInt($("monoRes").value||"128",10); if(mono.engine==="eqv") eqvEnsureAlloc(); if(mono.running) drawMono(); };
  $("monoSync").onchange = ()=> updateSyncPill();
  $("monoLoadText").onclick = ()=> loadMonoText();
  $("monoClearText").onclick = ()=> { $("monoText").textContent=""; };


  // EQV UI
  if($("monoEngine")){
    $("monoEngine").onchange = ()=>{
      mono.engine = $("monoEngine").value || "poles";
      if(mono.engine==="eqv"){
        eqvEnsureAlloc();
          if($("eqvState") && !eqv.baseReady) $("eqvState").textContent = "need base";
      }
      if(mono.running) drawMono();
    };
  }
  if($("eqvPreset")) $("eqvPreset").onchange = ()=> { eqvApplyPreset($("eqvPreset").value||"stable"); if(mono.running) drawMono(); };
  if($("eqvSnap")) $("eqvSnap").onclick = async ()=>{ mono.engine="eqv"; if($("monoEngine")) $("monoEngine").value="eqv"; await eqvSnapFromCamera(); if(!mono.running) monoStart(); };
  if($("eqvLoadImg")) $("eqvLoadImg").onclick = ()=> $("eqvImg")?.click();
  if($("eqvImg")) $("eqvImg").addEventListener("change", async (e)=>{ const f=e.target.files && e.target.files[0]; mono.engine="eqv"; if($("monoEngine")) $("monoEngine").value="eqv"; await eqvLoadImageFile(f); if(!mono.running) monoStart(); });

  if($("eqvSend")) $("eqvSend").onclick = ()=> eqvSendToPeer();
  if($("eqvRecv")) $("eqvRecv").onclick = ()=> eqvRequestFromPeer();

  // mark EQV params dirty on edits
  for(const id of ["eqvDt","eqvD","eqvK1","eqvK2","eqvK3","eqvBeta","eqvLam","eqvMu","eqvKap","eqvPer","eqvModes"]){
    const el = $(id);
    if(el) el.addEventListener("input", ()=>{ eqv.dirty = true; });
  }

  // ---------------- LLM tab ----------------
  
  // Quantum AI Trainer (phase / trig, in-browser)
  const QTrain = {
    urls: {
      train: "https://storage.googleapis.com/download.tensorflow.org/data/iris_training.csv",
      test: "https://storage.googleapis.com/download.tensorflow.org/data/iris_test.csv"
    },
    data: null,
    model: null,
    stop: false,
    steps: 0,
    lastReport: ""
  };

  function qSetPill(txt){
    const p = $("qtrainPill"); if(!p) return;
    p.textContent = txt;
  }

  function qSetStatus(txt){
    if($("qtrainStatus")) $("qtrainStatus").textContent = txt;
    qSetPill(txt);
  }

  function qLog(line){
    const box = $("qtrainLog");
    if(!box) return;
    box.textContent += (line + "\n");
    box.scrollTop = box.scrollHeight;
  }

  function qDiag(line){
    const box = $("qdiagOut");
    if(!box) return;
    box.textContent += (line + "\n");
    box.scrollTop = box.scrollHeight;
  }

  function qLCG(seed){
    let s = (seed>>>0) || 1;
    return function(){
      s = (1664525 * s + 1013904223) >>> 0;
      return s / 4294967296;
    };
  }

  function qShuffleInPlace(X, y, rnd){
    for(let i=X.length-1;i>0;i--){
      const j = Math.floor(rnd()*(i+1));
      const tx = X[i]; X[i]=X[j]; X[j]=tx;
      const ty = y[i]; y[i]=y[j]; y[j]=ty;
    }
  }

  function qParseCSV(text){
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    // accept header or no header
    let start = 0;
    if(lines.length && /sepal|petal|species/i.test(lines[0])) start = 1;
    const X = [];
    const y = [];
    for(let i=start;i<lines.length;i++){ 
      const parts = lines[i].split(",").map(s=>s.trim());
      if(parts.length < 5) continue;
      const x = parts.slice(0,4).map(v=>parseFloat(v));
      const label = parseInt(parts[4],10);
      if(x.some(v=>!Number.isFinite(v)) || !Number.isFinite(label)) continue;
      X.push(x); y.push(label);
    }
    return {X, y};
  }

  function qStdFit(X){
    const d = X[0].length;
    const mu = new Array(d).fill(0);
    const sig = new Array(d).fill(0);
    for(const row of X) for(let j=0;j<d;j++) mu[j]+=row[j];
    for(let j=0;j<d;j++) mu[j]/=X.length;
    for(const row of X) for(let j=0;j<d;j++){ const v=row[j]-mu[j]; sig[j]+=v*v; }
    for(let j=0;j<d;j++){ sig[j]=Math.sqrt(sig[j]/Math.max(1,(X.length-1))); if(sig[j]===0) sig[j]=1; }
    return {mu, sig};
  }

  function qStdApply(X, mu, sig){
    return X.map(row => row.map((v,j)=>(v-mu[j])/sig[j]));
  }

  function qOneHot(k, C){ const v=new Array(C).fill(0); v[k]=1; return v; }

  function qSoftmax(logits){
    let m = -Infinity; for(const z of logits) if(z>m) m=z;
    const exps = logits.map(z=>Math.exp(z-m));
    let s = 0; for(const e of exps) s+=e;
    return exps.map(e=>e/s);
  }

  function qInitModel(depth, seed){
    const rnd = qLCG(seed);
    const model = {
      depth,
      encS: new Array(4).fill(0).map(()=> (rnd()*2-1)*0.7),
      encB: new Array(4).fill(0).map(()=> (rnd()*2-1)*0.7),
      // phi[layer][0..3] for rotations: (0,1),(2,3),(1,2),(0,3)
      phi: new Array(depth).fill(0).map(()=> new Array(4).fill(0).map(()=> (rnd()*2-1)*0.6)),
      W: new Array(3).fill(0).map(()=> new Array(4).fill(0).map(()=> (rnd()*2-1)*0.4)),
      b: new Array(3).fill(0).map(()=> (rnd()*2-1)*0.1)
    };
    return model;
  }

  function qApplyRot(re, im, p, q, phi, rotCache){
    const c = Math.cos(phi), s = Math.sin(phi);
    const rp = re[p], rq = re[q], ip = im[p], iq = im[q];
    // outputs
    re[p] = c*rp - s*rq;
    re[q] = s*rp + c*rq;
    im[p] = c*ip - s*iq;
    im[q] = s*ip + c*iq;
    rotCache.push({p,q,phi,c,s, rp,rq, ip,iq});
  }

  function qForward(x, model){
    // encode complex amplitudes a_j = cos(theta_j) + i sin(theta_j) = exp(i theta_j)
    const theta = new Array(4);
    const re = new Array(4);
    const im = new Array(4);
    for(let j=0;j<4;j++){ 
      theta[j] = model.encS[j]*x[j] + model.encB[j];
      re[j] = Math.cos(theta[j]);
      im[j] = Math.sin(theta[j]);
    }
    const rotCache = [];
    for(let l=0;l<model.depth;l++){ 
      const ph = model.phi[l];
      qApplyRot(re, im, 0,1, ph[0], rotCache);
      qApplyRot(re, im, 2,3, ph[1], rotCache);
      qApplyRot(re, im, 1,2, ph[2], rotCache);
      qApplyRot(re, im, 0,3, ph[3], rotCache);
    }
    const p = new Array(4);
    for(let j=0;j<4;j++) p[j] = re[j]*re[j] + im[j]*im[j];
    const logits = new Array(3).fill(0);
    for(let k=0;k<3;k++){ 
      let z = model.b[k];
      for(let j=0;j<4;j++) z += model.W[k][j]*p[j];
      logits[k]=z;
    }
    const probs = qSoftmax(logits);
    return {theta, re, im, p, logits, probs, rotCache};
  }

  function qBackpropBatch(Xb, yb, model){
    // grads
    const g = {
      encS: new Array(4).fill(0),
      encB: new Array(4).fill(0),
      phi: new Array(model.depth).fill(0).map(()=> new Array(4).fill(0)),
      W: new Array(3).fill(0).map(()=> new Array(4).fill(0)),
      b: new Array(3).fill(0)
    };
    let loss = 0;

    for(let n=0;n<Xb.length;n++){ 
      const x = Xb[n];
      const y = yb[n];
      const f = qForward(x, model);
      const probs = f.probs;

      // cross-entropy
      const py = Math.max(1e-12, probs[y]);
      loss += -Math.log(py);

      // dL/dlogits = probs - onehot
      const dlog = probs.map((p,k)=> p - (k===y?1:0));

      // grads W,b and dL/dp
      const dp = new Array(4).fill(0);
      for(let k=0;k<3;k++){ 
        g.b[k] += dlog[k];
        for(let j=0;j<4;j++){ 
          g.W[k][j] += dlog[k]*f.p[j];
          dp[j] += dlog[k]*model.W[k][j];
        }
      }

      // dL/dre, dL/dim from p = re^2+im^2
      const dre = new Array(4);
      const dim = new Array(4);
      for(let j=0;j<4;j++){ 
        dre[j] = dp[j]*2*f.re[j];
        dim[j] = dp[j]*2*f.im[j];
      }

      // backprop rotations (reverse order)
      // Need to map each rotation back to layer+slot
      // rotCache order per layer: 4 entries; total = depth*4
      for(let r=f.rotCache.length-1; r>=0; r--){ 
        const rot = f.rotCache[r];
        const {p,q,c,s,rp,rq,ip,iq} = rot;
        const grep = dre[p], greq = dre[q], gimp = dim[p], gimq = dim[q];

        // dphi contribution
        const dphi = grep*(-s*rp - c*rq) + greq*(c*rp - s*rq) + gimp*(-s*ip - c*iq) + gimq*(c*ip - s*iq);

        const layer = Math.floor(r/4);
        const slot = r % 4;
        g.phi[layer][slot] += dphi;

        // grads to inputs
        dre[p] = c*grep + s*greq;
        dre[q] = -s*grep + c*greq;
        dim[p] = c*gimp + s*gimq;
        dim[q] = -s*gimp + c*gimq;
      }

      // backprop encoder
      for(let j=0;j<4;j++){ 
        const th = f.theta[j];
        const dth = dre[j]*(-Math.sin(th)) + dim[j]*(Math.cos(th));
        g.encS[j] += dth * x[j];
        g.encB[j] += dth;
      }
    }

    const invN = 1/Math.max(1, Xb.length);
    loss *= invN;

    // average grads
    for(let j=0;j<4;j++){ g.encS[j]*=invN; g.encB[j]*=invN; }
    for(let l=0;l<model.depth;l++) for(let s=0;s<4;s++) g.phi[l][s]*=invN;
    for(let k=0;k<3;k++){ 
      g.b[k]*=invN;
      for(let j=0;j<4;j++) g.W[k][j]*=invN;
    }

    return {g, loss};
  }

  function qWrapPi(x){
    // keep in [-pi, pi]
    const pi2 = 2*Math.PI;
    x = ((x + Math.PI) % pi2 + pi2) % pi2 - Math.PI;
    return x;
  }

  function qUpdate(model, grads, lr){
    for(let j=0;j<4;j++){ 
      model.encS[j] -= lr*grads.encS[j];
      model.encB[j] -= lr*grads.encB[j];
      model.encB[j] = qWrapPi(model.encB[j]);
    }
    for(let l=0;l<model.depth;l++) for(let s=0;s<4;s++){ 
      model.phi[l][s] -= lr*grads.phi[l][s];
      model.phi[l][s] = qWrapPi(model.phi[l][s]);
    }
    for(let k=0;k<3;k++){ 
      model.b[k] -= lr*grads.b[k];
      for(let j=0;j<4;j++) model.W[k][j] -= lr*grads.W[k][j];
    }
  }

  function qPredict(X, model){
    const preds = new Array(X.length);
    for(let i=0;i<X.length;i++){ 
      const probs = qForward(X[i], model).probs;
      let best=0, bv=-1;
      for(let k=0;k<probs.length;k++) if(probs[k]>bv){ bv=probs[k]; best=k; }
      preds[i]=best;
    }
    return preds;
  }

  function qAcc(pred, y){
    let ok=0;
    for(let i=0;i<y.length;i++) if(pred[i]===y[i]) ok++;
    return ok/y.length;
  }

  async function qFetchWithTimeout(url, ms=9000){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), ms);
    try{
      const res = await fetch(url, {signal: ctrl.signal, cache:"no-store"});
      clearTimeout(t);
      return res;
    }catch(e){
      clearTimeout(t);
      throw e;
    }
  }

  function qFallbackIris(){
    // tiny, embedded (not the full dataset) so the page still runs offline
    const X = [
      [5.1,3.5,1.4,0.2],[4.9,3.0,1.4,0.2],[4.7,3.2,1.3,0.2],
      [6.4,3.2,4.5,1.5],[6.9,3.1,4.9,1.5],[5.5,2.3,4.0,1.3],
      [6.5,3.0,5.8,2.2],[7.6,3.0,6.6,2.1],[4.9,2.5,4.5,1.7]
    ];
    const y = [0,0,0, 1,1,1, 2,2,1];
    // split last 3 as test
    return {
      train: {X: X.slice(0,6), y: y.slice(0,6)},
      test:  {X: X.slice(6),  y: y.slice(6)}
    };
  }

  async function qVerifyDatasetLinks(){
    $("qdiagOut") && ($("qdiagOut").textContent = "");
    qDiag("Link check (fetch):");
    for(const [name,url] of Object.entries(QTrain.urls)){
      try{
        const res = await qFetchWithTimeout(url, 9000);
        qDiag(`- ${name}: HTTP ${res.status} ${res.ok?"OK":"FAIL"}`);
        // sanity read a bit
        const txt = await res.text();
        qDiag(`  bytes: ${txt.length}; first line: ${txt.split(/\r?\n/)[0].slice(0,120)}`);
      }catch(e){
        qDiag(`- ${name}: FAILED (${e.name||"error"}) ${e.message||String(e)}`);
      }
    }
  }

  async function qLoadDataset(){
    qLog("");
    qSetStatus("loading data…");
    const dsSel = $("qtrainDataset")?.value || "tf_iris";
    let train, test;
    if(dsSel==="tf_iris"){
      try{
        const r1 = await qFetchWithTimeout(QTrain.urls.train, 12000);
        const t1 = await r1.text();
        const r2 = await qFetchWithTimeout(QTrain.urls.test, 12000);
        const t2 = await r2.text();
        train = qParseCSV(t1);
        test  = qParseCSV(t2);
        if(train.X.length<20 || test.X.length<10) throw new Error("Dataset parsed too small; falling back.");
      }catch(e){
        qLog("Dataset fetch/parse failed; using embedded fallback. (" + (e.message||String(e)) + ")");
        const fb = qFallbackIris();
        train = fb.train; test = fb.test;
      }
    } else {
      const fb = qFallbackIris();
      train = fb.train; test = fb.test;
    }

    const stats = qStdFit(train.X);
    const Xtr = qStdApply(train.X, stats.mu, stats.sig);
    const Xte = qStdApply(test.X,  stats.mu, stats.sig);

    QTrain.data = {
      train: {X: Xtr, y: train.y},
      test:  {X: Xte, y: test.y},
      raw: {train, test},
      stats
    };

    qLog(`Loaded: train=${train.X.length} test=${test.X.length}`);
    qSetStatus("data ready");
    return QTrain.data;
  }

  function qShowSample(){
    if(!QTrain.data){ qLog("No data loaded yet."); return; }
    const tr = QTrain.data.raw.train;
    const te = QTrain.data.raw.test;
    qLog("Sample rows (raw):");
    for(let i=0;i<Math.min(3,tr.X.length);i++) qLog("train  " + JSON.stringify(tr.X[i]) + " -> " + tr.y[i]);
    for(let i=0;i<Math.min(3,te.X.length);i++) qLog("test   " + JSON.stringify(te.X[i]) + " -> " + te.y[i]);
  }

  function qInit(){
    const depth = Math.max(1, Math.min(8, parseInt($("qtrainDepth")?.value||"4",10)));
    const seed  = parseInt($("qtrainSeed")?.value||"1337",10)>>>0;
    QTrain.model = qInitModel(depth, seed);
    QTrain.steps = 0;
    if($("qtrainSteps")) $("qtrainSteps").textContent = String(QTrain.steps);
    qLog("Model initialized. depth=" + depth + " seed=" + seed);
    qSetStatus("model ready");
  }

  async function qTrainRun(){
    if(!QTrain.data) await qLoadDataset();
    if(!QTrain.model) qInit();

    const epochs = Math.max(1, parseInt($("qtrainEpochs")?.value||"60",10));
    const batch  = Math.max(1, parseInt($("qtrainBatch")?.value||"16",10));
    const lr     = Math.max(1e-6, parseFloat($("qtrainLR")?.value||"0.03"));

    const X = QTrain.data.train.X.slice();
    const y = QTrain.data.train.y.slice();
    const rnd = qLCG((parseInt($("qtrainSeed")?.value||"1337",10)>>>0) ^ 0xA5A5A5A5);

    QTrain.stop = false;
    qSetStatus("training…");
    qLog("Training: epochs=" + epochs + " batch=" + batch + " lr=" + lr.toFixed(4));

    for(let ep=1; ep<=epochs; ep++){ 
      qShuffleInPlace(X, y, rnd);
      let epLoss = 0;
      let steps = 0;
      for(let i=0; i<X.length; i+=batch){ 
        if(QTrain.stop) break;
        const Xb = X.slice(i, i+batch);
        const yb = y.slice(i, i+batch);
        const {g, loss} = qBackpropBatch(Xb, yb, QTrain.model);
        qUpdate(QTrain.model, g, lr);
        epLoss += loss;
        steps++;
        QTrain.steps++;
        if(QTrain.steps % 10 === 0){ 
          if($("qtrainSteps")) $("qtrainSteps").textContent = String(QTrain.steps);
          if($("qtrainLoss")) $("qtrainLoss").textContent = (epLoss/steps).toFixed(4);
          await new Promise(r=>setTimeout(r, 0));
        }
      }
      if(QTrain.stop){ qLog("Stopped."); break; }

      // metrics at epoch end
      const predTr = qPredict(QTrain.data.train.X, QTrain.model);
      const predTe = qPredict(QTrain.data.test.X, QTrain.model);
      const accTr = qAcc(predTr, QTrain.data.train.y);
      const accTe = qAcc(predTe, QTrain.data.test.y);

      if($("qtrainAcc")) $("qtrainAcc").textContent = (100*accTr).toFixed(1) + "%";
      if($("qtestAcc")) $("qtestAcc").textContent  = (100*accTe).toFixed(1) + "%";
      if($("qtrainLoss")) $("qtrainLoss").textContent = (epLoss/Math.max(1,steps)).toFixed(4);

      qLog(`epoch ${ep}/${epochs}  loss=${(epLoss/Math.max(1,steps)).toFixed(4)}  train=${(100*accTr).toFixed(1)}%  test=${(100*accTe).toFixed(1)}%`);
      await new Promise(r=>setTimeout(r, 0));
    }

    qSetStatus(QTrain.stop ? "stopped" : "trained");
  }

  function qStop(){
    QTrain.stop = true;
    qSetStatus("stopping…");
  }

  function qEval(){
    if(!QTrain.data || !QTrain.model){ qLog("Load data + init model first."); return; }
    const predTr = qPredict(QTrain.data.train.X, QTrain.model);
    const predTe = qPredict(QTrain.data.test.X, QTrain.model);
    const accTr = qAcc(predTr, QTrain.data.train.y);
    const accTe = qAcc(predTe, QTrain.data.test.y);
    if($("qtrainAcc")) $("qtrainAcc").textContent = (100*accTr).toFixed(1) + "%";
    if($("qtestAcc")) $("qtestAcc").textContent  = (100*accTe).toFixed(1) + "%";
    qLog("Eval: train=" + (100*accTr).toFixed(1) + "% test=" + (100*accTe).toFixed(1) + "%");
    qSetStatus("evaluated");
  }

  function qExport(){
    if(!QTrain.model){ qLog("No model to export."); return; }
    const payload = {
      type: "quantum-ai-trig-phase-model",
      created_at: new Date().toISOString(),
      dataset: $("qtrainDataset")?.value || "tf_iris",
      model: QTrain.model
    };
    const json = JSON.stringify(payload, null, 2);
    const blob = new Blob([json], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "quantum_ai_weights.json";
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    qLog("Exported weights as quantum_ai_weights.json");
  }

  function qDiagReportLine(s){
    QTrain.lastReport += s + "\n";
    qDiag(s);
  }

  async function runDiagnostics(fetchLinks=true){
    if($("qdiagOut")) $("qdiagOut").textContent = "";
    QTrain.lastReport = "";
    qDiagReportLine("Diagnostics @ " + new Date().toLocaleString());
    const btns = Array.from(document.querySelectorAll("button"));
    qDiagReportLine("Buttons: " + btns.length);

    const noId = btns.filter(b=>!b.id).length;
    qDiagReportLine("Buttons missing id: " + noId);

    // check key buttons exist + are wired (onclick not null)
    const must = ["aqaiLoadTf","aqaiVerifyLinks","aqaiDownload","aqaiInit","aqaiTrain","aqaiStop","aqaiEval","aqaiGenerate","aqaiClearGen","aqaiExport","aqaiDiag","aqaiHfList","aqaiHfVerify","aqaiHfLoad","aqaiHfAuto","aqaiHfStop","ovCompute","ovMore","tabLayouts","layoutsApply","layoutsCompute","layoutsOpenOverlay","computeBtn"];
    for(const id of must){
      const el = $(id);
      if(!el) qDiagReportLine("MISSING: #" + id);
      else {
        const wired = (typeof el.onclick === "function") || (el.dataset && el.dataset.wired);
        qDiagReportLine((wired ? "OK: " : "WARN: ") + "#" + id + (wired? "" : " (no onclick detected)"));
      }
    }

    // quick scan for likely unbound buttons
    const suspicious = btns
      .filter(b=>b.id && !b.disabled)
      .filter(b=> typeof b.onclick !== "function")
      .map(b=>b.id)
      .slice(0, 40);
    if(suspicious.length) qDiagReportLine("Unwired active buttons (first 40): " + suspicious.join(", "));
    else qDiagReportLine("No obvious unwired active buttons found.");

    // link checks
    if(fetchLinks){
      const links = Array.from(document.querySelectorAll('a[href^="http"]'));
      qDiagReportLine("Links (http/https): " + links.length);
      for(const a of links){
        const url = a.getAttribute("href");
        try{
          const res = await qFetchWithTimeout(url, 9000);
          qDiagReportLine("LINK OK: " + url + " (HTTP " + res.status + ")");
        }catch(e){
          qDiagReportLine("LINK FAIL: " + url + " (" + (e.name||"error") + ")");
        }
      }
    } else {
      qDiagReportLine("Link fetch skipped.");
    }

    qSetStatus("diag done");
  }

  function qDiagCopy(){
    try{
      navigator.clipboard.writeText(QTrain.lastReport || $("qdiagOut")?.textContent || "");
      qDiag("Copied.");
    }catch(e){
      qDiag("Copy failed: " + (e.message||String(e)));
    }
  }


  function llmAddMsg(who, txt){
    const box = $("llmLog");
    if(!box) return;
    const row = document.createElement("div");
    row.className = "chatMsg";
    const w = document.createElement("div");
    w.className = "who";
    w.textContent = who;
    const t = document.createElement("div");
    t.className = "txt";
    t.textContent = txt;
    row.appendChild(w); row.appendChild(t);
    box.appendChild(row);
    box.scrollTop = box.scrollHeight;
  }

  function llmSetState(s){
    if($("llmState")) $("llmState").textContent = s;
  }

  function llmSaveLocal(){
    const payload = {
      system: $("llmSystem")?.value||"",
      backend: $("llmBackend")?.value||"local",
      url: $("llmUrl")?.value||"",
      model: $("llmModel")?.value||"",
      key: $("llmKey")?.value||"",
      chat: $("llmLog")?.innerText||""
    };
    localStorage.setItem("baz_llm_cfg", JSON.stringify(payload));
    llmAddMsg("system", "Saved locally.");
  }

  function llmLoadLocal(){
    const raw = localStorage.getItem("baz_llm_cfg");
    if(!raw){ llmAddMsg("system", "No saved config found."); return; }
    try{
      const p = JSON.parse(raw);
      if($("llmSystem")) $("llmSystem").value = p.system||"";
      if($("llmBackend")) $("llmBackend").value = p.backend||"local";
      if($("llmUrl")) $("llmUrl").value = p.url||"";
      if($("llmModel")) $("llmModel").value = p.model||"";
      if($("llmKey")) $("llmKey").value = p.key||"";
      llmAddMsg("system", "Loaded locally.");
    }catch(e){
      llmAddMsg("system", "Load failed: " + (e.message||String(e)));
    }
  }

  function llmClear(){
    const box = $("llmLog");
    if(box) box.innerHTML = "";
    llmSetState("idle");
  }

  async function llmLocalStub(system, user){
    // Offline stub: deterministic “assistant” that can at least route commands.
    const s = (system||"").trim();
    const u = (user||"").trim();
    if(/^\/help\b/i.test(u)){
      return "Commands:\n/help\n/status (webrtc)\n/eqv (print current EQV params)\n\nOtherwise this is an offline stub. Switch backend to use a real endpoint.";
    }
    if(/^\/status\b/i.test(u)){
      return `RTC=${pc?pc.connectionState:"—"} ICE=${pc?pc.iceConnectionState:"—"} DC=${dc?dc.readyState:"—"} engine=${mono.engine} sync=${mono.sync}`;
    }
    if(/^\/eqv\b/i.test(u)){
      eqvReadParamsFromUI();
      return JSON.stringify({N:eqv.N, t:eqv.t, params:eqv.params, modes:eqv.modes}, null, 2);
    }
    // fallback: simple reflection
    return (s?`[system applied]\n`:"") + "Stub reply: " + u;
  }

  async function llmCallOpenAICompat(system, user){
    const url = ($("llmUrl")?.value||"").trim();
    const model = ($("llmModel")?.value||"").trim() || "gpt-4.1-mini";
    const key = ($("llmKey")?.value||"").trim();

    if(!url){
      throw new Error("Missing endpoint URL.");
    }

    // Try Chat Completions schema (widely supported)
    const body = {
      model,
      messages: [
        ...(system ? [{role:"system", content:system}] : []),
        {role:"user", content:user}
      ],
      temperature: 0.2
    };

    const headers = {"Content-Type":"application/json"};
    if(key) headers["Authorization"] = key.startsWith("Bearer ") ? key : ("Bearer " + key);

    const r = await fetch(url, {method:"POST", headers, body:JSON.stringify(body)});
    if(!r.ok){
      const t = await r.text().catch(()=> "");
      throw new Error("HTTP " + r.status + " " + (t || r.statusText));
    }
    const j = await r.json();
    const msg = j?.choices?.[0]?.message?.content ?? j?.output_text ?? "";
    return String(msg||"");
  }

  async function llmSendLocal(){
    const msg = ($("llmInput")?.value||"").trim();
    if(!msg) return;
    $("llmInput").value = "";
    llmAddMsg("you", msg);

    const system = $("llmSystem")?.value||"";
    const backend = $("llmBackend")?.value||"local";

    llmSetState("thinking");
    try{
      let out = "";
      if(backend==="openai"){
        out = await llmCallOpenAICompat(system, msg);
      }else if(backend==="aqai"){
        out = await (window.__aqaiChatReply ? window.__aqaiChatReply(msg) : Promise.resolve("(AQAI not loaded)"));
      }else{
        out = await llmLocalStub(system, msg);
      }
      llmAddMsg("assistant", out);
      llmSetState("idle");
    }catch(e){
      llmAddMsg("error", (e.message||String(e)));
      llmSetState("idle");
    }
  }

  function llmSendPeer(){
    const msg = ($("llmInput")?.value||"").trim();
    if(!msg) return;
    $("llmInput").value = "";
    llmAddMsg("you→peer", msg);
    if(!dc || dc.readyState!=="open"){ llmAddMsg("error","DataChannel not open."); return; }
    try{
      dc.send(JSON.stringify({t:"llm", kind:"msg", m:msg}));
    }catch(e){
      llmAddMsg("error", "Send failed: " + (e.message||String(e)));
    }
  }

  if($("llmSend")) $("llmSend").onclick = ()=> llmSendLocal();
  if($("llmSendPeer")) $("llmSendPeer").onclick = ()=> llmSendPeer();
  if($("llmSendPeer")) $("llmSendPeer").disabled = !(dc && dc.readyState==="open");
  if($("llmClear")) $("llmClear").onclick = ()=> llmClear();
  if($("llmSave")) $("llmSave").onclick = ()=> llmSaveLocal();
  if($("llmLoad")) $("llmLoad").onclick = ()=> llmLoadLocal();

  // Quantum AI Trainer wiring
  if($("qtrainVerify")) $("qtrainVerify").onclick = ()=> qVerifyDatasetLinks();
  if($("qtrainLoad")) $("qtrainLoad").onclick = ()=> qLoadDataset();
  if($("qtrainShow")) $("qtrainShow").onclick = ()=> qShowSample();
  if($("qtrainInit")) $("qtrainInit").onclick = ()=> qInit();
  if($("qtrainRun")) $("qtrainRun").onclick = ()=> qTrainRun();
  if($("qtrainStop")) $("qtrainStop").onclick = ()=> qStop();
  if($("qtrainEval")) $("qtrainEval").onclick = ()=> qEval();
  if($("qtrainExport")) $("qtrainExport").onclick = ()=> qExport();
  if($("qdiagRun")) $("qdiagRun").onclick = ()=> runDiagnostics(true);
  if($("qdiagCopy")) $("qdiagCopy").onclick = ()=> qDiagCopy();

  // AQAI LLM UI bindings
  if($("aqaiLoadTf")) $("aqaiLoadTf").onclick = async ()=>{ aqaiPill("loading TF"); try{ await aqaiEnsureTf(); aqaiPill("TF ready"); aqaiLog("TF.js loaded."); }catch(e){ aqaiPill("TF load failed"); aqaiLog(String(e?.message||e)); } };
  if($("aqaiBackendWebgl")) $("aqaiBackendWebgl").onclick = ()=> aqaiSetBackend("webgl");
  if($("aqaiBackendCpu")) $("aqaiBackendCpu").onclick = ()=> aqaiSetBackend("cpu");
  if($("aqaiVerifyLinks")) $("aqaiVerifyLinks").onclick = ()=> aqaiVerifyLinks();
  if($("aqaiDownload")) $("aqaiDownload").onclick = ()=> aqaiDownloadCorpus();
  if($("aqaiInit")) $("aqaiInit").onclick = ()=> aqaiInitModel();
  if($("aqaiTrain")) $("aqaiTrain").onclick = async ()=> { setQuantumComputingActive(true); try{ await aqaiTrain(); } finally { setQuantumComputingActive(false); } };
  if($("aqaiStop")) $("aqaiStop").onclick = ()=> aqaiStop();
  if($("aqaiEval")) $("aqaiEval").onclick = async ()=> { setQuantumComputingActive(true); try{ await aqaiEval(); } finally { setQuantumComputingActive(false); } };
  if($("aqaiUse")) $("aqaiUse").onclick = ()=> aqaiUseInChat();
  if($("aqaiExport")) $("aqaiExport").onclick = ()=> aqaiExport();
  if($("aqaiImport")) $("aqaiImport").addEventListener("change", (e)=>{ const f=e.target.files?.[0]; if(f) aqaiImportFile(f); e.target.value=""; });
  if($("aqaiGenerate")) $("aqaiGenerate").onclick = async ()=> { setQuantumComputingActive(true); try{ await aqaiGenerate(); } finally { setQuantumComputingActive(false); } };
  if($("aqaiClearGen")) $("aqaiClearGen").onclick = ()=> aqaiClearGen();
  if($("aqaiDiag")) $("aqaiDiag").onclick = ()=> aqaiRunChecks(true);
  if($("aqaiDiagCopy")) $("aqaiDiagCopy").onclick = ()=> aqaiCopyReport();
  if($("aqaiHfList")) $("aqaiHfList").onclick = ()=> aqaiHfList();
  if($("aqaiHfVerify")) $("aqaiHfVerify").onclick = ()=> aqaiHfVerify();
  if($("aqaiHfLoad")) $("aqaiHfLoad").onclick = ()=> aqaiHfStreamToBuffer(false);
  if($("aqaiHfAuto")) $("aqaiHfAuto").onclick = ()=> aqaiHfStreamToBuffer(true);
  if($("aqaiHfStop")) $("aqaiHfStop").onclick = ()=> aqaiHfStop();
  if($("aqaiHfConfig")) $("aqaiHfConfig").onchange = ()=> aqaiHfRenderFiles();
  if($("aqaiHfSplit")) $("aqaiHfSplit").onchange = ()=> aqaiHfRenderFiles();


  // quick self-check on load (no link fetch)
  setTimeout(()=>{ try{ runDiagnostics(false); }catch(e){} }, 60);


  // ---------------- AQAI LLM (Transformer) ----------------
  const AQAI = {
    tf: null,
    readyTf: false,
    corpusBytes: new Uint8Array(0),
    corpusText: "",
    model: null,
    weights: null,
    optimizer: null,
    stop: false,
    lastReport: "",
    vocab: 256, // byte-level
    asciiMask: null,
    use: { rope:true, me:true },
    cache: { ropeSin:null, ropeCos:null, mask:null, modMask:null, cfg:null },
  };

  function aqaiLog(s){
    const box = $("aqaiLog");
    if(box){
      box.textContent += s + "\n";
      box.scrollTop = box.scrollHeight;
    }
  }
  function aqaiPill(s){ if($("aqaiPill")) $("aqaiPill").textContent = s; }
  function aqaiBytesUpdate(){
    const len = aqaiCorpusLen();
    if($("aqaiBytes")) $("aqaiBytes").textContent = String(len);
  }

  function aqaiSetRingCapacity(bytes){
    bytes = Math.max(1024, Math.floor(bytes||0));
    if(!AQAI.ring || AQAI.ring.buf.length !== bytes){
      AQAI.ring = { buf: new Uint8Array(bytes), start: 0, len: 0, seen: 0 };
    }
  }

  function aqaiRingAppend(u8){
    if(!u8 || !u8.length) return;
    if(!AQAI.ring) aqaiSetRingCapacity(Math.max(8*1024*1024, u8.length));
    const r = AQAI.ring;
    const N = r.buf.length;

    // If incoming chunk is bigger than the whole ring, keep only the tail
    if(u8.length >= N){
      r.buf.set(u8.subarray(u8.length - N));
      r.start = 0;
      r.len = N;
      r.seen += u8.length;
      return;
    }

    // Drop oldest bytes if needed
    const total = r.len + u8.length;
    if(total > N){
      const drop = total - N;
      r.start = (r.start + drop) % N;
      r.len = N - u8.length;
    }

    // Write at end
    let end = (r.start + r.len) % N;
    const first = Math.min(u8.length, N - end);
    r.buf.set(u8.subarray(0, first), end);
    if(first < u8.length){
      r.buf.set(u8.subarray(first), 0);
    }
    r.len = Math.min(N, r.len + u8.length);
    r.seen += u8.length;
  }

  function aqaiCorpusLen(){
    if(AQAI.ring) return AQAI.ring.len;
    return (AQAI.corpusBytes && AQAI.corpusBytes.length) ? AQAI.corpusBytes.length : 0;
  }

  function aqaiCorpusGet(i){
    if(AQAI.ring){
      const r = AQAI.ring;
      return r.buf[(r.start + i) % r.buf.length];
    }
    return AQAI.corpusBytes[i];
  }


  function aqaiDiagLine(s){
    AQAI.lastReport += s + "\n";
    if($("aqaiDiagOut")) $("aqaiDiagOut").textContent = AQAI.lastReport;
  }

  async function aqaiFetchWithTimeout(url, ms=15000, maxBytes=null){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort("timeout"), ms);
    try{
      const res = await fetch(url, {signal: ctrl.signal, cache:"no-store"});
      if(!res.ok) throw new Error("HTTP " + res.status);
      if(maxBytes == null) return await res.arrayBuffer();
      // stream and stop after maxBytes
      if(!res.body || !res.body.getReader){
        const buf = await res.arrayBuffer();
        return buf.slice(0, maxBytes);
      }
      const reader = res.body.getReader();
      const chunks = [];
      let got = 0;
      while(true){
        const {value, done} = await reader.read();
        if(done) break;
        if(value){
          let v = value;
          if(got + v.length > maxBytes){
            v = v.slice(0, Math.max(0, maxBytes - got));
          }
          chunks.push(v);
          got += v.length;
          if(got >= maxBytes) break;
        }
      }
      const out = new Uint8Array(got);
      let off = 0;
      for(const c of chunks){ out.set(c, off); off += c.length; }
      return out.buffer;
    } finally {
      clearTimeout(t);
    }
  }

  async function aqaiEnsureTf(){
    if(AQAI.readyTf && window.tf) { AQAI.tf = window.tf; return true; }
    // load tfjs pinned from jsDelivr
    await new Promise((resolve, reject)=>{
      if(window.tf){ resolve(); return; }
      const s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js";
      s.onload = resolve;
      s.onerror = ()=>reject(new Error("Failed to load TF.js"));
      document.head.appendChild(s);
    });
    AQAI.tf = window.tf;
    AQAI.readyTf = !!AQAI.tf;
    return AQAI.readyTf;
  }

  async function aqaiSetBackend(kind){
    await aqaiEnsureTf();
    const tf = AQAI.tf;
    try{
      if(kind==="webgl") await tf.setBackend("webgl");
      if(kind==="cpu") await tf.setBackend("cpu");
      await tf.ready();
      aqaiLog("TF backend: " + tf.getBackend());
    }catch(e){
      aqaiLog("TF backend set failed: " + (e?.message||e));
    }
  }

  function aqaiSelectedUrls(){
    const items = [];
    if($("aqaiCkWP")?.checked) items.push({name:"War and Peace", url: $("aqaiLinkWP")?.href});
    if($("aqaiCkMD")?.checked) items.push({name:"Moby-Dick", url: $("aqaiLinkMD")?.href});
    if($("aqaiCkCP")?.checked) items.push({name:"Crime and Punishment", url: $("aqaiLinkCP")?.href});
    if($("aqaiCkPP")?.checked) items.push({name:"Pride and Prejudice", url: $("aqaiLinkPP")?.href});
    if($("aqaiCkFR")?.checked) items.push({name:"Frankenstein", url: $("aqaiLinkFR")?.href});
    return items.filter(x=>x.url);
  }

  async function aqaiVerifyLinks(){
    AQAI.lastReport = "";
    aqaiDiagLine("AQAI check @ " + new Date().toLocaleString());
    const urls = aqaiSelectedUrls();
    aqaiDiagLine("Corpus links selected: " + urls.length);
    for(const it of urls){
      try{
        const res = await aqaiFetchWithTimeout(it.url, 12000, 2048);
        aqaiDiagLine("LINK OK: " + it.name + " (" + it.url + ") bytes~" + (res.byteLength||0));
      }catch(e){
        aqaiDiagLine("LINK FAIL: " + it.name + " (" + it.url + ") => " + (e?.message||e));
      }
    }
  }

  async function aqaiDownloadCorpus(){
    const urls = aqaiSelectedUrls();
    const maxMB = Math.max(1, Number($("aqaiMaxMB")?.value||25));
    const totMB = Math.max(1, Number($("aqaiTotalMB")?.value||80));
    const maxBytesPer = Math.floor(maxMB * 1024 * 1024);
    const maxTotal = Math.floor(totMB * 1024 * 1024);

    aqaiPill("downloading");
    aqaiLog("Downloading corpus (" + urls.length + " sources), cap " + totMB + "MB total, " + maxMB + "MB/book …");
    const parts = [];
    let total = 0;
    for(const it of urls){
      if(total >= maxTotal) break;
      const room = maxTotal - total;
      const take = Math.min(room, maxBytesPer);
      try{
        const buf = await aqaiFetchWithTimeout(it.url, 30000, take);
        const u8 = new Uint8Array(buf);
        parts.push(u8);
        total += u8.length;
        aqaiLog("  + " + it.name + ": " + u8.length + " bytes");
        aqaiBytesUpdate();
      }catch(e){
        aqaiLog("  ! Failed " + it.name + ": " + (e?.message||e));
      }
    }
    const out = new Uint8Array(total);
    let off=0; for(const p of parts){ out.set(p, off); off += p.length; }
    AQAI.corpusBytes = out;
    // also install a ring buffer so later training can sample efficiently
    const mb = Number($("aqaiTotalMB")?.value || 80);
    aqaiSetRingCapacity(Math.floor(mb*1024*1024));
    aqaiRingAppend(out);
    aqaiBytesUpdate();
    // decode to text (lossy for non-utf8 bytes; Gutenberg is utf8)
    try{
      AQAI.corpusText = new TextDecoder("utf-8", {fatal:false}).decode(out);
    }catch(e){
      AQAI.corpusText = "";
    }
    aqaiLog("Corpus ready: " + total + " bytes");
    aqaiPill("corpus ready");
  }

  // Byte tokenizer (UTF-8 bytes)
  function aqaiEncode(str){
    return new TextEncoder().encode(String(str||""));
  }
  function aqaiDecode(bytes){
    return new TextDecoder("utf-8", {fatal:false}).decode(bytes);
  }

  function aqaiDecodeDisplay(bytes){
    const mode = ($("aqaiDecodeMode")?.value || "escaped");
    const u8 = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
    if(mode==="hex"){
      let s=[]; for(let i=0;i<u8.length;i++){ s.push(u8[i].toString(16).padStart(2,"0")); }
      return s.join(" ");
    }
    if(mode==="latin1"){
      // chunked to avoid stack limits
      let out=""; const CH=8192;
      for(let i=0;i<u8.length;i+=CH){
        const sub=u8.subarray(i, i+CH);
        out += String.fromCharCode.apply(null, Array.from(sub));
      }
      return out;
    }
    if(mode==="utf8"){
      return aqaiDecode(u8);
    }
    // escaped (default): printable ASCII, escape the rest
    let out=""; 
    for(let i=0;i<u8.length;i++){
      const b=u8[i];
      if(b===10) out+="\n";
      else if(b===13) out+="\r";
      else if(b===9) out+="\t";
      else if(b>=32 && b<=126) out+=String.fromCharCode(b);
      else out+="\\x"+b.toString(16).padStart(2,"0");
    }
    return out;
  }

  function aqaiEnsureAsciiMask(tf, vocab){
    if(AQAI.asciiMask && AQAI.asciiMask.shape && AQAI.asciiMask.shape[0]===vocab) return;
    if(AQAI.asciiMask){ try{ AQAI.asciiMask.dispose(); }catch{} }
    const mask = new Float32Array(vocab);
    for(let i=0;i<vocab;i++){
      const b=i & 255;
      const ok = (b===9 || b===10 || b===13 || (b>=32 && b<=126));
      mask[i] = ok ? 1.0 : 0.0;
    }
    AQAI.asciiMask = tf.tensor1d(mask, "float32");
  }

function aqaiBuildRopeCache(tf, seqLen, headDim){
    // precompute sin/cos for RoPE on even/odd pairs
    const half = Math.floor(headDim/2);
    const invFreq = [];
    for(let i=0;i<half;i++){
      invFreq.push(1 / Math.pow(10000, (2*i)/headDim));
    }
    const inv = tf.tensor1d(invFreq, "float32"); // [half]
    const pos = tf.range(0, seqLen, 1, "float32").expandDims(1); // [seq,1]
    const ang = pos.mul(inv.expandDims(0)); // [seq,half]
    const sin = tf.sin(ang).reshape([1,1,seqLen,half]);
    const cos = tf.cos(ang).reshape([1,1,seqLen,half]);
    return {sin, cos, invFreq: inv};
  }

  function aqaiApplyRoPE(tf, x, rope){
    // x: [B,H,T,D] where D even ideally. Apply rotation on pairs in last dim.
    const B = x.shape[0], H = x.shape[1], T = x.shape[2], D = x.shape[3];
    const half = Math.floor(D/2);
    const x1 = x.slice([0,0,0,0],[B,H,T,half]);        // even indices packed
    const x2 = x.slice([0,0,0,half],[B,H,T,half]);     // odd packed
    // Rotate: (x1*cos - x2*sin, x1*sin + x2*cos)
    const xr1 = x1.mul(rope.cos).sub(x2.mul(rope.sin));
    const xr2 = x1.mul(rope.sin).add(x2.mul(rope.cos));
    return tf.concat([xr1, xr2], 3);
  }

  function aqaiCausalMask(tf, T){
    // [1,1,T,T] with 0 for allowed, -1e9 for blocked
    const ones = tf.ones([T,T], "float32");
    const band = tf.linalg.bandPart(ones, -1, 0); // lower triangular incl diag
    const mask = ones.sub(band).mul(tf.scalar(-1e9));
    return mask.reshape([1,1,T,T]);
  }

  function aqaiLayerNorm(tf, x, gamma, beta, eps=1e-5){
    const mean = tf.mean(x, -1, true);
    const varr = tf.mean(tf.square(x.sub(mean)), -1, true);
    const norm = x.sub(mean).div(tf.sqrt(varr.add(tf.scalar(eps))));
    return norm.mul(gamma).add(beta);
  }

  function aqaiGELU(tf, x){
    // exact GELU via erf: 0.5*x*(1+erf(x/sqrt(2)))
    const invSqrt2 = 1/Math.sqrt(2);
    return x.mul(0.5).mul(tf.add(tf.scalar(1), tf.erf(x.mul(invSqrt2))));
  }

  
  // ===== Hugging Face Parquet loader (AQAI) =====
  AQAI.hp = null;
  AQAI.hf = { files: [], lastDataset: "", stop: false };

  function aqaiHfPill(text){
    if($("aqaiHfPill")) $("aqaiHfPill").textContent = text;
  }
  function aqaiHfStatus(text){
    if($("aqaiHfStatus")) $("aqaiHfStatus").textContent = String(text||"—");
  }

  async function aqaiEnsureHyparquet(){
    if(AQAI.hp) return AQAI.hp;
    aqaiHfStatus("Loading hyparquet…");
    const mod = await import("https://cdn.jsdelivr.net/npm/hyparquet@1.23.3/src/hyparquet.min.js");
    AQAI.hp = mod;
    aqaiHfStatus("hyparquet ready.");
    return mod;
  }

  function aqaiHfFillSelect(sel, values, keep="*"){
    if(!sel) return;
    const cur = sel.value;
    sel.innerHTML = "";
    const optAll = document.createElement("option");
    optAll.value = "*"; optAll.textContent = "all";
    sel.appendChild(optAll);
    for(const v of values){
      const o = document.createElement("option");
      o.value = v; o.textContent = v;
      sel.appendChild(o);
    }
    // restore
    if(values.includes(cur)) sel.value = cur;
    else if(keep && (keep==="*" || values.includes(keep))) sel.value = keep;
    else sel.value = sel.querySelector("option")?.value || "*";
  }

  function aqaiHfRenderFiles(){
    const box = $("aqaiHfFiles");
    if(!box) return;
    const files = AQAI.hf.files || [];
    const cfg = $("aqaiHfConfig")?.value || "*";
    const split = $("aqaiHfSplit")?.value || "train";
    const filtered = files.filter(f => (cfg==="*" || f.config===cfg) && (split==="*" || f.split===split));
    let html = "";
    html += `<div style="margin-bottom:6px"><span class="mono">files:</span> ${files.length} &nbsp; <span class="mono">filtered:</span> ${filtered.length}</div>`;
    html += `<div class="small" style="opacity:.85;margin-bottom:6px">Tip: tick some shards, or leave all unticked and the streamer will use the current filters.</div>`;
    const show = filtered.slice(0, 200); // avoid DOM explosion
    html += `<div style="display:flex;flex-direction:column;gap:6px">`;
    show.forEach((f, i) => {
      const id = "hfcb_" + i;
      const sizeMB = (Number(f.size||0)/1024/1024).toFixed(1);
      html += `<label style="display:flex;gap:8px;align-items:center">
        <input type="checkbox" id="${id}" data-hf-url="${f.url}" data-hf-size="${f.size||0}" data-hf-config="${f.config||''}" data-hf-split="${f.split||''}">
        <span class="mono" style="min-width:88px">${sizeMB}MB</span>
        <span>${f.config||""}</span>
        <span class="mono" style="opacity:.75">/</span>
        <span>${f.split||""}</span>
        <span class="mono" style="opacity:.75">/</span>
        <span class="mono">${f.filename||""}</span>
      </label>`;
    });
    if(filtered.length > show.length){
      html += `<div class="small" style="opacity:.75;margin-top:6px">Showing first ${show.length} filtered shards (there are ${filtered.length}). Narrow filters or raise Buffer MB.</div>`;
    }
    html += `</div>`;
    box.innerHTML = html;
  }

  async function aqaiHfList(){
    try{
      AQAI.hf.stop = false;
      aqaiHfPill("listing");
      const ds = ($("aqaiHfDataset")?.value||"").trim();
      if(!ds){ aqaiHfStatus("Dataset is empty."); aqaiHfPill("idle"); return; }
      AQAI.hf.lastDataset = ds;
      const api = "https://datasets-server.huggingface.co/parquet?dataset=" + encodeURIComponent(ds);
      aqaiHfStatus("GET " + api);
      const res = await fetch(api, {method:"GET"});
      if(!res.ok) throw new Error("HF /parquet HTTP " + res.status);
      const j = await res.json();
      const files = (j && j.parquet_files) ? j.parquet_files : [];
      if(!files.length){
        aqaiHfStatus("No parquet_files returned. Dataset may be private / not converted / not found.");
      }
      // sort by (config, split, filename)
      files.sort((a,b)=> String(a.config).localeCompare(String(b.config)) || String(a.split).localeCompare(String(b.split)) || String(a.filename).localeCompare(String(b.filename)));
      AQAI.hf.files = files;

      // populate config dropdown
      const cfgs = Array.from(new Set(files.map(f=>f.config).filter(Boolean)));
      aqaiHfFillSelect($("aqaiHfConfig"), cfgs, cfgs[0]||"*");
      // ensure split select has correct default
      if($("aqaiHfSplit") && !$("aqaiHfSplit").value) $("aqaiHfSplit").value = "train";

      aqaiHfRenderFiles();
      aqaiHfStatus("Listed " + files.length + " parquet shard(s).");
      aqaiHfPill("ready");
    }catch(e){
      aqaiHfStatus("List failed: " + (e?.message||e));
      aqaiHfPill("error");
    }
  }

  function aqaiHfSelectedFiles(){
    const box = $("aqaiHfFiles");
    const files = AQAI.hf.files || [];
    if(!box || !files.length) return [];
    const checked = Array.from(box.querySelectorAll('input[type="checkbox"][data-hf-url]')).filter(x=>x.checked);
    if(checked.length){
      // Map checked back to file objects by url
      const byUrl = new Map(files.map(f=>[f.url,f]));
      return checked.map(cb => byUrl.get(cb.dataset.hfUrl)).filter(Boolean);
    }
    // else use filters
    const cfg = $("aqaiHfConfig")?.value || "*";
    const split = $("aqaiHfSplit")?.value || "train";
    return files.filter(f => (cfg==="*" || f.config===cfg) && (split==="*" || f.split===split));
  }

  function aqaiGuessTextColumn(cols){
    if(!cols || !cols.length) return "text";
    const lc = cols.map(c=>String(c).toLowerCase());
    const prefs = ["text","content","document","documents","passage","prompt","completion","response","message","messages","article","body"];
    for(const p of prefs){
      const i = lc.indexOf(p);
      if(i>=0) return cols[i];
    }
    // first string-like column is unknown here; default to first
    return cols[0];
  }

  async function aqaiHfVerify(){
    try{
      aqaiHfPill("verifying");
      const ds = ($("aqaiHfDataset")?.value||"").trim();
      if(ds){
        const api = "https://datasets-server.huggingface.co/parquet?dataset=" + encodeURIComponent(ds);
        const r = await fetch(api, {method:"GET"});
        aqaiDiagLine("HF /parquet: " + r.status + " " + api);
      }
      const sel = aqaiHfSelectedFiles().slice(0, 8);
      if(!sel.length){
        aqaiDiagLine("HF shards: none selected / filtered.");
        aqaiHfStatus("No shards to verify (select some or list shards first).");
        aqaiHfPill("ready");
        return;
      }
      for(const f of sel){
        const u = f.url;
        try{
          const r = await fetch(u, {method:"HEAD"});
          aqaiDiagLine("HF shard HEAD: " + r.status + " " + (f.filename||"") + " (" + (f.split||"") + "/" + (f.config||"") + ")");
        }catch(e){
          aqaiDiagLine("HF shard HEAD failed: " + (e?.message||e) + " :: " + u);
        }
      }
      aqaiHfStatus("Verified " + sel.length + " shard link(s).");
      aqaiHfPill("ready");
    }catch(e){
      aqaiHfStatus("Verify failed: " + (e?.message||e));
      aqaiHfPill("error");
    }
  }

  function aqaiHfStop(){
    AQAI.stop = true;
    AQAI.hf.stop = true;
    aqaiHfStatus("Stop requested.");
    aqaiHfPill("stopping");
  }

  async function aqaiHfStreamToBuffer(autoTrain=false){
    try{
      AQAI.stop = false;
      AQAI.hf.stop = false;
      aqaiHfPill(autoTrain ? "auto" : "stream");
      const hp = await aqaiEnsureHyparquet();
      const { asyncBufferFromUrl, parquetMetadataAsync, parquetSchema, parquetReadObjects } = hp;

      const bufMB = Number($("aqaiHfBufMB")?.value || 128);
      aqaiSetRingCapacity(Math.floor(bufMB * 1024 * 1024));
      const maxRows = Math.max(1, Math.floor(Number($("aqaiHfMaxRows")?.value || 50000)));
      const batchRows = Math.max(32, Math.floor(Number($("aqaiHfBatchRows")?.value || 256)));

      const files = aqaiHfSelectedFiles();
      if(!files.length){
        aqaiHfStatus("No shards to stream. Click 'List shards' first.");
        aqaiHfPill("idle");
        return;
      }

      let rowsDone = 0;
      let shardsDone = 0;

      // Stream shards until we hit maxRows or stop
      for(const f of files){
        if(AQAI.stop || AQAI.hf.stop) break;
        const shardLabel = (f.config||"") + "/" + (f.split||"") + "/" + (f.filename||"");
        aqaiHfStatus("Opening shard " + shardLabel);

        const ab = await asyncBufferFromUrl({ url: f.url, byteLength: Number(f.size||0) || undefined });
        const meta = await parquetMetadataAsync(ab);
        const schema = parquetSchema(meta);
        const cols = schema?.children ? schema.children.map(c=>c.name) : (schema?.columns ? schema.columns.map(c=>c.name) : []);
        let textCol = $("aqaiHfTextCol")?.value || "auto";
        if(textCol === "auto"){
          textCol = aqaiGuessTextColumn(cols);
          // populate dropdown once
          const sel = $("aqaiHfTextCol");
          if(sel && sel.options.length <= 1){
            sel.innerHTML = '<option value="auto">auto</option>' + cols.map(c=>`<option value="${c}">${c}</option>`).join("");
          }
          if(sel) sel.value = textCol;
        }

        const nrows = Number(meta?.num_rows || meta?.numRows || 0) || 0;
        const limit = Math.min(nrows, maxRows - rowsDone);
        let rowStart = 0;

        while(rowStart < limit){
          if(AQAI.stop || AQAI.hf.stop) break;
          const rowEnd = Math.min(limit, rowStart + batchRows);
          aqaiHfStatus(`Reading ${shardLabel} rows ${rowStart}..${rowEnd} (col=${textCol})`);
          const rows = await parquetReadObjects({ file: ab, columns: [textCol], rowStart, rowEnd });
          // rows is array of objects
          for(const obj of rows){
            if(AQAI.stop || AQAI.hf.stop) break;
            let s = obj ? obj[textCol] : "";
            if(typeof s !== "string") s = JSON.stringify(s);
            const u8 = aqaiEncode(s + "\n");
            aqaiRingAppend(u8);
            rowsDone += 1;
            if(rowsDone >= maxRows) break;
          }
          rowStart = rowEnd;
          aqaiBytesUpdate();
          if(AQAI.tf?.nextFrame) await AQAI.tf.nextFrame();
          if(rowsDone >= maxRows) break;
        }

        shardsDone += 1;
        if(rowsDone >= maxRows) break;
        aqaiHfStatus("Shard done: " + shardLabel + " (rows=" + rowsDone + ")");
      }

      aqaiHfStatus(`Streamed ${rowsDone} rows from ${shardsDone} shard(s). Buffer now has ${aqaiCorpusLen()} byte(s).`);
      aqaiHfPill("done");

      if(autoTrain){
        // Ensure TF + model
        if(!AQAI.readyTf) await aqaiEnsureTf();
        if(!AQAI.weights) await aqaiInitModel();
        // If training steps is zero, set a sane default
        if($("aqaiSteps") && Number($("aqaiSteps").value||0) <= 0) $("aqaiSteps").value = 200;
        await aqaiTrain();
      }
    }catch(e){
      aqaiHfStatus("Stream failed: " + (e?.message||e));
      aqaiHfPill("error");
    }
  }

function aqaiInitModel(){
    if(!AQAI.readyTf || !AQAI.tf){ aqaiLog("Load TF.js first."); return; }
    if(!(aqaiCorpusLen() > 1024)){ aqaiLog("Download corpus first."); return; }

    const tf = AQAI.tf;
    // dispose previous
    try{
      if(AQAI.weights){
        for(const k in AQAI.weights){ AQAI.weights[k].dispose?.(); }
      }
      AQAI.cache.ropeSin?.dispose?.(); AQAI.cache.ropeCos?.dispose?.(); AQAI.cache.mask?.dispose?.(); AQAI.cache.modMask?.dispose?.();
    }catch(e){}

    const seqLen = Math.max(16, Number($("aqaiSeq")?.value||96));
    const d = Math.max(32, Number($("aqaiD")?.value||128));
    const H = Math.max(1, Number($("aqaiH")?.value||4));
    const L = Math.max(1, Number($("aqaiL")?.value||3));
    const dff = Math.max(64, Number($("aqaiFF")?.value||256));
    const vocab = AQAI.vocab;
    const headDim = Math.floor(d / H);
    if(headDim < 8){ aqaiLog("d_model/heads too small."); return; }
    if(headDim*H !== d){ aqaiLog("Warning: d_model not divisible by heads; rounding headDim."); }

    AQAI.use.rope = !!$("aqaiUseRoPE")?.checked;
    AQAI.use.me = !!$("aqaiUseME")?.checked;

    aqaiPill("init…");
    aqaiLog("Init model: vocab=256, seq=" + seqLen + ", d=" + d + ", heads=" + H + ", layers=" + L + ", dff=" + dff);

    function v(name, shape, std=0.02){
      const init = tf.randomNormal(shape, 0, std, "float32");
      return tf.variable(init, true, name);
    }
    function z(name, shape){
      return tf.variable(tf.zeros(shape,"float32"), true, name);
    }

    const W = {};
    // token embed + pos embed
    W.tok = v("tok", [vocab, d], 0.02);
    W.pos = v("pos", [seqLen, d], 0.02);

    // per-layer weights
    for(let i=0;i<L;i++){
      W["ln1_g_"+i] = v("ln1g"+i, [1,1,d], 0.02); // gamma
      W["ln1_b_"+i] = z("ln1b"+i, [1,1,d]);
      W["ln2_g_"+i] = v("ln2g"+i, [1,1,d], 0.02);
      W["ln2_b_"+i] = z("ln2b"+i, [1,1,d]);

      W["Wq_"+i] = v("Wq"+i, [d,d], 0.02);
      W["Wk_"+i] = v("Wk"+i, [d,d], 0.02);
      W["Wv_"+i] = v("Wv"+i, [d,d], 0.02);
      W["Wo_"+i] = v("Wo"+i, [d,d], 0.02);

      W["W1_"+i] = v("W1"+i, [d,dff], 0.02);
      W["b1_"+i] = z("b1"+i, [dff]);
      W["W2_"+i] = v("W2"+i, [dff,d], 0.02);
      W["b2_"+i] = z("b2"+i, [d]);
    }

    W.lnF_g = v("lnFg", [1,1,d], 0.02);
    W.lnF_b = z("lnFb", [1,1,d]);
    W.Wout = v("Wout", [d, vocab], 0.02);
    W.bout = z("bout", [vocab]);

    // caches
    AQAI.cache.cfg = {seqLen, d, H, L, dff, headDim, vocab};
    AQAI.cache.mask = aqaiCausalMask(tf, seqLen);
    if(AQAI.use.rope){
      const rc = aqaiBuildRopeCache(tf, seqLen, headDim*2); // we'll rotate 2*half dims; use even split
      AQAI.cache.ropeSin = rc.sin;
      AQAI.cache.ropeCos = rc.cos;
    }

    // modular mask [vocab, p]
    const p = Math.max(2, Math.min(251, Number($("aqaiPrime")?.value||17)));
    const mm = new Float32Array(vocab * p);
    for(let t=0;t<vocab;t++){
      mm[t*p + (t % p)] = 1;
    }
    AQAI.cache.modMask = tf.tensor2d(mm, [vocab, p], "float32");

    AQAI.weights = W;
    const lr = Math.max(1e-4, Number($("aqaiLR")?.value||0.002));
    AQAI.optimizer = tf.train.adam(lr, 0.9, 0.999, 1e-8);
    AQAI.stop = false;
    aqaiPill("ready");
  }

  function aqaiForward(tf, xTok){
    // xTok: int32 [B,T]
    const W = AQAI.weights;
    const cfg = AQAI.cache.cfg;
    const {seqLen:T, d, H, L, headDim, vocab} = cfg;
    const B = xTok.shape[0];

    // embeddings
    let x = tf.gather(W.tok, xTok); // [B,T,d]
    const pos = W.pos.expandDims(0); // [1,T,d]
    x = x.add(pos);

    const mask = AQAI.cache.mask;

    const rope = (AQAI.use.rope && AQAI.cache.ropeSin && AQAI.cache.ropeCos)
      ? {sin: AQAI.cache.ropeSin, cos: AQAI.cache.ropeCos}
      : null;

    for(let i=0;i<L;i++){
      // LN1
      const y = aqaiLayerNorm(tf, x, W["ln1_g_"+i], W["ln1_b_"+i]);
      // QKV
      const q = tf.matMul(y, W["Wq_"+i]).reshape([B,T,H,headDim]).transpose([0,2,1,3]); // [B,H,T,dh]
      const k = tf.matMul(y, W["Wk_"+i]).reshape([B,T,H,headDim]).transpose([0,2,1,3]);
      const v = tf.matMul(y, W["Wv_"+i]).reshape([B,T,H,headDim]).transpose([0,2,1,3]);

      let q2=q, k2=k;
      if(rope && headDim>=2){
        // rotate first 2*floor(dh/2) dims by splitting into halves
        const dh2 = Math.floor(headDim/2)*2;
        if(dh2>=2){
          const qh = q.slice([0,0,0,0],[B,H,T,dh2]);
          const qt = q.slice([0,0,0,dh2],[B,H,T,headDim-dh2]);
          const kh = k.slice([0,0,0,0],[B,H,T,dh2]);
          const kt = k.slice([0,0,0,dh2],[B,H,T,headDim-dh2]);
          // reshape head dims into [.., dh2] and split into two halves
          const qh2 = qh.reshape([B,H,T,dh2]);
          const kh2 = kh.reshape([B,H,T,dh2]);
          // Apply RoPE using half=dh2/2 packed (x1,x2)
          const half = dh2/2;
          const q1 = qh2.slice([0,0,0,0],[B,H,T,half]);
          const q2p = qh2.slice([0,0,0,half],[B,H,T,half]);
          const k1 = kh2.slice([0,0,0,0],[B,H,T,half]);
          const k2p = kh2.slice([0,0,0,half],[B,H,T,half]);
          const sin = rope.sin.slice([0,0,0,0],[1,1,T,half]);
          const cos = rope.cos.slice([0,0,0,0],[1,1,T,half]);
          const rq1 = q1.mul(cos).sub(q2p.mul(sin));
          const rq2 = q1.mul(sin).add(q2p.mul(cos));
          const rk1 = k1.mul(cos).sub(k2p.mul(sin));
          const rk2 = k1.mul(sin).add(k2p.mul(cos));
          const qhR = tf.concat([rq1,rq2],3);
          const khR = tf.concat([rk1,rk2],3);
          q2 = tf.concat([qhR, qt], 3);
          k2 = tf.concat([khR, kt], 3);
        }
      }

      const scale = 1/Math.sqrt(headDim);
      const att = tf.matMul(q2, k2, false, true).mul(scale).add(mask); // [B,H,T,T]
      const w = tf.softmax(att, -1);
      const o = tf.matMul(w, v).transpose([0,2,1,3]).reshape([B,T,H*headDim]); // [B,T,d']
      const o2 = tf.matMul(o, W["Wo_"+i]); // [B,T,d]
      x = x.add(o2);

      // LN2
      const z = aqaiLayerNorm(tf, x, W["ln2_g_"+i], W["ln2_b_"+i]);
      const ff = aqaiGELU(tf, tf.matMul(z, W["W1_"+i]).add(W["b1_"+i]));
      const ff2 = tf.matMul(ff, W["W2_"+i]).add(W["b2_"+i]);
      x = x.add(ff2);
    }

    x = aqaiLayerNorm(tf, x, W.lnF_g, W.lnF_b);
    const logits = tf.matMul(x, W.Wout).add(W.bout); // [B,T,vocab]
    return logits;
  }

  function aqaiModularEntropy(tf, probs, p){
    // probs: [B,T,V], take mean over B,T -> [V], group by mod p -> [p]
    const meanP = tf.mean(probs, [0,1]); // [V]
    const mm = AQAI.cache.modMask; // [V,p]
    let g = tf.matMul(meanP.reshape([1, meanP.shape[0]]), mm).reshape([p]); // [p]
    const s = tf.sum(g).add(tf.scalar(1e-12));
    g = g.div(s);
    const ent = tf.neg(tf.sum(g.mul(tf.log(g.add(tf.scalar(1e-12)))))); // scalar
    return ent;
  }

  function aqaiSampleBatch(seqLen, batch){
    const N = aqaiCorpusLen();
    const xs = new Int32Array(batch*seqLen);
    const ys = new Int32Array(batch*seqLen);
    // random offsets
    for(let b=0;b<batch;b++){
      const start = Math.floor(Math.random() * Math.max(1, N - (seqLen+2)));
      for(let t=0;t<seqLen;t++){
        xs[b*seqLen+t] = aqaiCorpusGet(start+t) & 255;
        ys[b*seqLen+t] = aqaiCorpusGet(start+t+1) & 255;
      }
    }
    return {xs, ys};
  }

  async function aqaiTrain(){
    if(!AQAI.readyTf || !AQAI.tf || !AQAI.weights){ aqaiLog("Init model first."); return; }
    const tf = AQAI.tf;
    const cfg = AQAI.cache.cfg;
    const seqLen = cfg.seqLen;
    const batch = Math.max(1, Number($("aqaiBatch")?.value||16));
    const steps = Math.max(1, Number($("aqaiSteps")?.value||2000));
    const p = Math.max(2, Math.min(251, Number($("aqaiPrime")?.value||17)));
    const lam = Math.max(0, Number($("aqaiLam")?.value||0.0));
    const meMode = $("aqaiMeMode")?.value || "max";
    AQAI.stop = false;

    aqaiPill("training");
    aqaiLog("Train: steps=" + steps + ", batch=" + batch + ", seq=" + seqLen + ", λ=" + lam + " p=" + p);

    const varList = Object.values(AQAI.weights);

    for(let step=1; step<=steps; step++){
      if(AQAI.stop) break;
      const {xs, ys} = aqaiSampleBatch(seqLen, batch);
      const x = tf.tensor2d(xs, [batch, seqLen], "int32");
      const y = tf.tensor2d(ys, [batch, seqLen], "int32");

      const {value: loss, grads} = tf.variableGrads(()=>{
        const logits = aqaiForward(tf, x); // [B,T,V]
        const xent = tf.losses.sparseCategoricalCrossentropy(y, logits, {fromLogits:true}).mean();
        let total = xent;
        if(AQAI.use.me && lam>0){
          const probs = tf.softmax(logits, -1);
          const ent = aqaiModularEntropy(tf, probs, p);
          const reg = (meMode==="max") ? ent.neg() : ent;
          total = total.add(reg.mul(tf.scalar(lam)));
        }
        return total;
      }, varList);

      AQAI.optimizer.applyGradients(grads);

      // cleanup
      x.dispose(); y.dispose();
      for(const k in grads){ grads[k].dispose(); }

      if(step % 10 === 0 || step===1){
        const lv = (await loss.data())[0];
        aqaiPill("loss " + lv.toFixed(4));
        if(step % 50 === 0 || step===1) aqaiLog("step " + step + "/" + steps + " loss=" + lv.toFixed(6));
      }
      loss.dispose();
      await tf.nextFrame(); // yield to UI
    }
    aqaiPill(AQAI.stop ? "stopped" : "trained");
    aqaiLog("Training done.");
  }

  async function aqaiEval(){
    if(!AQAI.readyTf || !AQAI.tf || !AQAI.weights){ aqaiLog("Init model first."); return; }
    const tf = AQAI.tf;
    const cfg = AQAI.cache.cfg;
    const seqLen = cfg.seqLen;
    const batch = Math.max(1, Number($("aqaiBatch")?.value||16));
    const iters = 20;

    aqaiPill("eval");
    let acc = 0;
    for(let i=0;i<iters;i++){
      const {xs, ys} = aqaiSampleBatch(seqLen, batch);
      const x = tf.tensor2d(xs, [batch, seqLen], "int32");
      const y = tf.tensor2d(ys, [batch, seqLen], "int32");
      const logits = aqaiForward(tf, x);
      const xent = tf.losses.sparseCategoricalCrossentropy(y, logits, {fromLogits:true}).mean();
      acc += (await xent.data())[0];
      x.dispose(); y.dispose(); logits.dispose(); xent.dispose();
      await tf.nextFrame();
    }
    const loss = acc/iters;
    const ppl = Math.exp(Math.min(20, loss));
    aqaiLog("Eval: loss=" + loss.toFixed(6) + "  ppl≈" + ppl.toFixed(2));
    aqaiPill("eval ok");
  }

  function aqaiStop(){ AQAI.stop = true; aqaiPill("stopping"); aqaiLog("Stop requested."); }

  async function aqaiGenerate(){
    if(!AQAI.readyTf || !AQAI.tf || !AQAI.weights){ aqaiLog("Init model first."); return; }
    const tf = AQAI.tf;
    const cfg = AQAI.cache.cfg;
    const T = cfg.seqLen;

    const temp = Math.max(0.05, Number($("aqaiTemp")?.value||0.7));
    const topk = Math.max(0, Number($("aqaiTopk")?.value||20));
    const maxNew = Math.max(1, Number($("aqaiMaxNew")?.value||160));

    const prompt = String($("aqaiPrompt")?.value||"");
    let ctx = Array.from(aqaiEncode(prompt)).map(b=>b&255);

    const outBytes = [];
    aqaiPill("gen");
    for(let n=0;n<maxNew;n++){
      const slice = ctx.slice(Math.max(0, ctx.length - T), ctx.length);
      while(slice.length < T) slice.unshift(10); // pad with newline
      const x = tf.tensor2d(slice, [1,T], "int32");
      const logits = aqaiForward(tf, x); // [1,T,V]
      const last = logits.slice([0,T-1,0],[1,1,cfg.vocab]).reshape([cfg.vocab]);
      let probs = tf.softmax(last.div(tf.scalar(temp)));
      const asciiOnly = !!($("aqaiAsciiOnly")?.checked);
      let probsUse = probs, masked=null;
      if(asciiOnly){
        aqaiEnsureAsciiMask(tf, cfg.vocab);
        masked = probs.mul(AQAI.asciiMask);
        const s1 = masked.sum();
        const s2 = s1.add(1e-8);
        probsUse = masked.div(s2);
        s1.dispose(); s2.dispose();
      }
      if(topk > 0 && topk < cfg.vocab){

        const {values, indices} = tf.topk(probsUse, topk);
        const v = values.div(tf.sum(values));
        // sample in topk space
        const samp = tf.multinomial(tf.log(v).reshape([1,topk]), 1, null, true).reshape([]);
        const kidx = (await samp.data())[0];
        const tok = (await indices.data())[kidx];
        outBytes.push(tok & 255);
        ctx.push(tok & 255);
        values.dispose(); indices.dispose(); v.dispose(); samp.dispose();
      }else{
        const samp = tf.multinomial(tf.log(probsUse).reshape([1,cfg.vocab]), 1, null, true).reshape([]);
        const tok = (await samp.data())[0];
        outBytes.push(tok & 255);
        ctx.push(tok & 255);
        samp.dispose();
      }
      if(masked){ try{ probsUse.dispose(); }catch{} try{ masked.dispose(); }catch{} }
      x.dispose(); logits.dispose(); last.dispose(); probs.dispose();
      if(n % 8 === 0){
        if($("aqaiGenOut")) $("aqaiGenOut").textContent = aqaiDecodeDisplay(new Uint8Array(outBytes));
        await tf.nextFrame();
      }
    }
    if($("aqaiGenOut")) $("aqaiGenOut").textContent = aqaiDecodeDisplay(new Uint8Array(outBytes));
    aqaiPill("gen ok");
  }

  function aqaiClearGen(){
    if($("aqaiPrompt")) $("aqaiPrompt").value = "";
    if($("aqaiGenOut")) $("aqaiGenOut").textContent = "";
  }

  function aqaiExport(){
    if(!AQAI.weights || !AQAI.cache.cfg){ aqaiLog("Nothing to export."); return; }
    const tf = AQAI.tf;
    const payload = { cfg: AQAI.cache.cfg, prime: Number($("aqaiPrime")?.value||17), weights: {} };
    // pull weights
    const keys = Object.keys(AQAI.weights);
    const promises = keys.map(async k=>{
      const t = AQAI.weights[k];
      const arr = await t.array();
      payload.weights[k] = {shape: t.shape, data: arr};
    });
    Promise.all(promises).then(()=>{
      const blob = new Blob([JSON.stringify(payload)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "aqai_llm_checkpoint.json";
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
      aqaiLog("Exported checkpoint.");
    });
  }

  async function aqaiImportFile(file){
    if(!file){ return; }
    await aqaiEnsureTf();
    const tf = AQAI.tf;
    const txt = await file.text();
    let obj = null;
    try{ obj = JSON.parse(txt); }catch(e){ aqaiLog("Import JSON parse error."); return; }
    if(!obj || !obj.cfg || !obj.weights){ aqaiLog("Import file missing fields."); return; }

    // Set UI cfg then init and assign
    $("aqaiSeq").value = obj.cfg.seqLen;
    $("aqaiD").value = obj.cfg.d;
    $("aqaiH").value = obj.cfg.H;
    $("aqaiL").value = obj.cfg.L;
    $("aqaiFF").value = obj.cfg.dff;
    $("aqaiPrime").value = obj.prime || $("aqaiPrime").value;

    aqaiInitModel();
    // assign weights
    for(const k in obj.weights){
      if(!AQAI.weights[k]) continue;
      const t = AQAI.weights[k];
      const arr = obj.weights[k].data;
      const flat = tf.tensor(arr, t.shape, "float32");
      t.assign(flat);
      flat.dispose();
    }
    aqaiLog("Imported checkpoint.");
  }

  function aqaiUseInChat(){
    if(!$("llmBackend")) return;
    $("llmBackend").value = "aqai";
    aqaiLog("Set chat backend = AQAI. Now LLM chat will call your local trained model.");
  }

  async function aqaiChatReply(userText){
    // minimal: generate continuation from prompt = system + chat context + user message
    const sys = String($("llmSystem")?.value||"");
    const prompt = (sys?("System: "+sys+"\n"):"") + "User: " + userText + "\nAssistant:";
    if($("aqaiPrompt")) $("aqaiPrompt").value = prompt;
    await aqaiGenerate();
    const gen = $("aqaiGenOut")?.textContent || "";
    // Return first ~400 chars
    return gen.slice(0, 600).trim() || "(no output)";
  }

  async function aqaiRunChecks(fetchLinks=true){
    AQAI.lastReport = "";
    aqaiDiagLine("AQAI diagnostics @ " + new Date().toLocaleString());
    // must buttons
    const must = ["aqaiLoadTf","aqaiVerifyLinks","aqaiDownload","aqaiInit","aqaiTrain","aqaiStop","aqaiEval","aqaiUse","aqaiExport","aqaiDiag","aqaiGenerate","aqaiClearGen"];
    const missing = must.filter(id=>!$(id));
    if(missing.length) aqaiDiagLine("Missing elements: " + missing.join(", "));
    else aqaiDiagLine("All AQAI UI elements present.");
    // check handlers (onclick)
    const unwired = must.filter(id=> $(id) && typeof $(id).onclick !== "function");
    if(unwired.length) aqaiDiagLine("Unwired buttons: " + unwired.join(", "));
    else aqaiDiagLine("AQAI buttons appear wired.");
    // TF status
    aqaiDiagLine("TF.js present: " + (!!window.tf));
    if(fetchLinks){
      await aqaiVerifyLinks();
    }
  }

  function aqaiCopyReport(){
    try{
      navigator.clipboard?.writeText(AQAI.lastReport || $("aqaiDiagOut")?.textContent || "");
      aqaiLog("Copied AQAI report.");
    }catch(e){
      aqaiLog("Copy failed.");
    }
  }

  // Expose hook for chat backend
  window.__aqaiChatReply = aqaiChatReply;




  if($("llmInput")) $("llmInput").addEventListener("keydown", (e)=>{
    if(e.key==="Enter" && !e.shiftKey){
      e.preventDefault();
      llmSendLocal();
    }
  });

  // initialize defaults
  if($("eqvModes") && !$("eqvModes").value.trim()) eqvApplyPreset("stable");


  window.addEventListener("resize", ()=>{ if(mono.running) monoResize(); });

  updateSyncPill();


  // -------------------- AQC masks + overlay (pen-and-lens) --------------------
  const AQC = {
    mode: "none",        // none | cup | phase | foam | layout
    layoutId: "cup_basic",
    _saved: null,
    sizeMm: 20,
    opacity: 0.70,
    qcMode: false,
    qcActive: false,
    computeBusy: false,
    archMode: false,
    brushPx: 8,
    eraser: false,
    lastReport: ""
  };

  function setQuantumComputingActive(v){
    AQC.qcActive = !!v;
    const s = AQC.qcActive ? "active" : "idle";
    if($("ovQcState")) $("ovQcState").textContent = s;
    if($("aqcQcState")) $("aqcQcState").textContent = s;
    if(AQC.qcActive){
      // hard-disable overlays during compute/training (but restore after)
      if(!AQC._saved) AQC._saved = { mode:AQC.mode, layoutId:AQC.layoutId, archMode:AQC.archMode, opacity:AQC.opacity, sizeMm:AQC.sizeMm, qcMode:AQC.qcMode };
      AQC.mode = "none";
      AQC.qcMode = true;
      aqcApplyOverlayState();
    }
    else{
      // leaving compute/training: restore previous overlay state
      if(AQC._saved){
        AQC.mode = AQC._saved.mode;
        AQC.layoutId = AQC._saved.layoutId;
        AQC.opacity = AQC._saved.opacity;
        AQC.sizeMm = AQC._saved.sizeMm;
        AQC.qcMode = AQC._saved.qcMode;
        aqcSetArchMode(!!AQC._saved.archMode);
        AQC._saved = null;
      }
      aqcApplyOverlayState();
    }
  }

  function aqcClamp(x,a,b){ x=Number(x); if(!isFinite(x)) return a; return Math.max(a, Math.min(b, x)); }
  function aqcHash32(n){ n|=0; n = (n ^ 61) ^ (n >>> 16); n = n + (n << 3); n = n ^ (n >>> 4); n = Math.imul(n, 0x27d4eb2d); n = n ^ (n >>> 15); return n|0; }
  function aqcRand(seed){
    let s = aqcHash32(seed);
    return function(){
      // xorshift32
      s ^= (s << 13); s |= 0;
      s ^= (s >>> 17);
      s ^= (s << 5); s |= 0;
      return ((s >>> 0) / 4294967296);
    };
  }

  // Smoothstep polynomial: s(u)=1-3u^2+2u^3 (C^2 blend)
  function aqc_s(u){ return 1 - 3*u*u + 2*u*u*u; }
  // Cup ceiling: h(r)=1/y0 + (1-1/y0) s((r/R)^k), r in [0,R]
  function aqc_h(r, R, k, y0){
    const u = Math.pow(aqcClamp(r / Math.max(1e-9, R), 0, 1), k);
    return (1/y0) + (1 - 1/y0) * aqc_s(u);
  }

  function aqcMmToPx(mm, dpi){ return (mm / 25.4) * dpi; }

  function aqcCanvasSizeForPrint(c, wmm, hmm, dpi){
    const wpx = Math.max(32, Math.round(aqcMmToPx(wmm, dpi)));
    const hpx = Math.max(32, Math.round(aqcMmToPx(hmm, dpi)));
    c.width = wpx; c.height = hpx;
  }

  function aqcGetDesignOpts(){
    return {
      template: $("aqcTemplate")?.value || "cup",
      wmm: aqcClamp($("aqcWmm")?.value || 30, 10, 60),
      hmm: aqcClamp($("aqcHmm")?.value || 20, 10, 60),
      dpi: aqcClamp($("aqcDpi")?.value || 600, 150, 2400),
      y0: aqcClamp($("aqcY0")?.value || 2.0, 1.1, 10),
      R: aqcClamp($("aqcR")?.value || 10, 2, 25),
      k: aqcClamp($("aqcK")?.value || 3, 2, 10),
      slitD: aqcClamp($("aqcD")?.value || 2.0, 0.5, 10),
      slitW: aqcClamp($("aqcSlitW")?.value || 0.2, 0.05, 2),
      seed: Math.floor(aqcClamp($("aqcSeed")?.value || 2025, 0, 999999))
    };
  }

  function aqcAsciiFor(template){
    if(template==="phase"){
      return [
        "+----------+  \u2190 15mm",
        "| |     | |  \u2190 Gaussian slits \u03d5\u2080,\u03d5\u2081 (shade tails)",
        "| |     | |  ",
        "||||||| |||||||             \u2190 Central dark line (~5mm wide, full height)",
        "|         |  ",
        "|  [Horizon shade]         |",
        "+----------+"
      ].join("\n");
    }
    if(template==="foam"){
      return [
        "Bottom horizon: ~~~~~\u2248\u2248\u2248~~ (\u03b5=0.1 wiggles, \u2113c=0.3R scribbles)",
        "Ceiling same as Cup, plus nested inset cup (scale \u03b1)."
      ].join("\n");
    }
    return [
      "+--------------------------+  \u2190 20mm height (\u03b6 direction)",
      "|     Ceiling curve        |",
      "|   /\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\\   |  h(r): smooth drop from y0=2 to 1/y0",
      "|  /                      |  ",
      "| /                        |  ",
      "|/  [Side wall r=Ro=1.5R]  |",
      "|~~~~~~~~~~~~~~~~~~~~~~~~~~|  \u2190 Horizon: dense shade (bottom ~20%)",
      "|     [Axis \u03c1=0]           |",
      "+--------------------------+  \u2190 30mm width (\u03c1 direction)",
      "Slits (top): |==| (\u03d5\u2080 left, \u03d5\u2081 right, d=2mm, w=0.2mm)"
    ].join("\n");
  }

  function aqcDrawDither(ctx, x, y, w, h, seed, density){
    // Simple deterministic hatch/dither (phone-friendly).
    const rnd = aqcRand(seed);
    const lines = Math.max(40, Math.floor((w + h) * density));
    ctx.save();
    ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip();
    ctx.globalAlpha = 0.9;
    ctx.lineWidth = 1;
    for(let i=0;i<lines;i++){
      const t = rnd();
      const x0 = x + t*w;
      const y0 = y + (rnd()*h);
      const ang = (rnd()*Math.PI*0.45) + Math.PI*0.05;
      const L = Math.max(w,h)*1.2;
      ctx.beginPath();
      ctx.moveTo(x0 - Math.cos(ang)*L, y0 - Math.sin(ang)*L);
      ctx.lineTo(x0 + Math.cos(ang)*L, y0 + Math.sin(ang)*L);
      ctx.stroke();
    }
    ctx.restore();
  }

  function aqcRenderDesign(canvas, opts){
    if(!canvas) return;
    aqcCanvasSizeForPrint(canvas, opts.wmm, opts.hmm, opts.dpi);
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Work in mm coordinates mapped to pixels.
    const sx = canvas.width / opts.wmm;
    const sy = canvas.height / opts.hmm;

    const mm2px = (mm)=> mm * sx; // assume uniform scale based on width; close enough for print
    const px2mm = (px)=> px / sx;

    // background
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // border
    ctx.strokeStyle = "black";
    ctx.lineWidth = Math.max(1, Math.round(opts.dpi/600));
    ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, canvas.width-ctx.lineWidth, canvas.height-ctx.lineWidth);

    ctx.fillStyle = "black";
    ctx.strokeStyle = "black";

    const W = opts.wmm, H = opts.hmm;
    const cx = W/2, cy = H/2;

    if(opts.template==="phase"){
      // two slits + central stripe
      const slitY0 = 2, slitY1 = H - 2;
      const d = opts.slitD, w = opts.slitW;
      const slitX0 = cx - d/2 - w;
      const slitX1 = cx + d/2;
      // slits
      ctx.fillRect(mm2px(slitX0), mm2px(slitY0), mm2px(w), mm2px(slitY1-slitY0));
      ctx.fillRect(mm2px(slitX1), mm2px(slitY0), mm2px(w), mm2px(slitY1-slitY0));
      // central dark line (5mm wide default)
      const stripeW = Math.min(6, Math.max(2, W*0.22));
      ctx.fillRect(mm2px(cx - stripeW/2), mm2px(0.5), mm2px(stripeW), mm2px(H-1.0));

      // horizon shade bottom 20%
      const hzH = H*0.2;
      aqcDrawDither(ctx, 0, mm2px(H-hzH), canvas.width, mm2px(hzH), opts.seed+11, 0.015);

      // label marker
      ctx.globalAlpha = 1;
      return;
    }

    // Cup or Foam: draw ceiling curve and horizon shade
    const R = opts.R;
    const Ro = Math.min(W/2, 1.5*R);
    const topPad = 1.0, sidePad = 1.0, bottomPad = 1.0;

    // Ceiling curve (map h(r) to y coordinate: near top)
    // We'll interpret h(r) in [1/y0, 1] and map to a fraction of available vertical space.
    const availH = H - topPad - bottomPad;
    const yMin = topPad;                 // top
    const yMax = topPad + availH*0.75;   // where ceiling can drop
    const rMax = Math.min(R, Ro);

    ctx.beginPath();
    for(let i=0;i<=500;i++){
      const x = -Ro + (2*Ro)*i/500;
      const r = Math.min(rMax, Math.abs(x));
      const h = aqc_h(r, rMax, opts.k, opts.y0); // in [1/y0,1]
      const frac = 1 - (h - (1/opts.y0)) / (1 - (1/opts.y0)); // 0 at center, 1 at edge
      const y = yMin + frac*(yMax - yMin);
      const X = cx + x;
      if(i===0) ctx.moveTo(mm2px(X), mm2px(y));
      else ctx.lineTo(mm2px(X), mm2px(y));
    }
    ctx.stroke();

    // Side walls at ±Ro from ceiling down to horizon region
    ctx.beginPath();
    ctx.moveTo(mm2px(cx-Ro), mm2px(yMax));
    ctx.lineTo(mm2px(cx-Ro), mm2px(H-bottomPad));
    ctx.moveTo(mm2px(cx+Ro), mm2px(yMax));
    ctx.lineTo(mm2px(cx+Ro), mm2px(H-bottomPad));
    ctx.stroke();

    // Slits at the very top
    const d = opts.slitD, w = opts.slitW;
    const slitH = Math.max(4, availH*0.18);
    const slitY = topPad;
    ctx.fillRect(mm2px(cx - d/2 - w), mm2px(slitY), mm2px(w), mm2px(Math.min(slitH, H-topPad-1)));
    ctx.fillRect(mm2px(cx + d/2), mm2px(slitY), mm2px(w), mm2px(Math.min(slitH, H-topPad-1)));

    // Horizon shade bottom 20%
    const hzH = H*0.2;
    aqcDrawDither(ctx, 0, mm2px(H-hzH), canvas.width, mm2px(hzH), opts.seed+7, 0.018);

    if(opts.template==="foam"){
      // Add foam wiggles on horizon
      const rnd = aqcRand(opts.seed+99);
      const baseY = H - hzH*0.9;
      ctx.beginPath();
      for(let i=0;i<=400;i++){
        const x = (W*i/400);
        const wig = (rnd()-0.5) * (hzH*0.25);
        const y = baseY + wig;
        if(i===0) ctx.moveTo(mm2px(x), mm2px(y));
        else ctx.lineTo(mm2px(x), mm2px(y));
      }
      ctx.stroke();

      // Nested inset cup (scaled)
      const alpha = 0.7;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.translate(mm2px(W*(1-alpha)/2), mm2px(H*(1-alpha)/2));
      ctx.scale(alpha, alpha);
      // recursion: draw a smaller cup outline (no slits)
      const W2 = W, H2 = H;
      const cx2 = cx, topPad2 = topPad, bottomPad2 = bottomPad;
      const availH2 = H2 - topPad2 - bottomPad2;
      const yMin2 = topPad2;
      const yMax2 = topPad2 + availH2*0.70;
      const Ro2 = Math.min(W2/2, 1.5*R);
      const rMax2 = Math.min(R, Ro2);
      ctx.beginPath();
      for(let i=0;i<=400;i++){
        const x = -Ro2 + (2*Ro2)*i/400;
        const r = Math.min(rMax2, Math.abs(x));
        const h = aqc_h(r, rMax2, opts.k, opts.y0);
        const frac = 1 - (h - (1/opts.y0)) / (1 - (1/opts.y0));
        const y = yMin2 + frac*(yMax2 - yMin2);
        const X = cx2 + x;
        if(i===0) ctx.moveTo(mm2px(X), mm2px(y));
        else ctx.lineTo(mm2px(X), mm2px(y));
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function aqcRenderIntoOverlay(){
    const localV = $("local");
    const c = $("localOverlay");
    if(!localV || !c) return;
    // match canvas resolution to displayed video
    const rect = localV.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(c.width !== w || c.height !== h){ c.width = w; c.height = h; }

    aqcSyncDrawCanvas();
    aqcInstallDrawHandlers();

    if(AQC.qcMode || AQC.qcActive || AQC.computeBusy){
      const cctx = c.getContext("2d");
      cctx.clearRect(0,0,c.width,c.height);
      return;
    }

    const ctx = c.getContext("2d");
    ctx.clearRect(0,0,c.width,c.height);

    if(AQC.mode==="none") return;

    // Render a centered design at adjustable "mm" scale (user-tunable)
    const sizeFrac = aqcClamp(AQC.sizeMm/40, 0.2, 1.0);
    const box = Math.min(w,h) * sizeFrac;
    const left = (w - box)/2;
    const top = (h - box*0.66)/2; // match 30x20 aspect approx
    ctx.save();
    ctx.globalAlpha = aqcClamp(AQC.opacity, 0.1, 0.95);
    ctx.fillStyle = "rgba(255,255,255,.0)";
    // draw into a temporary offscreen canvas for crisp scaling
    const off = document.createElement("canvas");
    off.width = 900; off.height = 600; // 3:2 aspect
    const opts = aqcGetDesignOpts();
    opts.template = (AQC.mode==="cup") ? "cup" : (AQC.mode==="phase") ? "phase" : (AQC.mode==="foam") ? "foam" : "cup";
    opts.wmm = 30; opts.hmm = 20; opts.dpi = 600;
    if(AQC.mode==="layout"){ aqcDrawLayout(off, AQC.layoutId, opts); } else { aqcRenderDesign(off, opts); }
    ctx.drawImage(off, left, top, box, box*0.66);
    ctx.restore();
  }

  function aqcApplyOverlayState(){
    // update labels + redraw
    if($("ovSizeLabel")) $("ovSizeLabel").textContent = `${AQC.sizeMm}mm`;
    if($("aqcOvSizeLabel")) $("aqcOvSizeLabel").textContent = `${AQC.sizeMm}mm`;
    if($("ovOpLabel")) $("ovOpLabel").textContent = `${Math.round(AQC.opacity*100)}%`;
    if($("aqcOvOpLabel")) $("aqcOvOpLabel").textContent = `${Math.round(AQC.opacity*100)}%`;

    if($("overlayBtn")){
      $("overlayBtn").disabled = !localStream || AQC.qcMode || AQC.qcActive;
      if($("computeBtn")) $("computeBtn").disabled = !localStream || AQC.qcMode || AQC.qcActive || AQC.computeBusy;
      $("overlayBtn").style.display = (AQC.qcMode || AQC.qcActive || AQC.computeBusy) ? "none" : "";
    }
    if($("overlayPanel") && (AQC.qcMode || AQC.qcActive)) $("overlayPanel").classList.add("hidden");

    if($("ovQcState")) $("ovQcState").textContent = (AQC.qcActive ? "active" : (AQC.computeBusy ? "run" : (AQC.qcMode ? "qc" : "idle")));
    if($("aqcQcState")) $("aqcQcState").textContent = (AQC.qcActive ? "active" : (AQC.computeBusy ? "run" : (AQC.qcMode ? "qc" : "idle")));

    aqcRenderIntoOverlay();
  }

  function aqcOnMedia(isOn){
    // enable layout button when camera is live
    if(!isOn){
      AQC.mode = "none";
      AQC.qcMode = false;
    }
    // wait a tick so video has layout
    setTimeout(()=> aqcApplyOverlayState(), 50);
  }

  function aqcTogglePanel(show){
    const p = $("overlayPanel");
    if(!p) return;
    p.classList.toggle("hidden", !show);
    if(show){ aqcApplyOverlayState(); aqcSyncDrawCanvas(); aqcInstallDrawHandlers(); }
  }

  // AQC designer UI
  function aqcRender(){
    const c = $("aqcCanvas");
    const opts = aqcGetDesignOpts();
    aqcRenderDesign(c, opts);
    if($("aqcAscii")) $("aqcAscii").textContent = aqcAsciiFor(opts.template);
  }

  function aqcDownloadBlob(filename, mime, data){
    const blob = new Blob([data], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250);
  }

  function aqcExportPng(){
    const c = $("aqcCanvas");
    if(!c){ aqcLogDiag("No canvas"); return; }
    const url = c.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = `aqc-mask-${$("aqcTemplate")?.value||"cup"}-${Date.now()}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function aqcExportSvg(){
    const opts = aqcGetDesignOpts();
    const wmm = opts.wmm, hmm = opts.hmm;
    const border = 0.3;
    const d = opts.slitD, w = opts.slitW;
    const cx = wmm/2;
    let body = "";
    body += `<rect x="${border}" y="${border}" width="${(wmm-2*border)}" height="${(hmm-2*border)}" fill="white" stroke="black" stroke-width="${border}"/>`;

    if(opts.template==="phase"){
      const slitY0 = 2, slitY1 = hmm - 2;
      body += `<rect x="${(cx - d/2 - w)}" y="${slitY0}" width="${w}" height="${(slitY1-slitY0)}" fill="black"/>`;
      body += `<rect x="${(cx + d/2)}" y="${slitY0}" width="${w}" height="${(slitY1-slitY0)}" fill="black"/>`;
      const stripeW = Math.min(6, Math.max(2, wmm*0.22));
      body += `<rect x="${(cx - stripeW/2)}" y="0.5" width="${stripeW}" height="${(hmm-1.0)}" fill="black"/>`;
      // horizon shade block (solid)
      const hzH = hmm*0.2;
      body += `<rect x="0" y="${(hmm-hzH)}" width="${wmm}" height="${hzH}" fill="black" opacity="0.25"/>`;
    } else {
      // ceiling path (cup/foam)
      const R = opts.R;
      const Ro = Math.min(wmm/2, 1.5*R);
      const topPad = 1.0, bottomPad = 1.0;
      const availH = hmm - topPad - bottomPad;
      const yMin = topPad;
      const yMax = topPad + availH*0.75;
      const rMax = Math.min(R, Ro);

      let dpath = "";
      for(let i=0;i<=260;i++){
        const x = -Ro + (2*Ro)*i/260;
        const r = Math.min(rMax, Math.abs(x));
        const h = aqc_h(r, rMax, opts.k, opts.y0);
        const frac = 1 - (h - (1/opts.y0)) / (1 - (1/opts.y0));
        const y = yMin + frac*(yMax - yMin);
        const X = cx + x;
        dpath += (i===0) ? `M ${X.toFixed(3)} ${y.toFixed(3)}` : ` L ${X.toFixed(3)} ${y.toFixed(3)}`;
      }
      body += `<path d="${dpath}" fill="none" stroke="black" stroke-width="0.25"/>`;
      body += `<line x1="${(cx-Ro)}" y1="${yMax.toFixed(3)}" x2="${(cx-Ro)}" y2="${(hmm-bottomPad)}" stroke="black" stroke-width="0.25"/>`;
      body += `<line x1="${(cx+Ro)}" y1="${yMax.toFixed(3)}" x2="${(cx+Ro)}" y2="${(hmm-bottomPad)}" stroke="black" stroke-width="0.25"/>`;

      // slits
      const slitH = Math.max(4, availH*0.18);
      body += `<rect x="${(cx - d/2 - w)}" y="${topPad}" width="${w}" height="${slitH}" fill="black"/>`;
      body += `<rect x="${(cx + d/2)}" y="${topPad}" width="${w}" height="${slitH}" fill="black"/>`;

      // horizon shade block
      const hzH = hmm*0.2;
      body += `<rect x="0" y="${(hmm-hzH)}" width="${wmm}" height="${hzH}" fill="black" opacity="0.25"/>`;

      if(opts.template==="foam"){
        // extra wiggle polyline
        const rnd = aqcRand(opts.seed+99);
        const baseY = hmm - hzH*0.9;
        let pts = "";
        for(let i=0;i<=120;i++){
          const x = (wmm*i/120);
          const wig = (rnd()-0.5) * (hzH*0.25);
          const y = baseY + wig;
          pts += `${x.toFixed(3)},${y.toFixed(3)} `;
        }
        body += `<polyline points="${pts.trim()}" fill="none" stroke="black" stroke-width="0.25"/>`;
      }
    }

    const svg = `<?xml version="1.0" encoding="UTF-8"?>\n` +
                `<svg xmlns="http://www.w3.org/2000/svg" width="${wmm}mm" height="${hmm}mm" viewBox="0 0 ${wmm} ${hmm}">\n` +
                body + "\n</svg>\n";
    aqcDownloadBlob(`aqc-mask-${opts.template}-${Date.now()}.svg`, "image/svg+xml", svg);
  }

  function aqcCopyAscii(){
    const t = $("aqcAscii")?.textContent || "";
    try{ navigator.clipboard?.writeText(t); }catch{}
  }

  function aqcUseAsOverlay(){
    const opts = aqcGetDesignOpts();
    AQC.mode = opts.template;
    AQC.qcMode = false;
    aqcApplyOverlayState();
    // Open overlay panel if available
    aqcTogglePanel(true);
  }

  function aqcSetMode(m){
    AQC.mode = m;
    AQC.qcMode = false;
    aqcApplyOverlayState();
  }

  function aqcToggleQcMode(){
    AQC.qcMode = !AQC.qcMode;
    if(AQC.qcMode) AQC.mode = "none";
    aqcApplyOverlayState();
  }

  // ---- Architecture drawing + 4f run (phone-optimized) ----
  async function aqcEnsureTf(){
    if(window.tf && window.tf.tensor) return window.tf;
    const url = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js";
    await new Promise((resolve,reject)=>{
      const s=document.createElement("script");
      s.src=url; s.async=true;
      s.onload=()=>resolve();
      s.onerror=()=>reject(new Error("Failed to load TensorFlow.js"));
      document.head.appendChild(s);
    });
    return window.tf;
  }

  function aqcSetArchMode(on){
    AQC.archMode = !!on;
    if($("ovDrawState")) $("ovDrawState").textContent = AQC.archMode ? "on" : "off";
    if($("ovArch")) $("ovArch").classList.toggle("active", AQC.archMode);
    const dc = $("localDraw");
    if(dc) dc.style.pointerEvents = (AQC.archMode && !(AQC.qcMode || AQC.qcActive || AQC.computeBusy)) ? "auto" : "none";
  }

  function aqcSetEraser(v){
    AQC.eraser = !!v;
    if($("ovBrush")) $("ovBrush").classList.toggle("active", !AQC.eraser);
    if($("ovEraser")) $("ovEraser").classList.toggle("active", AQC.eraser);
  }

  function aqcClearDrawing(){
    const dc = $("localDraw"); if(!dc) return;
    const ctx = dc.getContext("2d");
    ctx.clearRect(0,0,dc.width,dc.height);
  }

  function aqcSyncDrawCanvas(){
    const ov = $("localOverlay"), dc = $("localDraw");
    if(!ov || !dc) return;

    // keep pixel buffer aligned with overlay canvas
    if(dc.width !== ov.width || dc.height !== ov.height){
      const snap = document.createElement("canvas");
      snap.width = dc.width || 1; snap.height = dc.height || 1;
      if(dc.width && dc.height) snap.getContext("2d").drawImage(dc,0,0);
      dc.width = ov.width; dc.height = ov.height;
      if(snap.width && snap.height){
        dc.getContext("2d").drawImage(snap, 0,0,snap.width,snap.height, 0,0,dc.width,dc.height);
      }
    }

    dc.style.display = (AQC.qcMode || AQC.qcActive || AQC.computeBusy) ? "none" : "";
    dc.style.pointerEvents = (AQC.archMode && !(AQC.qcMode || AQC.qcActive || AQC.computeBusy)) ? "auto" : "none";
  }

  function aqcInstallDrawHandlers(){
    const dc = $("localDraw");
    if(!dc || dc.__aqcDrawBound) return;
    dc.__aqcDrawBound = true;

    let down=false, last=null;
    function pos(e){
      const r=dc.getBoundingClientRect();
      const dpr=window.devicePixelRatio||1;
      return {x:(e.clientX-r.left)*dpr, y:(e.clientY-r.top)*dpr};
    }
    function seg(p0,p1){
      const ctx=dc.getContext("2d");
      ctx.save();
      ctx.lineCap="round"; ctx.lineJoin="round";
      ctx.lineWidth = AQC.brushPx;
      if(AQC.eraser){
        ctx.globalCompositeOperation="destination-out";
        ctx.strokeStyle="rgba(0,0,0,1)";
      }else{
        ctx.globalCompositeOperation="source-over";
        ctx.strokeStyle="rgba(0,0,0,1)";
      }
      ctx.beginPath();
      ctx.moveTo(p0.x,p0.y);
      ctx.lineTo(p1.x,p1.y);
      ctx.stroke();
      ctx.restore();
    }

    dc.addEventListener("pointerdown", (e)=>{
      if(!AQC.archMode || AQC.qcMode || AQC.qcActive || AQC.computeBusy) return;
      e.preventDefault();
      try{ dc.setPointerCapture(e.pointerId); }catch{}
      down=true;
      last = pos(e);
    }, {passive:false});

    dc.addEventListener("pointermove", (e)=>{
      if(!down) return;
      if(!AQC.archMode || AQC.qcMode || AQC.qcActive || AQC.computeBusy) return;
      e.preventDefault();
      const p = pos(e);
      if(last) seg(last,p);
      last = p;
    }, {passive:false});

    function end(e){
      if(!down) return;
      down=false; last=null;
      try{ dc.releasePointerCapture(e.pointerId); }catch{}
    }
    dc.addEventListener("pointerup", end);
    dc.addEventListener("pointercancel", end);
  }

  function aqcCaptureMask(res){
    const ov=$("localOverlay"), dc=$("localDraw");
    const off=document.createElement("canvas");
    off.width=res; off.height=res;
    const ctx=off.getContext("2d");
    ctx.fillStyle="#fff"; ctx.fillRect(0,0,res,res);
    if(ov && ov.width) ctx.drawImage(ov,0,0,res,res);
    if(dc && dc.width) ctx.drawImage(dc,0,0,res,res);
    const data=ctx.getImageData(0,0,res,res).data;
    const t=new Float32Array(res*res);
    for(let i=0,j=0;i<t.length;i++,j+=4){
      const gray=(data[j]+data[j+1]+data[j+2])/(3*255);
      t[i]=gray;
    }
    return t;
  }

  function aqcTfFFT2(tf, z){
    let y=tf.spectral.fft(z);
    y=tf.transpose(y);
    y=tf.spectral.fft(y);
    y=tf.transpose(y);
    return y;
  }

  function aqcTfIFFT2(tf, z){
    let y=tf.spectral.ifft(z);
    y=tf.transpose(y);
    y=tf.spectral.ifft(y);
    y=tf.transpose(y);
    return y;
  }

  async function aqcRunArchitecture(){
    if($("ovRunState")) $("ovRunState").textContent = "running";
    AQC.computeBusy = true;
    aqcSyncDrawCanvas();
    aqcApplyOverlayState();

    const t0 = performance.now();
    try{
      const tf = await aqcEnsureTf();
      const res = Math.floor(aqcClamp($("ovSimRes")?.value || 128, 64, 256));
      const stages = Math.floor(aqcClamp($("ovStages")?.value || 1, 1, 8));

      const maskArr = aqcCaptureMask(res);

      tf.engine().startScope();
      const N=res;
      const mask = tf.complex(tf.tensor2d(maskArr,[N,N]), tf.zeros([N,N]));
      let field = tf.complex(tf.ones([N,N]), tf.zeros([N,N]));

      for(let s=0;s<stages;s++){
        const F = aqcTfFFT2(tf, field);
        const G = F.mul(mask);
        field = aqcTfIFFT2(tf, G);
      }

      const intensity = field.abs().square();
      const maxv = (await intensity.max().data())[0] || 1;
      const norm = intensity.div(tf.scalar(maxv + 1e-9));
      const arr = await norm.data();

      const outC = $("ovResult");
      if(outC){
        outC.width = N; outC.height = N;
        const octx = outC.getContext("2d");
        const img = octx.createImageData(N,N);
        for(let i=0,j=0;i<arr.length;i++,j+=4){
          const v = Math.max(0, Math.min(255, Math.round(arr[i]*255)));
          img.data[j]=v; img.data[j+1]=v; img.data[j+2]=v; img.data[j+3]=255;
        }
        octx.putImageData(img,0,0);
      }

      tf.engine().endScope();

      const dt = Math.round(performance.now()-t0);
      if($("ovResultDetails")) $("ovResultDetails").open = true;
      if($("ovResultInfo")) $("ovResultInfo").textContent = `res=${res} stages=${stages} time=${dt}ms backend=${(tf.getBackend&&tf.getBackend())||"?"}`;
      if($("ovRunState")) $("ovRunState").textContent = "done";

    }catch(e){
      if($("ovResultInfo")) $("ovResultInfo").textContent = "Run failed: " + (e && e.message ? e.message : String(e));
      if($("ovRunState")) $("ovRunState").textContent = "failed";
    }finally{
      setStatusToast("ready");
      RUNCTL.computeAbort = false;
      AQC.computeBusy = false;
      aqcSyncDrawCanvas();
      aqcApplyOverlayState();
    }
  }


  function aqcLogDiag(line){
    const out = $("aqcDiagOut");
    if(out) out.textContent += line + "\n";
  }

  function aqcRunChecks(){
    const out = $("aqcDiagOut");
    if(out) out.textContent = "";
    const must = ["tabAqc","viewAQC","aqcRender","aqcToOverlay","aqcExportPng","aqcExportSvg","aqcCanvas","overlayBtn","overlayPanel","localDraw","ovNone","ovCup","ovPhase","ovFoam","ovArch","ovBrush","ovEraser","ovBrushSize","ovClear","ovSimRes","ovStages","ovRun","ovResult","overlayClose","ovSize","ovOpacity","ovToggleQc","computeBtn","ovCompute","ovObs","ovFFT","ovPred","ovComputeDetails","monoHeavyDetails","hvMode","hvRes","hvPower","hvAuto","hvStart","hvStop","hvCanvas","hvState"];
    const missing = must.filter(id=> !$(id));
    if(missing.length) aqcLogDiag("Missing: " + missing.join(", "));
    else aqcLogDiag("All AQC elements present.");

    // overlay button state
    if($("overlayBtn")){
      aqcLogDiag("Media on: " + (!!localStream));
      aqcLogDiag("Layout enabled: " + (!$("overlayBtn").disabled));
      aqcLogDiag("QC mode: " + AQC.qcMode + "  QC active: " + AQC.qcActive);
    }

    // download support
    const a = document.createElement("a");
    const okDl = ("download" in a);
    aqcLogDiag("Download attribute supported: " + okDl);

    AQC.lastReport = out ? out.textContent : "";
  }

  function aqcCopyReport(){
    try{
      navigator.clipboard?.writeText(AQC.lastReport || $("aqcDiagOut")?.textContent || "");
    }catch{}
  }

  function aqcWire(){
    // Local overlay UI
    if($("overlayBtn")) $("overlayBtn").onclick = ()=> aqcTogglePanel(true);
    if($("computeBtn")) $("computeBtn").onclick = ()=> { RUNCTL.computeAbort=false; aqcTogglePanel(true); setTimeout(()=> aqcComputeFromCameraPaper(), 120); };
    if($("overlayClose")) $("overlayClose").onclick = ()=> aqcTogglePanel(false);
    if($("ovNone")) $("ovNone").onclick = ()=> { AQC.mode="none"; aqcApplyOverlayState(); };
    if($("ovCup")) $("ovCup").onclick = ()=> aqcSetMode("cup");
    if($("ovPhase")) $("ovPhase").onclick = ()=> aqcSetMode("phase");
    if($("ovFoam")) $("ovFoam").onclick = ()=> aqcSetMode("foam");

    if($("ovArch")) $("ovArch").onclick = ()=> aqcSetArchMode(!AQC.archMode);
    if($("ovBrush")) $("ovBrush").onclick = ()=> aqcSetEraser(false);
    if($("ovEraser")) $("ovEraser").onclick = ()=> aqcSetEraser(true);
    if($("ovBrushSize")) $("ovBrushSize").oninput = (e)=> { AQC.brushPx = aqcClamp(e.target.value, 2, 30); if($("ovBrushLabel")) $("ovBrushLabel").textContent = `${AQC.brushPx}px`; };
    if($("ovClear")) $("ovClear").onclick = ()=> aqcClearDrawing();
    if($("ovRun")) $("ovRun").onclick = ()=> aqcRunArchitecture();

    if($("ovSize")) $("ovSize").oninput = (e)=> { AQC.sizeMm = aqcClamp(e.target.value, 8, 40); aqcApplyOverlayState(); };
    if($("ovOpacity")) $("ovOpacity").oninput = (e)=> { AQC.opacity = aqcClamp(e.target.value/100, 0.1, 0.95); aqcApplyOverlayState(); };
    if($("ovToggleQc")) $("ovToggleQc").onclick = ()=> aqcToggleQcMode();

    // Designer
    if($("aqcRender")) $("aqcRender").onclick = ()=> aqcRender();
    if($("aqcExportPng")) $("aqcExportPng").onclick = ()=> aqcExportPng();
    if($("aqcExportSvg")) $("aqcExportSvg").onclick = ()=> aqcExportSvg();
    if($("aqcCopyAscii")) $("aqcCopyAscii").onclick = ()=> aqcCopyAscii();
    if($("aqcToOverlay")) $("aqcToOverlay").onclick = ()=> aqcUseAsOverlay();

    // Quick overlay controls in AQC tab
    if($("aqcOvNone")) $("aqcOvNone").onclick = ()=> { AQC.mode="none"; AQC.qcMode=false; aqcApplyOverlayState(); };
    if($("aqcOvCup")) $("aqcOvCup").onclick = ()=> aqcSetMode("cup");
    if($("aqcOvPhase")) $("aqcOvPhase").onclick = ()=> aqcSetMode("phase");
    if($("aqcOvFoam")) $("aqcOvFoam").onclick = ()=> aqcSetMode("foam");
    if($("aqcOvSize")) $("aqcOvSize").oninput = (e)=> { AQC.sizeMm = aqcClamp(e.target.value, 8, 40); aqcApplyOverlayState(); };
    if($("aqcOvOpacity")) $("aqcOvOpacity").oninput = (e)=> { AQC.opacity = aqcClamp(e.target.value/100, 0.1, 0.95); aqcApplyOverlayState(); };
    if($("aqcToggleQc")) $("aqcToggleQc").onclick = ()=> aqcToggleQcMode();

    if($("aqcDiag")) $("aqcDiag").onclick = ()=> aqcRunChecks();
    if($("aqcDiagCopy")) $("aqcDiagCopy").onclick = ()=> aqcCopyReport();

    // Live redraw when window resizes / video resizes
    window.addEventListener("resize", ()=> aqcRenderIntoOverlay());
    if($("local")) $("local").addEventListener("loadedmetadata", ()=> setTimeout(()=>aqcRenderIntoOverlay(), 120));

    // init draw UI labels
    if($("ovBrushLabel")) $("ovBrushLabel").textContent = `${AQC.brushPx}px`;
    if($("ovDrawState")) $("ovDrawState").textContent = AQC.archMode ? "on" : "off";
  }

  // call once after UI wireup
  aqcWire();
  aqcRender();


  log("ready.", true);
// ---------------------------
  // Layout library (for camera overlays + analysis)
  // ---------------------------
  const LayoutLib = [];
  function layoutAdd(id, name, cat, draw, desc){
    LayoutLib.push({id, name, cat, draw, desc});
  }

  function drawCentered(ctx, fn){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0,0,w,h);
    fn(ctx, w, h);
    ctx.restore();
  }

  function normToPx(x, y, w, h){ return [x*w, y*h]; }

  // --- Core generators ---
  function genCup(ctx,w,h, p){
    // 3:2 aspect in our offscreens (900x600), map to that
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    // border
    ctx.strokeRect(w*0.06, h*0.08, w*0.88, h*0.84);

    // ceiling curve h(r) with s(u)=1-3u^2+2u^3
    const y0 = p?.y0 ?? 2.0;
    const k = p?.k ?? 3.0;
    const R = 1.0;
    const s = (u)=> (1 - 3*u*u + 2*u*u*u);
    const hfun = (r)=> (1/y0) + (1 - 1/y0)*s(Math.pow(r/R,k));
    // draw ceiling as a curve across top
    ctx.beginPath();
    const left = w*0.14, right = w*0.86;
    const top = h*0.18, bot = h*0.70;
    for(let i=0;i<=260;i++){
      const t = i/260; // 0..1 across width
      const r = Math.abs(t-0.5)*2; // 0 center -> 1 edge
      const hh = hfun(r);
      // map hh in [1/y0,1] to pixel y
      const yy = top + (1-hh)*(bot-top)*0.55;
      const xx = left + t*(right-left);
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    // horizon shade band (bottom 20%)
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.fillRect(w*0.14, h*0.66, w*0.72, h*0.12);
    ctx.restore();

    // twin slits at top
    const d = p?.d ?? 0.20; // relative separation
    const slitW = p?.w ?? 0.02;
    const slitH = 0.08;
    const cx = w*0.50;
    const y = h*0.22;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.fillRect(cx - d*w/2 - slitW*w/2, y, slitW*w, slitH*h);
    ctx.fillRect(cx + d*w/2 - slitW*w/2, y, slitW*w, slitH*h);

    ctx.restore();
  }

  function genPhaseGate(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(w*0.10, h*0.08, w*0.80, h*0.84);
    // slits
    ctx.fillStyle = "rgba(255,255,255,.95)";
    const slitW = w*0.03, slitH = h*0.55;
    ctx.fillRect(w*0.25 - slitW/2, h*0.15, slitW, slitH);
    ctx.fillRect(w*0.75 - slitW/2, h*0.15, slitW, slitH);
    // central parity stripe
    ctx.globalAlpha = 0.75;
    ctx.fillRect(w*0.50 - w*0.12, h*0.08, w*0.24, h*0.84);
    // horizon shade
    ctx.globalAlpha = 0.35;
    ctx.fillRect(w*0.10, h*0.72, w*0.80, h*0.12);
    ctx.restore();
  }

  function genFoam(ctx,w,h,p){
    genCup(ctx,w,h,p);
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,.9)";
    ctx.lineWidth = Math.max(1, Math.floor(w/700));
    // scribble perturbations along horizon
    ctx.beginPath();
    const y = h*0.74;
    const left = w*0.16, right = w*0.84;
    for(let i=0;i<=420;i++){
      const t = i/420;
      const xx = left + t*(right-left);
      const wig = Math.sin(t*26*Math.PI) * h*0.012 + Math.sin(t*9*Math.PI)*h*0.007;
      const yy = y + wig;
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
    // inset cup
    ctx.globalAlpha = 0.28;
    ctx.translate(w*0.17, h*0.10);
    ctx.scale(0.66, 0.66);
    genCup(ctx,w,h,p);
    ctx.restore();
  }

  function genDoubleSlit(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(w*0.08, h*0.08, w*0.84, h*0.84);
    ctx.fillStyle = "rgba(255,255,255,.95)";
    const slitW = w*0.015, slitH = h*0.35;
    const gap = w*0.10;
    ctx.fillRect(w*0.50-gap/2-slitW/2, h*0.12, slitW, slitH);
    ctx.fillRect(w*0.50+gap/2-slitW/2, h*0.12, slitW, slitH);
    ctx.restore();
  }

  
  function genTripleSlit(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(w*0.08, h*0.08, w*0.84, h*0.84);
    ctx.fillStyle="rgba(255,255,255,.95)";
    const slitW=w*0.014, slitH=h*0.36;
    const gap=w*0.07;
    const y=h*0.12;
    ctx.fillRect(w*0.50-gap-slitW/2, y, slitW, slitH);
    ctx.fillRect(w*0.50-slitW/2, y, slitW, slitH);
    ctx.fillRect(w*0.50+gap-slitW/2, y, slitW, slitH);
    ctx.restore();
  }

  function genPinholeArray(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(w*0.08, h*0.08, w*0.84, h*0.84);
    const n = p?.n ?? 7;
    const r = Math.min(w,h)*0.012;
    const left=w*0.18, right=w*0.82, top=h*0.18, bot=h*0.78;
    for(let iy=0;iy<n;iy++){
      for(let ix=0;ix<n;ix++){
        const x = left + (ix/(n-1))*(right-left);
        const y = top + (iy/(n-1))*(bot-top);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fillStyle="rgba(255,255,255,.95)";
        ctx.fill();
      }
    }
    ctx.restore();
  }

  function genAxicon(ctx,w,h,p){
    // radial lines -> Bessel-like (axicon approximation)
    ctx.save();
    const cx=w*0.5, cy=h*0.5;
    const lines = p?.lines ?? 80;
    const R = Math.min(w,h)*0.42;
    ctx.strokeStyle="rgba(255,255,255,.55)";
    ctx.lineWidth = Math.max(1, Math.floor(w/820));
    for(let i=0;i<lines;i++){
      const a = (i/lines)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(cx + R*Math.cos(a), cy + R*Math.sin(a));
      ctx.stroke();
    }
    ctx.restore();
  }

  function genCheckerPhase(ctx,w,h,p){
    ctx.save();
    const n = p?.n ?? 16;
    const cellW = w*0.84/n, cellH = h*0.84/n;
    const x0=w*0.08, y0=h*0.08;
    for(let iy=0;iy<n;iy++){
      for(let ix=0;ix<n;ix++){
        const on = ((ix+iy)%2)===0;
        ctx.fillStyle = on ? "rgba(255,255,255,.85)" : "rgba(255,255,255,.15)";
        ctx.fillRect(x0+ix*cellW, y0+iy*cellH, cellW, cellH);
      }
    }
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(x0,y0,w*0.84,h*0.84);
    ctx.restore();
  }

  function genKagome(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.85)";
    ctx.lineWidth = Math.max(1, Math.floor(w/760));
    const a = p?.a ?? 0.14;
    const dx = w*a;
    const dy = dx*Math.sqrt(3)/2;
    const left=w*0.10, right=w*0.90, top=h*0.12, bot=h*0.88;
    for(let y=top; y<bot+dy; y+=dy){
      const row = Math.round((y-top)/dy);
      for(let x=left; x<right+dx; x+=dx){
        const xx = x + (row%2)*dx/2;
        const r = dx*0.28;
        // triangles
        ctx.beginPath();
        ctx.moveTo(xx, y-r);
        ctx.lineTo(xx-r*0.86, y+r*0.5);
        ctx.lineTo(xx+r*0.86, y+r*0.5);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(xx, y+r);
        ctx.lineTo(xx-r*0.86, y-r*0.5);
        ctx.lineTo(xx+r*0.86, y-r*0.5);
        ctx.closePath();
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function genHPH(ctx,w,h,p){
    // Sketch: H - P(phi) - H via 3 blocks and two slits
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/560));
    ctx.strokeRect(w*0.08, h*0.08, w*0.84, h*0.84);
    // input/output couplers
    ctx.globalAlpha=0.9;
    ctx.fillStyle="rgba(255,255,255,.9)";
    ctx.fillRect(w*0.18, h*0.30, w*0.08, h*0.40);
    ctx.fillRect(w*0.74, h*0.30, w*0.08, h*0.40);
    // phase block
    ctx.globalAlpha=0.55;
    ctx.fillRect(w*0.47, h*0.22, w*0.06, h*0.56);
    ctx.restore();
  }

function genGrating(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth = Math.max(2, Math.floor(w/500));
    ctx.strokeRect(w*0.08, h*0.08, w*0.84, h*0.84);
    const n = p?.n ?? 13;
    ctx.fillStyle="rgba(255,255,255,.95)";
    const top = h*0.12, bot = h*0.60;
    const left = w*0.18, right = w*0.82;
    for(let i=0;i<n;i++){
      const t = (i+0.5)/n;
      const x = left + t*(right-left);
      ctx.fillRect(x-w*0.006, top, w*0.012, bot-top);
    }
    ctx.restore();
  }

  function genZonePlate(ctx,w,h,p){
    ctx.save();
    const cx=w*0.5, cy=h*0.5;
    const rings = p?.rings ?? 18;
    for(let i=1;i<=rings;i++){
      const r = Math.sqrt(i/rings) * Math.min(w,h)*0.42;
      ctx.beginPath();
      ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.strokeStyle = (i%2===0) ? "rgba(255,255,255,.9)" : "rgba(255,255,255,.25)";
      ctx.lineWidth = Math.max(2, Math.floor(w/560));
      ctx.stroke();
    }
    ctx.restore();
  }

  function genForkHologram(ctx,w,h,p){
    ctx.save();
    const l = p?.l ?? 1;
    ctx.strokeStyle="rgba(255,255,255,.9)";
    ctx.lineWidth = Math.max(1, Math.floor(w/700));
    const left=w*0.10, right=w*0.90, top=h*0.15, bot=h*0.85;
    const cx=w*0.50, cy=h*0.50;
    const lines = 42;
    for(let i=0;i<lines;i++){
      const t = (i/(lines-1));
      const y = top + t*(bot-top);
      ctx.beginPath();
      for(let j=0;j<=240;j++){
        const u = j/240;
        const x = left + u*(right-left);
        const dx = (x-cx)/(right-left);
        const dy = (y-cy)/(bot-top);
        const phase = 14*dx + l*Math.atan2(dy,dx);
        const off = Math.sin(phase)*0.006*(right-left);
        const yy = y + off;
        if(j===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function genGraphene(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.9)";
    ctx.lineWidth = Math.max(1, Math.floor(w/760));
    const a = p?.a ?? 0.10; // relative lattice spacing
    const dx = w*a;
    const dy = dx*Math.sqrt(3)/2;
    const left=w*0.08, right=w*0.92, top=h*0.10, bot=h*0.90;
    for(let y=top; y<bot+dy; y+=dy){
      const row = Math.round((y-top)/dy);
      for(let x=left; x<right+dx; x+=dx){
        const xx = x + (row%2)*dx/2;
        // small hex cell
        const r = dx*0.25;
        ctx.beginPath();
        for(let k=0;k<6;k++){
          const ang = Math.PI/3*k + Math.PI/6;
          const px = xx + r*Math.cos(ang);
          const py = y  + r*Math.sin(ang);
          if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function genMoire(ctx,w,h,p){
    ctx.save();
    // two lattices rotated slightly
    genGraphene(ctx,w,h,{a:0.11});
    ctx.globalAlpha = 0.55;
    ctx.translate(w*0.5,h*0.5);
    ctx.rotate((p?.theta ?? 3.0) * Math.PI/180);
    ctx.translate(-w*0.5,-h*0.5);
    genGraphene(ctx,w,h,{a:0.11});
    ctx.restore();
  }

  function genMZI(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.9)";
    ctx.lineWidth = Math.max(2, Math.floor(w/560));
    ctx.strokeRect(w*0.10, h*0.10, w*0.80, h*0.80);
    // two arms + beam splitters
    const x0=w*0.18, x1=w*0.82, y0=h*0.30, y1=h*0.70;
    ctx.beginPath();
    ctx.moveTo(x0, (y0+y1)/2); ctx.lineTo(w*0.32, y0);
    ctx.lineTo(w*0.68, y0); ctx.lineTo(x1,(y0+y1)/2);
    ctx.moveTo(x0,(y0+y1)/2); ctx.lineTo(w*0.32, y1);
    ctx.lineTo(w*0.68, y1); ctx.lineTo(x1,(y0+y1)/2);
    ctx.stroke();
    // phase shifter block on top arm
    ctx.globalAlpha = 0.55;
    ctx.fillStyle="rgba(255,255,255,.9)";
    ctx.fillRect(w*0.48, y0-h*0.04, w*0.06, h*0.08);
    ctx.restore();
  }

  function genRingRes(ctx,w,h,p){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,.9)";
    ctx.lineWidth = Math.max(2, Math.floor(w/560));
    const cx=w*0.60, cy=h*0.50;
    const r=Math.min(w,h)*0.22;
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
    // bus waveguide
    ctx.beginPath();
    ctx.moveTo(w*0.12, cy+r*0.75);
    ctx.lineTo(w*0.88, cy+r*0.75);
    ctx.stroke();
    // coupling gap indicator
    ctx.globalAlpha=0.6;
    ctx.fillStyle="rgba(255,255,255,.9)";
    ctx.fillRect(cx-r*0.35, cy+r*0.62, r*0.7, h*0.012);
    ctx.restore();
  }

  // Populate library
  layoutAdd("cup_basic","Resonance Cup (basic)","cup",(ctx,w,h)=>genCup(ctx,w,h,{}),
    "Cup domain with smooth ceiling curve + twin slits + shaded horizon band.");
  layoutAdd("phase_gate","Phase Gate (parity mask)","gates",(ctx,w,h)=>genPhaseGate(ctx,w,h,{}),
    "Twin slits + central parity stripe (π/2-like mode selection).");
  layoutAdd("foam_test","Foam perturbation test","cup",(ctx,w,h)=>genFoam(ctx,w,h,{}),
    "Cup + scribble perturbations + inset scaling cup.");
  layoutAdd("double_slit","Double-slit (interference)","interference",(ctx,w,h)=>genDoubleSlit(ctx,w,h,{}),
    "Classic two-slit diffraction/interference. FFT shows two dominant lobes.");
  layoutAdd("grating_13","Multi-slit grating (13)","diffractive",(ctx,w,h)=>genGrating(ctx,w,h,{n:13}),
    "Periodic slits. FFT shows multiple diffraction orders.");
  layoutAdd("zone_plate","Fresnel zone plate","diffractive",(ctx,w,h)=>genZonePlate(ctx,w,h,{rings:18}),
    "Concentric rings; focuses and creates strong radial spectrum.");
  layoutAdd("fork_l1","Fork hologram (vortex l=1)","vortex",(ctx,w,h)=>genForkHologram(ctx,w,h,{l:1}),
    "Forked grating for OAM-like vortex patterns.");
  layoutAdd("fork_l2","Fork hologram (vortex l=2)","vortex",(ctx,w,h)=>genForkHologram(ctx,w,h,{l:2}),
    "Higher charge fork hologram.");
  layoutAdd("graphene","Graphene lattice (honeycomb)","lattices",(ctx,w,h)=>genGraphene(ctx,w,h,{a:0.11}),
    "Hex honeycomb lattice; FFT shows sixfold peaks.");
  layoutAdd("moire_twist","Moiré twist (bilayer)","lattices",(ctx,w,h)=>genMoire(ctx,w,h,{theta:3.0}),
    "Two lattices with small rotation → moiré superlattice.");
  layoutAdd("mzi","Mach–Zehnder (mask sketch)","interference",(ctx,w,h)=>genMZI(ctx,w,h,{}),
    "Two-arm interferometer sketch; useful for alignment/analysis.");
  layoutAdd("ring_res","Ring resonator + bus (mask sketch)","gates",(ctx,w,h)=>genRingRes(ctx,w,h,{}),
    "Ring + bus waveguide coupling sketch (photonic resonance).");
  layoutAdd("triple_slit","Triple-slit (interference)","interference",(ctx,w,h)=>genTripleSlit(ctx,w,h,{}),
    "Three slits; FFT shows three-source interference structure.");
  layoutAdd("pinhole_7x7","Pinhole array (7×7)","diffractive",(ctx,w,h)=>genPinholeArray(ctx,w,h,{n:7}),
    "2D aperture array; FFT forms lattice of orders (Talbot-friendly).");
  layoutAdd("axicon","Axicon (Bessel-like)","diffractive",(ctx,w,h)=>genAxicon(ctx,w,h,{lines:80}),
    "Radial phase/amplitude proxy for Bessel-like rings and axial invariance.");
  layoutAdd("checker_phase","Checkerboard phase","gates",(ctx,w,h)=>genCheckerPhase(ctx,w,h,{n:16}),
    "Binary phase proxy; strong high-frequency content in FFT.");
  layoutAdd("kagome","Kagome lattice","lattices",(ctx,w,h)=>genKagome(ctx,w,h,{a:0.14}),
    "Kagome-like lattice; FFT shows characteristic triangular symmetry.");
  layoutAdd("hph_circuit","H–P(φ)–H circuit sketch","gates",(ctx,w,h)=>genHPH(ctx,w,h,{}),
    "A compact 3-block circuit sketch to test cascaded mask reasoning.");


  function aqcDrawLayout(canvas, layoutId, opts){
    const ctx = canvas.getContext("2d");
    const lay = LayoutLib.find(x=>x.id===layoutId) || LayoutLib[0];
    // background cleared
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!lay) return;
    lay.draw(ctx, canvas.width, canvas.height, opts);
  }

  function layoutsBuildGrid(){
    const grid = $("layoutsGrid");
    if(!grid) return;
    grid.innerHTML = "";
    const q = ($("layoutsSearch")?.value || "").trim().toLowerCase();
    const cat = $("layoutsCategory")?.value || "all";
    for(const lay of LayoutLib){
      if(cat!=="all" && lay.cat!==cat) continue;
      if(q && !(lay.name.toLowerCase().includes(q) || lay.id.includes(q) || (lay.desc||"").toLowerCase().includes(q))) continue;

      const card = document.createElement("div");
      card.className = "layoutCard";
      card.id = "layoutCard_"+lay.id;
      const cnv = document.createElement("canvas");
      cnv.className = "layoutThumb";
      cnv.width = 360; cnv.height = 240;
      card.appendChild(cnv);
      const title = document.createElement("div");
      title.style.marginTop = "8px";
      title.innerHTML = `<b>${lay.name}</b><div class="small">${lay.desc||""}</div>`;
      card.appendChild(title);

      // render thumb
      lay.draw(cnv.getContext("2d"), cnv.width, cnv.height);

      card.onclick = ()=> layoutsSelect(lay.id);
      grid.appendChild(card);
    }
    layoutsMarkActive();
  }

  function layoutsSelect(layoutId){
    AQC.mode = "layout";
    AQC.layoutId = layoutId;
    layoutsMarkActive();
    layoutsRenderPreview();
  }

  function layoutsMarkActive(){
    const id = AQC.layoutId;
    document.querySelectorAll(".layoutCard").forEach(el=> el.classList.toggle("active", el.id==="layoutCard_"+id));
    if($("layoutsSelectedName")){
      const lay = LayoutLib.find(x=>x.id===id);
      $("layoutsSelectedName").textContent = "Selected: " + (lay?lay.name:"(none)");
    }
  }

  function layoutsRenderPreview(){
    const c = $("layoutsPreview");
    if(!c) return;
    // keep a nice size
    if(c.width<2){ c.width = 900; c.height = 600; }
    if(c.height<2){ c.height = 600; }
    const lay = LayoutLib.find(x=>x.id===AQC.layoutId) || LayoutLib[0];
    if(!lay) return;
    lay.draw(c.getContext("2d"), c.width, c.height);
    if($("layoutsInfo")) $("layoutsInfo").textContent = lay.desc || "";
  }

  function layoutsApplyToCamera(){
    AQC.mode = "layout";
    aqcApplyOverlayState();
    aqcTogglePanel(true);
  }

  // ---------------------------
  // Compute: camera + paper mask → FFT + 4f prediction
  // ---------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function canvasEnsureSize(c, w, h){
    if(c.width !== w) c.width = w;
    if(c.height !== h) c.height = h;
  }

  function getVideoCropToCanvas(video, outCanvas, N, roiFrac, includeOverlay){
    const rect = video.getBoundingClientRect();
    const srcW = video.videoWidth || Math.max(2, Math.floor(rect.width));
    const srcH = video.videoHeight || Math.max(2, Math.floor(rect.height));
    // center-crop to square
    const side = Math.floor(Math.min(srcW, srcH) * roiFrac);
    const sx = Math.floor((srcW - side)/2);
    const sy = Math.floor((srcH - side)/2);

    canvasEnsureSize(outCanvas, N, N);
    const ctx = outCanvas.getContext("2d");
    ctx.drawImage(video, sx, sy, side, side, 0, 0, N, N);

    if(includeOverlay){
      const ov = $("localOverlay");
      if(ov && ov.width && ov.height){
        // overlay is in display coords; render it into offscreen by mapping through relative center-crop
        // We approximate by drawing overlay scaled to video and then cropping same region.
        const tmp = document.createElement("canvas");
        tmp.width = srcW; tmp.height = srcH;
        const tctx = tmp.getContext("2d");
        // draw overlay into tmp scaled to video size
        // localOverlay is already aligned to displayed video; we just scale to srcW/srcH
        tctx.drawImage(ov, 0, 0, tmp.width, tmp.height);
        // crop and composite additively (guide only)
        ctx.globalAlpha = 0.55;
        ctx.drawImage(tmp, sx, sy, side, side, 0, 0, N, N);
        ctx.globalAlpha = 1.0;
      }
    }
    return {sx,sy,side,srcW,srcH};
  }

  function imageDataToGrayFloat(imgData){
    const d = imgData.data;
    const n = imgData.width * imgData.height;
    const out = new Float32Array(n);
    for(let i=0;i<n;i++){
      const r=d[i*4], g=d[i*4+1], b=d[i*4+2];
      out[i] = (0.2126*r + 0.7152*g + 0.0722*b)/255.0;
    }
    return out;
  }

  function grayToMask(gray, thr, invert){
    const n = gray.length;
    const out = new Float32Array(n);
    const t = thr/255.0;
    for(let i=0;i<n;i++){
      let v = gray[i];
      // threshold -> binary-ish amplitude mask
      let m = (v > t) ? 1.0 : 0.0;
      if(invert) m = 1.0 - m;
      out[i] = m;
    }
    return out;
  }

  function renderScalarToCanvas(c, scalar, N, logScale=false){
    canvasEnsureSize(c, N, N);
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(N, N);
    let min=1e9, max=-1e9;
    for(let i=0;i<scalar.length;i++){
      const v = logScale ? Math.log(1 + scalar[i]) : scalar[i];
      if(v<min) min=v;
      if(v>max) max=v;
    }
    const denom = (max-min) || 1e-9;
    for(let i=0;i<scalar.length;i++){
      const v0 = logScale ? Math.log(1 + scalar[i]) : scalar[i];
      const v = (v0 - min)/denom;
      const col = Math.floor(v*255);
      img.data[i*4] = col;
      img.data[i*4+1] = col;
      img.data[i*4+2] = col;
      img.data[i*4+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }

  async function aqcEnsureTf(){
    if(window.tf) return window.tf;
    // reuse existing loader if present
    if(typeof loadTf === "function") return await loadTf();
    // fallback minimal loader
    const url = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js";
    await new Promise((res, rej)=>{
      const s = document.createElement("script");
      s.src = url; s.async = true;
      s.onload = res; s.onerror = ()=> rej(new Error("TF load failed"));
      document.head.appendChild(s);
    });
    return window.tf;
  }

  function tfFFT2(z){
    // z: complex tensor [N,N]
    const tf = window.tf;
    return tf.tidy(()=>{
      const fftRows = tf.spectral.fft(z); // last axis
      const trans = fftRows.transpose();
      const fftCols = tf.spectral.fft(trans);
      return fftCols.transpose();
    });
  }
  function tfIFFT2(z){
    const tf = window.tf;
    return tf.tidy(()=>{
      const ifftRows = tf.spectral.ifft(z);
      const trans = ifftRows.transpose();
      const ifftCols = tf.spectral.ifft(trans);
      return ifftCols.transpose();
    });
  }

  function makeInputField(N, kind){
    const tf = window.tf;
    return tf.tidy(()=>{
      const xs = tf.linspace(-1,1,N);
      const ys = tf.linspace(-1,1,N);
      const X = xs.tile([N]).reshape([N,N]);
      const Y = ys.reshape([N,1]).tile([1,N]);
      let amp;
      if(kind==="plane"){
        amp = tf.ones([N,N]);
      }else{
        const r2 = X.mul(X).add(Y.mul(Y));
        amp = r2.mul(-8.0).exp(); // gaussian
      }
      return tf.complex(amp, tf.zerosLike(amp));
    });
  }

  function scalarTopKPeaks(arr, N, k=8){
    // crude peak finder: take top-K excluding small center radius
    const peaks=[];
    const cx=(N/2)|0, cy=(N/2)|0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const dx=x-cx, dy=y-cy;
        const r2=dx*dx+dy*dy;
        if(r2 < (N*0.06)*(N*0.06)) continue;
        const v = arr[y*N+x];
        if(peaks.length<k){
          peaks.push({x,y,v});
          peaks.sort((a,b)=>b.v-a.v);
        }else if(v > peaks[peaks.length-1].v){
          peaks[peaks.length-1]={x,y,v};
          peaks.sort((a,b)=>b.v-a.v);
        }
      }
    }
    return peaks;
  }

  

  // ---------------------------
  // Heavy compute visualization (stress-test)
  // ---------------------------
  const HeavyViz = {
    running:false,
    mode:"butterfly",
    res:192,
    power:"med",
    raf:0,
    lastT:0,
    info:"",
    seedGray:null,
    // butterfly
    b:{x1:0.1,y1:0,z1:0, x2:0.100001,y2:0,z2:0, t:0},
    // navier
    f:null,
    // black disk
    bd:{radiusFrac:0.22},
    // black hole family
    bh:{tiltDeg:35, spin:0.35, scale:8.0, stars:true, disk:true, t:0}
  };

  function hvSetState(s){ if($("hvState")) $("hvState").textContent = s; }
  function hvSetInfo(s){ HeavyViz.info=s||""; if($("hvInfo")) $("hvInfo").textContent = HeavyViz.info; }

  function hvReadUI(){
    HeavyViz.mode = $("hvMode")?.value || HeavyViz.mode;
    HeavyViz.res = parseInt($("hvRes")?.value || HeavyViz.res, 10);
    HeavyViz.power = $("hvPower")?.value || HeavyViz.power;

    // extra params
    const bd = parseFloat($("hvBDRad")?.value || HeavyViz.bd.radiusFrac);
    if(!Number.isNaN(bd)) HeavyViz.bd.radiusFrac = Math.max(0.05, Math.min(0.49, bd));

    const tilt = parseFloat($("hvBHTilt")?.value || HeavyViz.bh.tiltDeg);
    if(!Number.isNaN(tilt)) HeavyViz.bh.tiltDeg = Math.max(0, Math.min(89, tilt));

    const spin = parseFloat($("hvBHSpin")?.value || HeavyViz.bh.spin);
    if(!Number.isNaN(spin)) HeavyViz.bh.spin = Math.max(0, Math.min(0.999, spin));

    const sc = parseFloat($("hvBHScale")?.value || HeavyViz.bh.scale);
    if(!Number.isNaN(sc)) HeavyViz.bh.scale = Math.max(0.5, Math.min(60, sc));

    HeavyViz.bh.stars = !!$("hvBHStars")?.checked;
    HeavyViz.bh.disk  = !!$("hvBHDisk")?.checked;
  }

  function hvEnsureCanvas(){
    const c = $("hvCanvas");
    if(!c) return null;
    const N = HeavyViz.res;
    if(c.width!==N || c.height!==N){
      c.width = N; c.height = N;
    }
    return c;
  }

  function hvVizStop(){
    
    panicVisible(false);
    HeavyViz.running = false;
    if(HeavyViz.raf) cancelAnimationFrame(HeavyViz.raf);
    HeavyViz.raf = 0;
    hvSetState("idle");
  }

  function hvVizStart(opts={}){
    
    panicVisible(true);
    hvReadUI();
    const c = hvEnsureCanvas();
    if(!c) return;
    HeavyViz.seedGray = opts.seedGray || HeavyViz.seedGray;

    hvVizStop();
    HeavyViz.running = true;
    HeavyViz.lastT = performance.now();

    if(HeavyViz.mode==="butterfly") hvInitButterfly();
    else if(HeavyViz.mode==="navier") hvInitNavier();
    else if(HeavyViz.mode==="blackdisk") hvInitBlackDisk();
    else if(HeavyViz.mode==="bh_shadow") hvInitBHShadow();
    else if(HeavyViz.mode==="bh_lens") hvInitBHLens();
    else if(HeavyViz.mode==="bh_geodesics") hvInitBHGeodesics();
    else if(HeavyViz.mode==="bh_ringdown") hvInitBHRingdown();
    else if(HeavyViz.mode==="bh_disk") hvInitBHDisk();

    hvSetState("running");
    if($("monoHeavyDetails")) $("monoHeavyDetails").open = true;
    HeavyViz.raf = requestAnimationFrame(hvLoop);
  }

  function hvLoop(t){
    if(!HeavyViz.running) return;
    const dt = Math.min(0.05, Math.max(0.001, (t-HeavyViz.lastT)/1000));
    HeavyViz.lastT = t;

    if(HeavyViz.mode==="butterfly") hvStepButterfly(dt);
    else if(HeavyViz.mode==="navier") hvStepNavier(dt);
    else if(HeavyViz.mode==="blackdisk") hvStepBlackDisk(dt);
    else if(HeavyViz.mode==="bh_shadow") hvStepBHShadow(dt);
    else if(HeavyViz.mode==="bh_lens") hvStepBHLens(dt);
    else if(HeavyViz.mode==="bh_geodesics") hvStepBHGeodesics(dt);
    else if(HeavyViz.mode==="bh_ringdown") hvStepBHRingdown(dt);
    else if(HeavyViz.mode==="bh_disk") hvStepBHDisk(dt);

    HeavyViz.raf = requestAnimationFrame(hvLoop);
  }

  // ---- 1) Chaotic butterfly (Lorenz pair divergence) ----
  function hvInitButterfly(){
    const c = hvEnsureCanvas();
    const ctx = c.getContext("2d");
    ctx.clearRect(0,0,c.width,c.height);
    // seed from camera gray if available (tiny bias)
    let bias = 0;
    if(HeavyViz.seedGray && HeavyViz.seedGray.length){
      const g = HeavyViz.seedGray;
      for(let i=0;i<Math.min(g.length, 4096);i+=17) bias += g[i];
      bias = (bias/240.0) - 0.5;
    }
    HeavyViz.b = {x1:0.1+bias*0.02,y1:0,z1:0, x2:0.100001+bias*0.02,y2:0,z2:0, t:0};
    hvSetInfo("Lorenz butterfly: two near-identical trajectories diverge. (Heavy=more steps/frame)");
  }

  function hvLorenzStep(st, dt){
    const sigma=10, rho=28, beta=8/3;
    const dx = sigma*(st.y-st.x);
    const dy = st.x*(rho-st.z)-st.y;
    const dz = st.x*st.y - beta*st.z;
    st.x += dx*dt; st.y += dy*dt; st.z += dz*dt;
  }

  function hvStepButterfly(dt){
    const c = hvEnsureCanvas();
    const ctx = c.getContext("2d");
    // fade
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0,0,c.width,c.height);

    const steps = (HeavyViz.power==="low")?200 : (HeavyViz.power==="med")?600 : (HeavyViz.power==="high")?1400 : 2600;
    const st = HeavyViz.b;
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 1;
    for(let i=0;i<steps;i++){
      hvLorenzStep({x:st.x1,y:st.y1,z:st.z1}, 0); // no-op to avoid object churn
      hvLorenzStep({x:st.x2,y:st.y2,z:st.z2}, 0);
      // integrate directly
      const s1={x:st.x1,y:st.y1,z:st.z1};
      const s2={x:st.x2,y:st.y2,z:st.z2};
      hvLorenzStep(s1, dt*0.12);
      hvLorenzStep(s2, dt*0.12);
      st.x1=s1.x; st.y1=s1.y; st.z1=s1.z;
      st.x2=s2.x; st.y2=s2.y; st.z2=s2.z;

      const x1 = (st.x1/40 + 0.5)*c.width;
      const y1 = (st.z1/60 + 0.2)*c.height;
      const x2 = (st.x2/40 + 0.5)*c.width;
      const y2 = (st.z2/60 + 0.2)*c.height;

      ctx.fillStyle = "rgba(106,228,255,0.9)";
      ctx.fillRect(x1|0, y1|0, 1, 1);
      ctx.fillStyle = "rgba(255,223,106,0.8)";
      ctx.fillRect(x2|0, y2|0, 1, 1);
    }
    ctx.restore();
  }

  // ---- 2) Navier–Stokes (2D stable fluids) ----
  function hvInitNavier(){
    const N = HeavyViz.res;
    const size = (N+2)*(N+2);
    const f = {
      N,
      dt:0.08,
      diff:0.00008,
      visc:0.00008,
      u:new Float32Array(size), v:new Float32Array(size),
      u0:new Float32Array(size), v0:new Float32Array(size),
      dens:new Float32Array(size), dens0:new Float32Array(size),
      p:new Float32Array(size), div:new Float32Array(size),
      lastX:0,lastY:0, dragging:false
    };

    // seed density from camera crop if available
    if(HeavyViz.seedGray){
      const g = HeavyViz.seedGray;
      for(let j=1;j<=N;j++){
        for(let i=1;i<=N;i++){
          const gi = ((j-1)*N + (i-1));
          const v = g[gi] || 0;
          f.dens[IX(f,i,j)] = v*0.8;
        }
      }
    }

    HeavyViz.f = f;
    hvAttachNavierInput();
    hvSetInfo("Navier–Stokes 2D: drag on canvas to inject dye + momentum.");
  }

  function IX(f,i,j){ return i + (f.N+2)*j; }

  function setBnd(f,b,x){
    const N=f.N;
    for(let i=1;i<=N;i++){
      x[IX(f,0,i)]   = b===1 ? -x[IX(f,1,i)] : x[IX(f,1,i)];
      x[IX(f,N+1,i)] = b===1 ? -x[IX(f,N,i)] : x[IX(f,N,i)];
      x[IX(f,i,0)]   = b===2 ? -x[IX(f,i,1)] : x[IX(f,i,1)];
      x[IX(f,i,N+1)] = b===2 ? -x[IX(f,i,N)] : x[IX(f,i,N)];
    }
    x[IX(f,0,0)]       = 0.5*(x[IX(f,1,0)]     + x[IX(f,0,1)]);
    x[IX(f,0,N+1)]     = 0.5*(x[IX(f,1,N+1)]   + x[IX(f,0,N)]);
    x[IX(f,N+1,0)]     = 0.5*(x[IX(f,N,0)]     + x[IX(f,N+1,1)]);
    x[IX(f,N+1,N+1)]   = 0.5*(x[IX(f,N,N+1)]   + x[IX(f,N+1,N)]);
  }

  function linSolve(f,b,x,x0,a,c,it){
    const N=f.N;
    for(let k=0;k<it;k++){
      for(let j=1;j<=N;j++){
        for(let i=1;i<=N;i++){
          x[IX(f,i,j)] = (x0[IX(f,i,j)] + a*(x[IX(f,i-1,j)] + x[IX(f,i+1,j)] + x[IX(f,i,j-1)] + x[IX(f,i,j+1)]))/c;
        }
      }
      setBnd(f,b,x);
    }
  }

  function diffuse(f,b,x,x0,diff,dt){
    const N=f.N;
    const a = dt*diff*N*N;
    const it = (HeavyViz.power==="low")?6 : (HeavyViz.power==="med")?10 : (HeavyViz.power==="high")?16 : 24;
    linSolve(f,b,x,x0,a,1+4*a,it);
  }

  function advect(f,b,d,d0,u,v,dt){
    const N=f.N;
    const dt0 = dt*N;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        let x = i - dt0*u[IX(f,i,j)];
        let y = j - dt0*v[IX(f,i,j)];
        if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5;
        if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5;
        const i0 = Math.floor(x), i1=i0+1;
        const j0 = Math.floor(y), j1=j0+1;
        const s1 = x-i0, s0=1-s1;
        const t1 = y-j0, t0=1-t1;
        d[IX(f,i,j)] =
          s0*(t0*d0[IX(f,i0,j0)] + t1*d0[IX(f,i0,j1)]) +
          s1*(t0*d0[IX(f,i1,j0)] + t1*d0[IX(f,i1,j1)]);
      }
    }
    setBnd(f,b,d);
  }

  function project(f,u,v,p,div){
    const N=f.N;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        div[IX(f,i,j)] = -0.5*(u[IX(f,i+1,j)]-u[IX(f,i-1,j)] + v[IX(f,i,j+1)]-v[IX(f,i,j-1)])/N;
        p[IX(f,i,j)] = 0;
      }
    }
    setBnd(f,0,div); setBnd(f,0,p);
    const it = (HeavyViz.power==="low")?10 : (HeavyViz.power==="med")?18 : (HeavyViz.power==="high")?30 : 44;
    linSolve(f,0,p,div,1,4,it);
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        u[IX(f,i,j)] -= 0.5*N*(p[IX(f,i+1,j)]-p[IX(f,i-1,j)]);
        v[IX(f,i,j)] -= 0.5*N*(p[IX(f,i,j+1)]-p[IX(f,i,j-1)]);
      }
    }
    setBnd(f,1,u); setBnd(f,2,v);
  }

  function velStep(f,u,v,u0,v0,visc,dt){
    // add source already in u0/v0
    for(let i=0;i<u.length;i++){ u[i]+=dt*u0[i]; v[i]+=dt*v0[i]; u0[i]=0; v0[i]=0; }
    diffuse(f,1,u0,u,visc,dt);
    diffuse(f,2,v0,v,visc,dt);
    project(f,u0,v0,f.p,f.div);
    advect(f,1,u,u0,u0,v0,dt);
    advect(f,2,v,v0,u0,v0,dt);
    project(f,u,v,f.p,f.div);
  }

  function densStep(f,x,x0,u,v,diff,dt){
    for(let i=0;i<x.length;i++){ x[i]+=dt*x0[i]; x0[i]=0; }
    diffuse(f,0,x0,x,diff,dt);
    advect(f,0,x,x0,u,v,dt);
  }

  function hvNavierInject(f, px, py, dx, dy){
    const N=f.N;
    const i = Math.floor(px*N)+1;
    const j = Math.floor(py*N)+1;
    if(i<1||i>N||j<1||j>N) return;
    const rad = (HeavyViz.power==="low")?2 : (HeavyViz.power==="med")?3 : (HeavyViz.power==="high")?4 : 6;
    for(let y=-rad;y<=rad;y++){
      for(let x=-rad;x<=rad;x++){
        const ii=i+x, jj=j+y;
        if(ii<1||ii>N||jj<1||jj>N) continue;
        const w = 1 - (x*x+y*y)/((rad+1)*(rad+1));
        if(w<=0) continue;
        f.dens0[IX(f,ii,jj)] += 4.0*w;
        f.u0[IX(f,ii,jj)] += dx*50*w;
        f.v0[IX(f,ii,jj)] += dy*50*w;
      }
    }
  }

  function hvAttachNavierInput(){
    const c = $("hvCanvas");
    if(!c) return;
    const f = HeavyViz.f;
    const getPos = (e)=>{
      const r=c.getBoundingClientRect();
      const x=(e.clientX-r.left)/r.width;
      const y=(e.clientY-r.top)/r.height;
      return [Math.max(0,Math.min(1,x)), Math.max(0,Math.min(1,y))];
    };
    c.onpointerdown = (e)=>{
      if(HeavyViz.mode!=="navier") return;
      c.setPointerCapture(e.pointerId);
      f.dragging=true;
      const [x,y]=getPos(e);
      f.lastX=x; f.lastY=y;
    };
    c.onpointerup = (e)=>{
      if(HeavyViz.mode!=="navier") return;
      f.dragging=false;
    };
    c.onpointermove = (e)=>{
      if(HeavyViz.mode!=="navier" || !f.dragging) return;
      const [x,y]=getPos(e);
      const dx=x-f.lastX, dy=y-f.lastY;
      hvNavierInject(f, x, y, dx, dy);
      f.lastX=x; f.lastY=y;
    };
  }

  function hvStepNavier(dt){
    const f = HeavyViz.f;
    if(!f) return;
    // occasionally inject from camera seed as weak dye at center
    if(HeavyViz.seedGray && (Math.random()<0.06)){
      const g=HeavyViz.seedGray;
      const mid=(f.N>>1) + (f.N+2)*((f.N>>1)+1);
      f.dens0[mid] += (g[(g.length>>1)]||0)*2.0;
    }

    const steps = (HeavyViz.power==="low")?1 : (HeavyViz.power==="med")?2 : (HeavyViz.power==="high")?3 : 4;
    for(let s=0;s<steps;s++){
      velStep(f, f.u, f.v, f.u0, f.v0, f.visc, f.dt);
      densStep(f, f.dens, f.dens0, f.u, f.v, f.diff, f.dt);
    }

    // render density
    const c = hvEnsureCanvas();
    const ctx = c.getContext("2d");
    const N=f.N;
    const img = ctx.createImageData(N,N);
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const d = Math.max(0, Math.min(1, f.dens[IX(f,i,j)]));
        const v = Math.max(0, Math.min(255, (d*255)|0));
        const k = ((j-1)*N + (i-1))<<2;
        img.data[k]=v; img.data[k+1]=v; img.data[k+2]=v; img.data[k+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }

  // ---- 3) Black disk diffraction (FFT) ----
  function hvInitBlackDisk(){
    hvSetInfo("Airy diffraction (black disk): far-field intensity. Uses TF.js FFT if available; otherwise an analytic Airy fallback.");
    // compute a first frame immediately
    hvRenderBlackDisk().catch((e)=>{ hvSetState("error"); hvSetInfo("Black disk failed: "+(e?.message||e)); });
  }


function hvStepBlackDisk(dt){
    // refresh slower to avoid locking the UI
    if(!HeavyViz._bdNext || performance.now() > HeavyViz._bdNext){
      const interval = (HeavyViz.power==="low")?900 : (HeavyViz.power==="med")?600 : (HeavyViz.power==="high")?400 : 260;
      HeavyViz._bdNext = performance.now() + interval;
      hvRenderBlackDisk().catch((e)=>{ hvSetState('error'); hvSetInfo('Black disk failed: '+(e?.message||e)); });
    }
  }

  async function hvRenderBlackDisk(){
    const c = hvEnsureCanvas();
    if(!c) return;
    const N = HeavyViz.res;

    const powScale = (HeavyViz.power==="low")?1 : (HeavyViz.power==="med")?1.5 : (HeavyViz.power==="high")?2.2 : 3.2;

    // Prefer TF.js FFT path (fast on WebGL). If anything fails (offline / CORS / no TF),
    // fall back to an analytic Airy model so the "black disk" always renders.
    try{
      const tf = await aqcEnsureTf();
      if(!tf || !tf.spectral || !tf.spectral.fft) throw new Error("TF.js spectral FFT not available");
      await tf.setBackend("webgl").catch(()=>{});
      await tf.ready();

      // build aperture = 1 - disk
      const r0 = HeavyViz.bd.radiusFrac * (N/2);
      const ap = new Float32Array(N*N);
      let seed = 0;
      if(HeavyViz.seedGray){
        const g=HeavyViz.seedGray;
        for(let i=0;i<Math.min(g.length, 2048);i+=13) seed += g[i];
        seed = (seed/160.0)-0.5;
      }
      const cx = (N-1)/2 + seed*1.2;
      const cy = (N-1)/2 - seed*1.2;
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const dx=x-cx, dy=y-cy;
          const inside = (dx*dx+dy*dy) <= r0*r0;
          ap[y*N+x] = inside ? 0.0 : 1.0;
        }
      }

      const out = await tf.tidy(async ()=>{
        const A = tf.tensor2d(ap,[N,N],"float32");
        // slight phase seed from camera gray
        let field = tf.complex(A, tf.zerosLike(A));
        if(HeavyViz.seedGray && HeavyViz.seedGray.length===N*N){
          const ph = tf.tensor2d(HeavyViz.seedGray,[N,N],"float32").sub(tf.scalar(0.5)).mul(tf.scalar(0.35));
          const re = A.mul(ph.cos());
          const im = A.mul(ph.sin());
          field = tf.complex(re, im);
        }
        const F = aqcTfFFT2(tf, field);
        const I = F.abs().pow(tf.scalar(2));
        const m = (await I.max().data())[0] || 1;
        const norm = I.div(tf.scalar(m+1e-9)).pow(tf.scalar(1/powScale));
        return await norm.data();
      });

      const ctx = c.getContext("2d");
      const img = ctx.createImageData(N,N);
      for(let i=0,j=0;i<out.length;i++,j+=4){
        const v = Math.max(0, Math.min(255, (out[i]*255)|0));
        img.data[j]=v; img.data[j+1]=v; img.data[j+2]=v; img.data[j+3]=255;
      }
      ctx.putImageData(img,0,0);
      hvSetInfo(`Black disk (FFT): N=${N} backend=${(tf.getBackend&&tf.getBackend())||"?"} r≈${(HeavyViz.bd.radiusFrac).toFixed(2)}·(N/2)`);
      return;
    }catch(e){
      hvRenderBlackDiskAiry(c, N, powScale);
      hvSetInfo(`Black disk (Airy fallback): N=${N} r≈${(HeavyViz.bd.radiusFrac).toFixed(2)}·(N/2) (${(e?.message||e)})`);
    }
  }

  // --- Airy fallback (no TF.js required) ---
  function hvJ1(x){
    // Hybrid: series for small x, asymptotic for large x.
    const ax = Math.abs(x);
    if(ax < 1e-3) return x/2;
    if(ax < 4.0){
      // J1(x) = sum_{m>=0} (-1)^m (x/2)^{2m+1} / (m!(m+1)!)
      const z = x/2;
      let term = z;
      let sum = term;
      for(let m=1;m<14;m++){
        term *= - (z*z) / (m*(m+1));
        sum += term;
      }
      return sum;
    }
    const s = Math.sqrt(2/(Math.PI*ax));
    const ph = ax - 3*Math.PI/4;
    const val = s*Math.cos(ph);
    return x<0 ? -val : val;
  }

  function hvAiryI(r, scale){
    // I(r) ~ (2 J1(s r) / (s r))^2 with safe handling near 0.
    const x = scale * r;
    if(Math.abs(x) < 1e-6) return 1.0;
    const j1 = hvJ1(x);
    const a = (2*j1/x);
    return a*a;
  }

  function hvRenderBlackDiskAiry(c, N, powScale){
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(N,N);

    // scale tuned so you get rings at phone-friendly resolutions
    const scale = HeavyViz.bh?.scale ? (HeavyViz.bh.scale*0.9) : 7.2;
    const cx = (N-1)/2, cy = (N-1)/2;
    const r0 = HeavyViz.bd.radiusFrac * (N/2);

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const dx = x-cx, dy=y-cy;
        const r = Math.sqrt(dx*dx+dy*dy);
        // treat as obstruction via Babinet: show same ring structure but suppress central core
        let I = hvAiryI(Math.max(0, r-r0*0.15), scale*0.045);
        // soften and emphasize rings
        I = Math.pow(Math.max(0, Math.min(1, I)), 1/powScale);
        const v = Math.max(0, Math.min(255, (I*255)|0));
        const j=(y*N+x)*4;
        img.data[j]=v; img.data[j+1]=v; img.data[j+2]=v; img.data[j+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }


  // ---- 4) Black hole family (shadow / lensing / geodesics / ringdown / disk) ----
  function hvBHSeed(){
    // derive a stable-ish seed from camera crop if available
    let s = 0x12345678;
    const g = HeavyViz.seedGray;
    if(g && g.length){
      let acc = 0;
      for(let i=0;i<Math.min(g.length, 8192);i+=17) acc = (acc + (g[i]*997))|0;
      s = (acc ^ 0x9e3779b9) >>> 0;
    }
    return s>>>0;
  }
  function hvMulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function hvBHEnsureBg(N){
    if(HeavyViz._bhBg && HeavyViz._bhBgN===N) return;
    HeavyViz._bhBgN = N;
    const seed = hvBHSeed();
    const rnd = hvMulberry32(seed);
    const bg = new Float32Array(N*N);
    // starfield: sparse bright points + faint dust
    for(let i=0;i<bg.length;i++){
      const d = Math.pow(rnd(), 6); // faint dust bias
      bg[i] = 0.06 * d;
    }
    const stars = Math.floor(N*N*0.0025);
    for(let i=0;i<stars;i++){
      const x = (rnd()*N)|0, y=(rnd()*N)|0;
      const idx = y*N+x;
      bg[idx] += 0.8 + 0.2*rnd();
      // tiny bloom
      if(x+1<N) bg[idx+1] += 0.15;
      if(y+1<N) bg[idx+N] += 0.15;
    }
    HeavyViz._bhBg = bg;
  }

  function hvBHSampleBg(u, v, N){
    // u,v in [-1,1]; wrap
    const x = ((u*0.5+0.5)*N) % N;
    const y = ((v*0.5+0.5)*N) % N;
    const xi = (x|0+N)%N, yi=(y|0+N)%N;
    return HeavyViz._bhBg[yi*N+xi] || 0;
  }

  function hvBHCommonRender(mode){
    const c = hvEnsureCanvas();
    if(!c) return;
    const N = HeavyViz.res;
    hvBHEnsureBg(N);
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(N,N);

    const tilt = (HeavyViz.bh.tiltDeg||0) * Math.PI/180;
    const spin = HeavyViz.bh.spin||0;
    const scale = HeavyViz.bh.scale||8.0;
    const showStars = !!HeavyViz.bh.stars;
    const showDisk  = !!HeavyViz.bh.disk;

    // visual radii (in normalized screen units)
    const shadowR = 0.28;
    const ringR   = 0.34 + 0.02*spin;
    const ringW   = 0.015;

    const t = HeavyViz.bh.t || 0;
    const cosT = Math.cos(tilt), sinT = Math.sin(tilt);

    for(let y=0;y<N;y++){
      const vy = ( (y/(N-1))*2 - 1 );
      for(let x=0;x<N;x++){
        const ux = ( (x/(N-1))*2 - 1 );
        let u = ux, v = vy;
        const r = Math.sqrt(u*u+v*v)+1e-6;

        // simple gravitational deflection (toy): alpha ~ M / r
        const M = 0.06 + 0.02*spin;
        const alpha = (mode==="bh_lens" ? 0.12 : 0.08) * (M) / (r + 0.03);
        u = u + alpha*(u/r);
        v = v + alpha*(v/r);

        let I = 0;

        // background
        if(showStars){
          // mild rotation so it "moves" and looks alive
          const ang = 0.12*Math.sin(0.2*t);
          const cu=Math.cos(ang), su=Math.sin(ang);
          const uu = cu*u - su*v;
          const vv = su*u + cu*v;
          I += 0.9*hvBHSampleBg(uu, vv, N);
        }

        // shadow + photon ring
        const rr = Math.sqrt(ux*ux+vy*vy);
        if(rr < shadowR){
          I *= 0.02; // deep shadow
        }else{
          const ring = Math.exp(-((rr-ringR)*(rr-ringR))/(2*ringW*ringW));
          I += 0.55*ring;
        }

        // accretion disk (tilted)
        if(mode==="bh_shadow" && showDisk){
          // rotate (u,v) into disk coordinates
          const xd = ux;
          const yd = vy*cosT;
          const zd = vy*sinT;
          const rd = Math.sqrt(xd*xd+yd*yd);

          // disk band: |z| small and radius in [0.36, 0.95]
          if(Math.abs(zd) < 0.12 && rd > 0.36 && rd < 0.95){
            const th = Math.atan2(yd, xd);
            // brightness profile with beaming
            const prof = Math.exp(-((rd-0.62)*(rd-0.62))/0.03);
            const swirl = 0.55 + 0.45*Math.sin(6*th + 1.4*t + 2.2*spin);
            const beam  = 0.6 + 0.4*Math.cos(th - 0.6*t); // crude Doppler-ish
            I += prof * swirl * beam * (0.9 + 0.6*spin);
          }
        }

        // clamp + gamma
        I = Math.max(0, Math.min(1, I));
        // "scale" acts like exposure/contrast knob
        I = 1 - Math.exp(-I*scale*0.18);

        const v8 = (I*255)|0;
        const j = (y*N + x)*4;
        img.data[j]=v8; img.data[j+1]=v8; img.data[j+2]=v8; img.data[j+3]=255;
      }
    }

    ctx.putImageData(img,0,0);
  }

  function hvInitBHShadow(){
    hvSetInfo("Black hole shadow + accretion: toy lensing + photon ring + tilted disk (heavy).");
    HeavyViz.bh.t = 0;
    hvBHCommonRender("bh_shadow");
  }
  function hvStepBHShadow(dt){
    if(!HeavyViz._bhNext || performance.now() > HeavyViz._bhNext){
      const interval = (HeavyViz.power==="low")?800 : (HeavyViz.power==="med")?520 : (HeavyViz.power==="high")?360 : 240;
      HeavyViz._bhNext = performance.now() + interval;
      HeavyViz.bh.t = (HeavyViz.bh.t||0) + dt*1.2;
      hvBHCommonRender("bh_shadow");
    }
  }

  function hvInitBHLens(){
    hvSetInfo("Black hole lensing starfield: toy deflection mapping (heavy).");
    HeavyViz.bh.t = 0;
    hvBHCommonRender("bh_lens");
  }
  function hvStepBHLens(dt){
    if(!HeavyViz._bhNext || performance.now() > HeavyViz._bhNext){
      const interval = (HeavyViz.power==="low")?900 : (HeavyViz.power==="med")?620 : (HeavyViz.power==="high")?420 : 280;
      HeavyViz._bhNext = performance.now() + interval;
      HeavyViz.bh.t = (HeavyViz.bh.t||0) + dt*0.9;
      hvBHCommonRender("bh_lens");
    }
  }

  function hvInitBHGeodesics(){
    hvSetInfo("Photon geodesics: many light-rays bent around a compact mass (toy integration).");
    const N = HeavyViz.res;
    const rays = [];
    const nR = Math.max(40, Math.min(140, (N/2)|0));
    const mu = 0.004 + 0.004*HeavyViz.bh.spin;
    for(let i=0;i<nR;i++){
      const b = (i/(nR-1))*2 - 1;
      const y0 = b*0.9;
      const ray = { pts:[], x:-1.7, y:y0, vx:1.0, vy:0.0, alive:true, hit:false };
      rays.push(ray);
    }
    HeavyViz._bhRays = rays;
    HeavyViz._bhRayMu = mu;
    HeavyViz._bhRayStep = 0;
    hvBHDrawRays();
  }

  function hvBHIntegrateRays(steps){
    const rays = HeavyViz._bhRays || [];
    const mu = HeavyViz._bhRayMu || 0.006;
    const h = 0.01;
    for(let s=0;s<steps;s++){
      for(const r of rays){
        if(!r.alive) continue;
        const x=r.x, y=r.y;
        const rr = Math.sqrt(x*x+y*y)+1e-6;
        if(rr < 0.28){ r.alive=false; r.hit=true; continue; }
        if(x > 1.7 || Math.abs(y)>2.0){ r.alive=false; continue; }
        // acceleration toward origin
        const ax = -mu * x/(rr*rr*rr);
        const ay = -mu * y/(rr*rr*rr);
        r.vx += ax*h;
        r.vy += ay*h;
        // keep ~unit speed (photon-like)
        const v = Math.sqrt(r.vx*r.vx + r.vy*r.vy)+1e-9;
        r.vx /= v; r.vy /= v;
        r.x += r.vx*h;
        r.y += r.vy*h;
        if((s%2)===0) r.pts.push([r.x, r.y]);
      }
    }
  }

  function hvBHDrawRays(){
    const c = hvEnsureCanvas(); if(!c) return;
    const ctx = c.getContext("2d");
    const N = HeavyViz.res;
    ctx.clearRect(0,0,N,N);
    ctx.globalAlpha = 1;

    // draw BH horizon + photon ring
    const cx=(N-1)/2, cy=(N-1)/2;
    const shadowR = 0.28*(N/2);
    const ringR = (0.34 + 0.02*(HeavyViz.bh.spin||0))*(N/2);

    ctx.beginPath(); ctx.arc(cx,cy,shadowR,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.9;
    ctx.beginPath(); ctx.arc(cx,cy,ringR,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;

    const rays = HeavyViz._bhRays || [];
    ctx.beginPath();
    for(const r of rays){
      if(!r.pts || !r.pts.length) continue;
      const p0=r.pts[0];
      ctx.moveTo(cx + p0[0]*(N/2), cy + p0[1]*(N/2));
      for(let k=1;k<r.pts.length;k++){
        const p=r.pts[k];
        ctx.lineTo(cx + p[0]*(N/2), cy + p[1]*(N/2));
      }
    }
    ctx.stroke();
  }

  function hvStepBHGeodesics(dt){
    // progressively integrate and redraw
    const steps = (HeavyViz.power==="low")?20 : (HeavyViz.power==="med")?40 : (HeavyViz.power==="high")?70 : 110;
    hvBHIntegrateRays(steps);
    hvBHDrawRays();
  }

  function hvInitBHRingdown(){
    hvSetInfo("Ringdown: decaying waveform + tiny spectrogram (heavy).");
    HeavyViz._bhRD = { t0: performance.now()/1000, phase:0 };
    hvRenderBHRingdown();
  }

  function hvRenderBHRingdown(){
    const c = hvEnsureCanvas(); if(!c) return;
    const ctx = c.getContext("2d");
    const N = HeavyViz.res;
    ctx.clearRect(0,0,N,N);

    const spin = HeavyViz.bh.spin||0;
    const f0 = 8 + 10*spin; // arbitrary units
    const tau = 1.2 - 0.6*spin;
    const now = performance.now()/1000;
    const t0 = HeavyViz._bhRD?.t0 || now;
    const t = now - t0;

    // waveform top half
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const tt = t + (i/N)*2.5; // show forward window
      const amp = Math.exp(-tt/tau);
      const w = Math.cos(2*Math.PI*f0*tt);
      const y = 0.25*N + (amp*w)*0.22*N;
      if(i===0) ctx.moveTo(i,y); else ctx.lineTo(i,y);
    }
    ctx.stroke();

    // spectrogram bottom half (cheap DFT of a few bins)
    const bins = 48;
    const seg = 128;
    for(let x=0;x<N;x+=4){
      const tseg = t + (x/N)*2.0;
      for(let b=0;b<bins;b++){
        const f = 2 + b*(22/bins);
        let re=0, im=0;
        for(let n=0;n<seg;n++){
          const tt = tseg + (n/seg)*0.35;
          const a = Math.exp(-tt/tau);
          const s = a*Math.cos(2*Math.PI*f0*tt);
          const ph = 2*Math.PI*f*(n/seg);
          re += s*Math.cos(ph);
          im -= s*Math.sin(ph);
        }
        const mag = Math.sqrt(re*re+im*im)/(seg);
        const v = Math.max(0, Math.min(1, mag*6));
        const yy = 0.55*N + (1-b/(bins-1))*0.42*N;
        ctx.globalAlpha = v;
        ctx.fillRect(x, yy, 4, (0.42*N)/bins + 1);
      }
    }
    ctx.globalAlpha = 1;
  }

  function hvStepBHRingdown(dt){
    if(!HeavyViz._bhNext || performance.now() > HeavyViz._bhNext){
      const interval = (HeavyViz.power==="low")?220 : (HeavyViz.power==="med")?160 : (HeavyViz.power==="high")?110 : 70;
      HeavyViz._bhNext = performance.now() + interval;
      hvRenderBHRingdown();
    }
  }

  function hvInitBHDisk(){
    hvSetInfo("Accretion disk turbulence: rotating, advected noise field (heavy).");
    const N = HeavyViz.res;
    const f = new Float32Array(N*N);
    const seed = hvBHSeed();
    const rnd = hvMulberry32(seed^0xa5a5a5a5);
    for(let i=0;i<f.length;i++) f[i] = rnd();
    HeavyViz._bhDisk = { f, t:0 };
    hvRenderBHDisk();
  }

  function hvRenderBHDisk(){
    const c = hvEnsureCanvas(); if(!c) return;
    const ctx = c.getContext("2d");
    const N = HeavyViz.res;
    const img = ctx.createImageData(N,N);

    const disk = HeavyViz._bhDisk;
    if(!disk) return;
    const f = disk.f;
    const t = disk.t;

    const cx = (N-1)/2, cy=(N-1)/2;
    const spin = HeavyViz.bh.spin||0;
    const w = 0.8 + 1.6*spin;

    for(let y=0;y<N;y++){
      const vy = (y-cy)/(N/2);
      for(let x=0;x<N;x++){
        const ux = (x-cx)/(N/2);
        const r = Math.sqrt(ux*ux+vy*vy)+1e-6;
        const th = Math.atan2(vy, ux);

        // rotate sampling coordinate backward to advect field
        const ang = -w*(0.6/(r+0.15))*t;
        const uu = r*Math.cos(th+ang);
        const vv = r*Math.sin(th+ang);

        let sx = Math.floor((uu*0.5+0.5)*N);
        let sy = Math.floor((vv*0.5+0.5)*N);
        sx = (sx%N+N)%N; sy=(sy%N+N)%N;
        const base = f[sy*N+sx] || 0;

        // disk ring mask + central shadow
        const shadow = r < 0.24 ? 0 : 1;
        const ring = Math.exp(-((r-0.55)*(r-0.55))/0.03) + 0.6*Math.exp(-((r-0.85)*(r-0.85))/0.02);
        let I = shadow * ring * (0.25 + 0.9*base);

        // photon ring highlight
        I += 0.45*Math.exp(-((r-(0.34+0.02*spin))*(r-(0.34+0.02*spin)))/0.0008);

        I = Math.max(0, Math.min(1, 1-Math.exp(-I*(HeavyViz.bh.scale||8)*0.22)));
        const v8 = (I*255)|0;
        const j=(y*N+x)*4;
        img.data[j]=v8; img.data[j+1]=v8; img.data[j+2]=v8; img.data[j+3]=255;
      }
    }

    ctx.putImageData(img,0,0);
  }

  function hvStepBHDisk(dt){
    if(HeavyViz._bhDisk) HeavyViz._bhDisk.t += dt;
    if(!HeavyViz._bhNext || performance.now() > HeavyViz._bhNext){
      const interval = (HeavyViz.power==="low")?180 : (HeavyViz.power==="med")?120 : (HeavyViz.power==="high")?85 : 55;
      HeavyViz._bhNext = performance.now() + interval;
      hvRenderBHDisk();
    }
  }
  // Called from compute: auto-start heavy viz if enabled; also feed camera crop as seed
  function hvOnComputeBegin(){
    const auto = !!$("hvAuto")?.checked;
    if(!auto) return;
    // start if not running
    if(!HeavyViz.running) hvVizStart({});
  }

  function hvOnComputeSeed(gray, N){
    if(!gray || !N) return;
    // only use seed if sizes match current res or if we can resample quickly
    hvReadUI();
    const targetN = HeavyViz.res;
    if(targetN===N){
      HeavyViz.seedGray = new Float32Array(gray);
    }else{
      // crude nearest resample
      const out = new Float32Array(targetN*targetN);
      for(let y=0;y<targetN;y++){
        const sy = Math.floor(y*(N/targetN));
        for(let x=0;x<targetN;x++){
          const sx = Math.floor(x*(N/targetN));
          out[y*targetN+x] = gray[sy*N+sx];
        }
      }
      HeavyViz.seedGray = out;
    }
  }

  async function aqcComputeFromCameraPaper(){
    
    panicVisible(true);
    const video = $("local");
    if(!video || !(video.videoWidth>0)) { log("Compute: local camera not running", true); return; }

    const N = parseInt($("ovCN")?.value || "256", 10);
    const roi = parseFloat($("ovRoi")?.value || "0.75");
    const thr = parseInt($("ovThresh")?.value || "140", 10);
    const invert = !!$("ovInvert")?.checked;
    const includeOverlay = !!$("ovInclOverlay")?.checked;
    const inputKind = $("ovInput")?.value || "gaussian";
    const maskDomain = $("ovMaskDomain")?.value || "fourier";

    if($("ovRoiLabel")) $("ovRoiLabel").textContent = roi.toFixed(2)+"×";
    if($("ovThreshLabel")) $("ovThreshLabel").textContent = String(thr);

    AQC.computeBusy = true;
    setQuantumComputingActive(true);
    aqcApplyOverlayState();
    hvOnComputeBegin();
    setStatusToast("compute: capturing");

    try{
      await aqcEnsureTf();
      const tf = window.tf;
      await tf.setBackend("webgl").catch(()=>{});
      await tf.ready();
      await tf.nextFrame?.().catch(()=>{});

      // capture crop
      const cap = document.createElement("canvas");
      getVideoCropToCanvas(video, cap, N, roi, includeOverlay);
      const ctx = cap.getContext("2d");
      const img = ctx.getImageData(0,0,N,N);

      // render observed
      const gray = imageDataToGrayFloat(img);
      renderScalarToCanvas($("ovObs"), gray, N, false);
      hvOnComputeSeed(gray, N);
      if(RUNCTL.computeAbort) throw new Error("aborted");
      await tf.nextFrame?.().catch(()=>{});

      // camera FFT magnitude
      const fftMag = await tf.tidy(()=>{
        const x = tf.tensor2d(gray, [N,N], "float32");
        const xm = x.sub(x.mean()); // remove DC
        const z = tf.complex(xm, tf.zerosLike(xm));
        const F = tfFFT2(z);
        const mag = tf.abs(F);
        return mag;
      }).data();
      renderScalarToCanvas($("ovFFT"), fftMag, N, true);
      setStatusToast("compute: predicting");
      if(RUNCTL.computeAbort) throw new Error("aborted");
      await tf.nextFrame?.().catch(()=>{});

      // mask from thresholded drawing
      const maskArr = grayToMask(gray, thr, invert);
      // 4f prediction
      const predMag = await tf.tidy(()=>{
        const input = makeInputField(N, inputKind);
        const mask = tf.tensor2d(maskArr, [N,N], "float32");
        if(maskDomain==="fourier"){
          const F = tfFFT2(input);
          const Fm = tf.complex(mask, tf.zerosLike(mask));
          const G = F.mul(Fm);
          const out = tfIFFT2(G);
          return tf.abs(out).square(); // intensity
        }else{
          // object aperture then far-field
          const A = tf.complex(mask, tf.zerosLike(mask));
          const obj = input.mul(A);
          const F = tfFFT2(obj);
          return tf.abs(F).square();
        }
      }).data();

      renderScalarToCanvas($("ovPred"), predMag, N, true);

      // metrics
      const peaks = scalarTopKPeaks(fftMag, N, 8);
      const peakStr = peaks.map(p=>`(${p.x},${p.y})`).join(", ");
      const lay = LayoutLib.find(x=>x.id===AQC.layoutId);
      const hint = (lay?.cat==="lattices") ? "Lattice: expect 6-fold peaks." :
                   (lay?.id?.includes("slit") || lay?.id?.includes("grating")) ? "Slits/grating: expect line of diffraction orders." :
                   (lay?.cat==="vortex") ? "Vortex: expect ring-like spectrum + central null." : "Use peaks + symmetry as signature.";

      if($("ovComputeInfo")){
        $("ovComputeInfo").innerHTML =
          `<b>FFT peaks (top)</b>: ${peakStr}<br/>`+
          `<b>Mask</b>: thr=${thr} invert=${invert} domain=${maskDomain} input=${inputKind}<br/>`+
          `<b>Hint</b>: ${hint}`;
      }
      if($("ovComputeDetails")) $("ovComputeDetails").open = true;
    }catch(e){
      log("Compute failed: " + (e?.message || e), true);
      if($("ovComputeInfo")) $("ovComputeInfo").textContent = "Compute failed: " + (e?.message || e);
    }finally{
      setStatusToast("ready");
      RUNCTL.computeAbort = false;
      AQC.computeBusy = false;
      setQuantumComputingActive(false);
      aqcApplyOverlayState();
    }
  }

  // Hook new UI controls
  (function(){
    if($("hvStart")) {
      const _hvStartHandler = (ev)=>{ try{ ev?.preventDefault?.(); ev?.stopPropagation?.(); hvVizStart({}); } catch(e){ hvSetState("error"); hvSetInfo("Start failed: "+(e?.message||e)); log("HeavyViz start failed: "+(e?.stack||e), true);} };
      $("hvStart").onclick = _hvStartHandler;
      $("hvStart").addEventListener("touchstart", _hvStartHandler, {passive:false});
      $("hvStart").addEventListener("pointerdown", _hvStartHandler);
    }
    if($("hvStop")) {
      const _hvStopHandler = (ev)=>{ try{ ev?.preventDefault?.(); ev?.stopPropagation?.(); hvVizStop(); } catch(e){ log("HeavyViz stop failed: "+(e?.stack||e), true);} };
      $("hvStop").onclick = _hvStopHandler;
      $("hvStop").addEventListener("touchstart", _hvStopHandler, {passive:false});
      $("hvStop").addEventListener("pointerdown", _hvStopHandler);
    }
    if($("hvMode")) $("hvMode").onchange = ()=> { if(HeavyViz.running){ hvVizStart({seedGray:HeavyViz.seedGray}); } };
    if($("hvRes")) $("hvRes").onchange = ()=> { if(HeavyViz.running){ hvVizStart({seedGray:HeavyViz.seedGray}); } };
    if($("hvPower")) $("hvPower").onchange = ()=> { /* applied next frame */ };

    if($("ovMore")) $("ovMore").onclick = ()=> { setActiveTab("layouts"); layoutsBuildGrid(); layoutsRenderPreview(); };
    if($("ovCompute")) $("ovCompute").onclick = ()=> { RUNCTL.computeAbort=false; aqcComputeFromCameraPaper(); };
    if($("ovComputeStop")) $("ovComputeStop").onclick = ()=> { stopAllNow("compute stop"); };
    if($("layoutsOpenOverlay")) $("layoutsOpenOverlay").onclick = ()=> { setActiveTab("trx"); aqcTogglePanel(true); };
    if($("layoutsApply")) $("layoutsApply").onclick = ()=> { setActiveTab("trx"); layoutsApplyToCamera(); };
    if($("layoutsCompute")) $("layoutsCompute").onclick = ()=> { setActiveTab("trx"); aqcTogglePanel(true); setTimeout(()=> aqcComputeFromCameraPaper(), 120); };
    if($("layoutsSearch")) $("layoutsSearch").oninput = ()=> layoutsBuildGrid();
    if($("layoutsCategory")) $("layoutsCategory").onchange = ()=> layoutsBuildGrid();
    if($("ovRoi")) $("ovRoi").oninput = (e)=> { if($("ovRoiLabel")) $("ovRoiLabel").textContent = parseFloat(e.target.value).toFixed(2)+"×"; };
    if($("ovThresh")) $("ovThresh").oninput = (e)=> { if($("ovThreshLabel")) $("ovThreshLabel").textContent = String(parseInt(e.target.value,10)); };
  })();


  // Debug: show last clicked control in toast (doesn't steal events)
  document.addEventListener("click", (e)=>{
    const t = e.target && (e.target.closest?.("button,summary,a,input,select") || e.target);
    const id = t && (t.id || t.getAttribute?.("id") || t.getAttribute?.("name") || t.tagName);
    if(id) setStatusToast("tap: " + id);
    setTimeout(()=>{ if(!RUNCTL.stopAll) setStatusToast("ready"); }, 650);
  }, true);

})();
</script>
</body>
</html>
