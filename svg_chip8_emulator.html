<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SVG UI + CHIP-8 Emulator (Single File)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    /* Layout: screen on top, controls below */
    #app {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Top area */
    #top {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: start;
    }
    #screenWrap{
      background:#06070a;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      gap: 8px;
      align-content: start;
    }
    #hud {
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      color: rgba(255,255,255,.85);
      font-size: 13px;
    }
    #hud .left, #hud .right { display:flex; flex-wrap: wrap; gap:8px; align-items:center; }
    #hud button, #hud label {
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 13px;
    }
    #hud button { cursor:pointer; }
    #hud button:active { transform: translateY(1px); }
    #hud input[type="range"] { width: 160px; }
    #file { display:none; }
    #status { opacity:.85; }
    /* Canvas: pixel perfect */
    #screen {
      width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display:block;
      touch-action: none;
    }
    /* Sidebar cheatsheet */
    #sidebar{
      min-width: 220px;
      max-width: 260px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 10px;
      box-sizing: border-box;
      color: rgba(255,255,255,.85);
      font-size: 13px;
      line-height: 1.35;
    }
    #sidebar h3{ margin:0 0 8px 0; font-size: 14px; color: rgba(255,255,255,.92); }
    #sidebar code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; color: rgba(255,255,255,.92); }
    /* Bottom controls SVG */
    #controlsWrap{
      background:#06070a;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: none; /* important: stop browser gestures eating taps */
    }
    #controls {
      width: 100%;
      height: 100%;
      display:block;
    }
    .key { cursor: pointer; }
    .key .cap { fill: rgba(255,255,255,.07); stroke: rgba(255,255,255,.18); stroke-width: 2; }
    .key .label { fill: rgba(255,255,255,.92); font-size: 22px; font-weight: 700; dominant-baseline: middle; text-anchor: middle; }
    .key.pressed .cap { fill: rgba(255,255,255,.18); }
    .key .hit { fill: transparent; pointer-events: all; } /* reliable touch target */
    /* Mobile: reduce sidebar */
    @media (max-width: 860px){
      #top { grid-template-columns: 1fr; }
      #sidebar { max-width: none; }
      #hud { gap: 6px; }
      #hud input[type="range"] { width: 120px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="top">
      <div id="screenWrap">
        <div id="hud">
          <div class="left">
            <button id="btnRun">Run</button>
            <button id="btnReset">Reset</button>
            <button id="btnLoad">Load ROM</button>
            <input id="file" type="file" accept=".ch8,.rom,.bin,application/octet-stream" />
            <label title="CPU speed (instructions/sec)">
              Speed
              <input id="speed" type="range" min="100" max="1500" step="50" value="700" />
            </label>
          </div>
          <div class="right">
            <button id="btnFS">Fullscreen</button>
            <span id="status">Ready (built-in demo loaded)</span>
          </div>
        </div>
        <canvas id="screen" width="64" height="32"></canvas>
      </div>

      <aside id="sidebar">
        <h3>Keyboard mapping</h3>
        <div style="opacity:.9">
          CHIP‑8 uses a 4×4 keypad:
          <pre style="margin:8px 0; padding:8px; background:rgba(255,255,255,.04); border-radius:12px; border:1px solid rgba(255,255,255,.12); overflow:auto;">
1 2 3 C
4 5 6 D
7 8 9 E
A 0 B F</pre>
          This page maps:
          <pre style="margin:8px 0; padding:8px; background:rgba(255,255,255,.04); border-radius:12px; border:1px solid rgba(255,255,255,.12); overflow:auto;">
1 2 3 4
Q W E R
A S D F
Z X C V</pre>
          So <code>X</code> is key <code>0</code>, <code>V</code> is <code>F</code>, etc.
        </div>
        <div style="margin-top:10px; opacity:.85">
          Notes:
          <ul style="margin:6px 0 0 18px; padding:0">
            <li>Buttons are SVG (pointer events), sized for touch.</li>
            <li>No ROMs included. Load your own legal .ch8 ROM.</li>
          </ul>
        </div>
      </aside>
    </div>

    <div id="controlsWrap">
      <!-- SVG controls: big touch targets + reliable pointer events -->
      <svg id="controls" viewBox="0 0 1200 420" preserveAspectRatio="xMidYMid meet" aria-label="CHIP-8 keypad">
        <rect x="0" y="0" width="1200" height="420" fill="#06070a"></rect>

        <text x="60" y="55" fill="rgba(255,255,255,.70)" font-size="18" font-weight="700">Touch keypad</text>
        <text x="60" y="85" fill="rgba(255,255,255,.55)" font-size="14">Tap/hold. Works on phone + desktop.</text>

        <!-- Key grid (4x4) -->
        <g id="keys" transform="translate(60,120)">
          <!-- generated by JS for less boilerplate -->
        </g>

        <!-- A couple of "utility" big keys -->
        <g transform="translate(820,120)">
          <g class="key" data-key="F">
            <rect class="cap" x="0" y="0" width="300" height="90" rx="18"></rect>
            <text class="label" x="150" y="45">F</text>
            <rect class="hit" x="-8" y="-8" width="316" height="106" rx="22"></rect>
          </g>
          <text x="0" y="125" fill="rgba(255,255,255,.55)" font-size="14">Some ROMs use F / B / A a lot.</text>

          <g class="key" data-key="0" transform="translate(0,170)">
            <rect class="cap" x="0" y="0" width="300" height="90" rx="18"></rect>
            <text class="label" x="150" y="45">0</text>
            <rect class="hit" x="-8" y="-8" width="316" height="106" rx="22"></rect>
          </g>
          <text x="0" y="295" fill="rgba(255,255,255,.55)" font-size="14">0 is often the “main” button.</text>
        </g>
      </svg>
    </div>
  </div>

<script>
/* =========================
   1) SVG keypad generator
   ========================= */
const keyLayout = [
  ["1","2","3","C"],
  ["4","5","6","D"],
  ["7","8","9","E"],
  ["A","0","B","F"],
];

(function buildKeypad(){
  const g = document.getElementById("keys");
  const w = 150, h = 90, gap = 18, rx = 18;
  for (let r=0; r<4; r++){
    for (let c=0; c<4; c++){
      const k = keyLayout[r][c];
      const x = c*(w+gap), y = r*(h+gap);
      const key = document.createElementNS("http://www.w3.org/2000/svg","g");
      key.setAttribute("class","key");
      key.dataset.key = k;

      const cap = document.createElementNS("http://www.w3.org/2000/svg","rect");
      cap.setAttribute("class","cap");
      cap.setAttribute("x", x);
      cap.setAttribute("y", y);
      cap.setAttribute("width", w);
      cap.setAttribute("height", h);
      cap.setAttribute("rx", rx);

      const label = document.createElementNS("http://www.w3.org/2000/svg","text");
      label.setAttribute("class","label");
      label.setAttribute("x", x + w/2);
      label.setAttribute("y", y + h/2);
      label.textContent = k;

      const hit = document.createElementNS("http://www.w3.org/2000/svg","rect");
      hit.setAttribute("class","hit");
      hit.setAttribute("x", x-8);
      hit.setAttribute("y", y-8);
      hit.setAttribute("width", w+16);
      hit.setAttribute("height", h+16);
      hit.setAttribute("rx", rx+4);

      key.appendChild(cap);
      key.appendChild(label);
      key.appendChild(hit);
      g.appendChild(key);
    }
  }
})();

/* =========================
   2) CHIP-8 Emulator core
   ========================= */
class Chip8 {
  constructor(){
    this.reset();
  }

  reset(){
    this.mem = new Uint8Array(4096);
    this.V = new Uint8Array(16);
    this.I = 0;
    this.pc = 0x200;
    this.stack = new Uint16Array(16);
    this.sp = 0;
    this.delayTimer = 0;
    this.soundTimer = 0;
    this.keys = new Array(16).fill(false);
    this.display = new Uint8Array(64*32); // 0/1
    this.drawFlag = true;
    this.waitingForKey = false;
    this.waitReg = 0;

    // Standard CHIP-8 fontset (0-F), 5 bytes per character
    const font = [
      0xF0,0x90,0x90,0x90,0xF0, // 0
      0x20,0x60,0x20,0x20,0x70, // 1
      0xF0,0x10,0xF0,0x80,0xF0, // 2
      0xF0,0x10,0xF0,0x10,0xF0, // 3
      0x90,0x90,0xF0,0x10,0x10, // 4
      0xF0,0x80,0xF0,0x10,0xF0, // 5
      0xF0,0x80,0xF0,0x90,0xF0, // 6
      0xF0,0x10,0x20,0x40,0x40, // 7
      0xF0,0x90,0xF0,0x90,0xF0, // 8
      0xF0,0x90,0xF0,0x10,0xF0, // 9
      0xF0,0x90,0xF0,0x90,0x90, // A
      0xE0,0x90,0xE0,0x90,0xE0, // B
      0xF0,0x80,0x80,0x80,0xF0, // C
      0xE0,0x90,0x90,0x90,0xE0, // D
      0xF0,0x80,0xF0,0x80,0xF0, // E
      0xF0,0x80,0xF0,0x80,0x80  // F
    ];
    const fontStart = 0x50;
    for (let i=0;i<font.length;i++) this.mem[fontStart+i]=font[i];

    this.rngBuf = new Uint8Array(1);
  }

  loadRom(bytes){
    this.reset();
    const max = Math.min(bytes.length, 4096-0x200);
    this.mem.set(bytes.slice(0,max), 0x200);
    this.pc = 0x200;
    this.drawFlag = true;
  }

  randByte(){
    // Better than Math.random() and available on mobile.
    crypto.getRandomValues(this.rngBuf);
    return this.rngBuf[0];
  }

  tick(){
    if (this.waitingForKey) return; // CPU halted until key press

    const op = (this.mem[this.pc] << 8) | this.mem[this.pc + 1];
    this.pc = (this.pc + 2) & 0xFFF;

    const nnn = op & 0x0FFF;
    const kk  = op & 0x00FF;
    const n   = op & 0x000F;
    const x   = (op >> 8) & 0x0F;
    const y   = (op >> 4) & 0x0F;

    switch (op & 0xF000){
      case 0x0000:
        if (op === 0x00E0){ // CLS
          this.display.fill(0);
          this.drawFlag = true;
        } else if (op === 0x00EE){ // RET
          this.sp = (this.sp - 1) & 0xF;
          this.pc = this.stack[this.sp];
        } else {
          // 0NNN (ignored on most modern interpreters)
        }
        break;

      case 0x1000: // JP addr
        this.pc = nnn;
        break;

      case 0x2000: // CALL addr
        this.stack[this.sp] = this.pc;
        this.sp = (this.sp + 1) & 0xF;
        this.pc = nnn;
        break;

      case 0x3000: // SE Vx, byte
        if (this.V[x] === kk) this.pc = (this.pc + 2) & 0xFFF;
        break;

      case 0x4000: // SNE Vx, byte
        if (this.V[x] !== kk) this.pc = (this.pc + 2) & 0xFFF;
        break;

      case 0x5000: // SE Vx, Vy (5XY0)
        if ((op & 0x000F) === 0 && this.V[x] === this.V[y]) this.pc = (this.pc + 2) & 0xFFF;
        break;

      case 0x6000: // LD Vx, byte
        this.V[x] = kk;
        break;

      case 0x7000: // ADD Vx, byte
        this.V[x] = (this.V[x] + kk) & 0xFF;
        break;

      case 0x8000:
        switch (op & 0x000F){
          case 0x0: this.V[x] = this.V[y]; break;                // LD Vx, Vy
          case 0x1: this.V[x] |= this.V[y]; break;               // OR
          case 0x2: this.V[x] &= this.V[y]; break;               // AND
          case 0x3: this.V[x] ^= this.V[y]; break;               // XOR
          case 0x4: {                                            // ADD Vx, Vy
            const sum = this.V[x] + this.V[y];
            this.V[0xF] = sum > 0xFF ? 1 : 0;
            this.V[x] = sum & 0xFF;
            break;
          }
          case 0x5: {                                            // SUB Vx, Vy
            this.V[0xF] = this.V[x] >= this.V[y] ? 1 : 0;
            this.V[x] = (this.V[x] - this.V[y]) & 0xFF;
            break;
          }
          case 0x6: {                                            // SHR Vx {, Vy}
            this.V[0xF] = this.V[x] & 0x1;
            this.V[x] = (this.V[x] >> 1) & 0xFF;
            break;
          }
          case 0x7: {                                            // SUBN Vx, Vy
            this.V[0xF] = this.V[y] >= this.V[x] ? 1 : 0;
            this.V[x] = (this.V[y] - this.V[x]) & 0xFF;
            break;
          }
          case 0xE: {                                            // SHL Vx {, Vy}
            this.V[0xF] = (this.V[x] >> 7) & 0x1;
            this.V[x] = (this.V[x] << 1) & 0xFF;
            break;
          }
        }
        break;

      case 0x9000: // SNE Vx, Vy (9XY0)
        if ((op & 0x000F) === 0 && this.V[x] !== this.V[y]) this.pc = (this.pc + 2) & 0xFFF;
        break;

      case 0xA000: // LD I, addr
        this.I = nnn;
        break;

      case 0xB000: // JP V0, addr
        this.pc = (nnn + this.V[0]) & 0xFFF;
        break;

      case 0xC000: // RND Vx, byte
        this.V[x] = this.randByte() & kk;
        break;

      case 0xD000: { // DRW Vx, Vy, nibble
        const vx = this.V[x] & 63;
        const vy = this.V[y] & 31;
        this.V[0xF] = 0;
        for (let row=0; row<n; row++){
          const sprite = this.mem[(this.I + row) & 0xFFF];
          for (let col=0; col<8; col++){
            if ((sprite & (0x80 >> col)) !== 0){
              const px = (vx + col) & 63;
              const py = (vy + row) & 31;
              const idx = py*64 + px;
              if (this.display[idx] === 1) this.V[0xF] = 1;
              this.display[idx] ^= 1;
            }
          }
        }
        this.drawFlag = true;
        break;
      }

      case 0xE000:
        if (kk === 0x9E){ // SKP Vx
          if (this.keys[this.V[x] & 0xF]) this.pc = (this.pc + 2) & 0xFFF;
        } else if (kk === 0xA1){ // SKNP Vx
          if (!this.keys[this.V[x] & 0xF]) this.pc = (this.pc + 2) & 0xFFF;
        }
        break;

      case 0xF000:
        switch (kk){
          case 0x07: this.V[x] = this.delayTimer & 0xFF; break;         // LD Vx, DT
          case 0x0A: {                                                  // LD Vx, K
            this.waitingForKey = true;
            this.waitReg = x;
            break;
          }
          case 0x15: this.delayTimer = this.V[x] & 0xFF; break;         // LD DT, Vx
          case 0x18: this.soundTimer = this.V[x] & 0xFF; break;         // LD ST, Vx
          case 0x1E: this.I = (this.I + this.V[x]) & 0xFFF; break;      // ADD I, Vx
          case 0x29: this.I = 0x50 + (this.V[x] & 0xF) * 5; break;      // LD F, Vx
          case 0x33: {                                                  // LD B, Vx
            const v = this.V[x];
            this.mem[this.I] = Math.floor(v / 100);
            this.mem[(this.I + 1) & 0xFFF] = Math.floor((v % 100) / 10);
            this.mem[(this.I + 2) & 0xFFF] = v % 10;
            break;
          }
          case 0x55:                                                    // LD [I], V0..Vx
            for (let i=0;i<=x;i++) this.mem[(this.I + i) & 0xFFF] = this.V[i];
            break;
          case 0x65:                                                    // LD V0..Vx, [I]
            for (let i=0;i<=x;i++) this.V[i] = this.mem[(this.I + i) & 0xFFF];
            break;
        }
        break;
    }
  }

  setKey(keyIndex, isDown){
    this.keys[keyIndex & 0xF] = !!isDown;
    if (this.waitingForKey && isDown){
      this.V[this.waitReg] = keyIndex & 0xF;
      this.waitingForKey = false;
    }
  }

  timersTick(){
    if (this.delayTimer > 0) this.delayTimer--;
    if (this.soundTimer > 0) this.soundTimer--;
  }
}

/* =========================
   3) Renderer + main loop
   ========================= */
const chip8 = new Chip8();
const canvas = document.getElementById("screen");
const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });

function render(){
  // Paint 64x32 -> canvas (64x32). Then CSS scales it pixel-perfect.
  const img = ctx.createImageData(64, 32);
  const data = img.data;
  for (let i=0;i<64*32;i++){
    const on = chip8.display[i] ? 255 : 0;
    const j = i*4;
    data[j] = on; data[j+1] = on; data[j+2] = on; data[j+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

let running = false;
let speedIPS = 700; // instructions/sec
let last = performance.now();
let cpuAcc = 0;
let timerAcc = 0;

function frame(now){
  const dt = Math.min(0.05, (now - last) / 1000); // cap to avoid giant jumps
  last = now;

  if (running){
    cpuAcc += dt * speedIPS;
    const steps = Math.floor(cpuAcc);
    cpuAcc -= steps;
    for (let i=0;i<steps;i++) chip8.tick();

    timerAcc += dt;
    while (timerAcc >= 1/60){
      chip8.timersTick();
      timerAcc -= 1/60;
    }
  }

  if (chip8.drawFlag){
    chip8.drawFlag = false;
    render();
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* =========================
   4) Input (keyboard + SVG touch)
   ========================= */
const keyMap = new Map([
  ["1",0x1],["2",0x2],["3",0x3],["4",0xC],
  ["q",0x4],["w",0x5],["e",0x6],["r",0xD],
  ["a",0x7],["s",0x8],["d",0x9],["f",0xE],
  ["z",0xA],["x",0x0],["c",0xB],["v",0xF]
]);

window.addEventListener("keydown", (e)=>{
  const k = e.key;
  if (k === " "){ e.preventDefault(); toggleRun(); return; }
  const idx = keyMap.get(k) ?? keyMap.get(k.toLowerCase());
  if (idx !== undefined){
    e.preventDefault();
    chip8.setKey(idx, true);
    setPressed(idx, true);
  }
}, { passive:false });

window.addEventListener("keyup", (e)=>{
  const idx = keyMap.get(e.key) ?? keyMap.get(e.key.toLowerCase());
  if (idx !== undefined){
    e.preventDefault();
    chip8.setKey(idx, false);
    setPressed(idx, false);
  }
}, { passive:false });

// SVG touch buttons (Pointer Events)
const svg = document.getElementById("controls");
const pressed = new Set();

function hexToIdx(h){
  // h is "0".."9","A".."F","B","C","D","E","F"
  return parseInt(h, 16) & 0xF;
}

function setPressed(idx, isDown){
  // Update SVG class based on data-key
  const hex = idx.toString(16).toUpperCase();
  document.querySelectorAll(`.key[data-key="${hex}"]`).forEach(el=>{
    el.classList.toggle("pressed", !!isDown);
  });
}

function onDown(el, pointerId){
  const key = el.dataset.key;
  const idx = hexToIdx(key);
  pressed.add(pointerId);
  el.setPointerCapture(pointerId);
  chip8.setKey(idx, true);
  setPressed(idx, true);
}

function onUp(el, pointerId){
  const key = el.dataset.key;
  const idx = hexToIdx(key);
  pressed.delete(pointerId);
  chip8.setKey(idx, false);
  setPressed(idx, false);
}

svg.querySelectorAll(".key").forEach(el=>{
  el.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    onDown(el, e.pointerId);
  }, { passive:false });

  el.addEventListener("pointerup", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    onUp(el, e.pointerId);
  }, { passive:false });

  el.addEventListener("pointercancel", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    onUp(el, e.pointerId);
  }, { passive:false });

  el.addEventListener("pointerleave", (e)=>{
    // If finger slides off while held, treat as release
    if (e.buttons === 0) return;
    onUp(el, e.pointerId);
  }, { passive:false });
});

/* =========================
   5) UI actions
   ========================= */
const statusEl = document.getElementById("status");
const btnRun = document.getElementById("btnRun");
const btnReset = document.getElementById("btnReset");
const btnLoad = document.getElementById("btnLoad");
const fileEl = document.getElementById("file");
const speedEl = document.getElementById("speed");
const btnFS = document.getElementById("btnFS");

function setStatus(msg){ statusEl.textContent = msg; }

function toggleRun(){
  running = !running;
  btnRun.textContent = running ? "Pause" : "Run";
  setStatus(running ? "Running" : "Paused");
}

btnRun.addEventListener("click", toggleRun);

btnReset.addEventListener("click", ()=>{
  chip8.loadRom(builtinDemo());
  render();
  setStatus("Reset (built-in demo loaded)");
});

btnLoad.addEventListener("click", ()=> fileEl.click());

fileEl.addEventListener("change", async ()=>{
  const f = fileEl.files && fileEl.files[0];
  if (!f) return;
  const buf = new Uint8Array(await f.arrayBuffer());
  chip8.loadRom(buf);
  render();
  running = true;
  btnRun.textContent = "Pause";
  setStatus(`Loaded: ${f.name}`);
  fileEl.value = "";
});

speedEl.addEventListener("input", ()=>{
  speedIPS = Number(speedEl.value);
  setStatus(`Speed: ${speedIPS} IPS`);
});

btnFS.addEventListener("click", async ()=>{
  const el = document.documentElement;
  try{
    if (!document.fullscreenElement) await el.requestFullscreen();
    else await document.exitFullscreen();
  }catch(_){
    // ignore
  }
});

// Ensure canvas stays sharp and sized nicely
function resizeCanvasCSS(){
  // Keep aspect ratio 64:32 = 2:1. Choose a friendly size based on container width.
  const wrap = document.getElementById("screenWrap");
  const w = wrap.clientWidth - 22; // padding+border-ish
  const targetW = Math.max(256, Math.min(w, 900));
  canvas.style.width = targetW + "px";
  canvas.style.height = (targetW/2) + "px";
}
window.addEventListener("resize", resizeCanvasCSS);
resizeCanvasCSS();

/* =========================
   6) Built-in demo ROM (authored here)
   ========================= */
function builtinDemo(){
  // Tiny program that moves a "0" sprite across the screen.
  // 0x200: 00E0 CLS
  // 0x202: 6100 V1=0
  // 0x204: 620C V2=12
  // 0x206: A216 I=0x216 (sprite)
  // 0x208: 00E0 CLS
  // 0x20A: D125 DRW V1,V2,5
  // 0x20C: 7101 V1 += 1
  // 0x20E: 3120 SE V1,0x20 (if V1==32 skip next)
  // 0x210: 1208 JP 0x208
  // 0x212: 6100 V1=0
  // 0x214: 1208 JP 0x208
  // 0x216: F0 90 90 90 F0 (sprite for '0')
  return new Uint8Array([
    0x00,0xE0,
    0x61,0x00,
    0x62,0x0C,
    0xA2,0x16,
    0x00,0xE0,
    0xD1,0x25,
    0x71,0x01,
    0x31,0x20,
    0x12,0x08,
    0x61,0x00,
    0x12,0x08,
    0xF0,0x90,0x90,0x90,0xF0
  ]);
}

// Boot demo
chip8.loadRom(builtinDemo());
render();
</script>
</body>
</html>
