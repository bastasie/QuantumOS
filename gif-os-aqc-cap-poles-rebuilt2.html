<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta name="theme-color" content="#0b0b0b"/>
  <title>GIF‑OS Prototype (Single‑File)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#070707; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow:hidden; }
    * { box-sizing: border-box; }

    #wrap { position:fixed; inset:0; display:flex; flex-direction:column; padding:max(10px, env(safe-area-inset-top)) 10px max(10px, env(safe-area-inset-bottom)); gap:10px; }
    .bar {
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:18px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
    }
    .bar h1 { margin:0; font-size:14px; font-weight:950; opacity:0.95; }
    .bar .hint { margin-left:auto; font-size:12px; opacity:0.70; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 60vw; }

    button, input[type="text"] {
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.42);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.92);
      padding: 10px 10px;
      border-radius: 16px;
      font-weight: 850;
      font-size: 13px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      outline:none;
    }
    button:active { transform: translateY(1px); background: rgba(255,255,255,0.09); }
    .btnSmall { padding: 9px 10px; border-radius: 14px; font-size: 12px; }

    #main {
      flex:1; min-height:0;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:10px;
    }
    .card {
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.46);
      backdrop-filter: blur(12px);
      padding: 12px;
      min-height:0;
      overflow:hidden;
    }

    #screenCard { display:flex; flex-direction:column; gap:10px; }
    #screenWrap { flex:1; min-height:0; display:grid; place-items:center; border-radius: 18px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.35); }
    #screen {
      width: min(92vw, 980px);
      height: auto;
      image-rendering: pixelated;
      border-radius: 16px;
      background: #000;
      touch-action: none; /* we handle */
    }

    #panel { display:flex; flex-direction:column; gap:10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      opacity:0.84;
      display:flex;
      gap:8px;
      align-items:center;
    }
    #log {
      flex:1; min-height:0;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.30);
      padding: 10px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.35;
      opacity:0.92;
    }

    #toast {
      position: fixed;
      left: 50%;
      bottom: calc(10px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
      font-size: 12px;
      opacity: 0;
      transition: opacity 180ms ease;
      pointer-events:none;
      max-width: 92vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      z-index: 50;
    }
    #toast.show { opacity: 0.88; }

    @media (max-width: 980px) {
      #main { grid-template-columns: 1fr; }
      #screen { width: min(94vw, 720px); }
    }
  
    /* Overlay WebApp windows (DOM, above the pixel screen) */
    #webWindows{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
    }
    .webwin{
      position: absolute;
      width: min(980px, calc(100vw - 24px));
      height: min(720px, calc(100vh - 24px));
      left: 12px;
      top: 12px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
    }
    .webwinHeader{
      display:flex; gap:10px; align-items:center;
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.35);
      user-select:none;
      cursor: grab;
      touch-action: none;
    }
    .webwinHeader:active{ cursor: grabbing; }
    .webwinTitle{
      font-weight: 950;
      font-size: 13px;
      opacity: 0.95;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 65vw;
    }
    .webwinBtns{ margin-left:auto; display:flex; gap:8px; align-items:center; }
    .webbtn{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      padding: 8px 10px;
      border-radius: 14px;
      font-weight: 950;
      font-size: 12px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      cursor:pointer;
    }
    .webbtn:active{ transform: translateY(1px); background: rgba(255,255,255,0.10); }
    .webwinBody{ flex:1; min-height:0; background: rgba(0,0,0,0.35); }
    .webwin iframe{ width:100%; height:100%; border:0; background: transparent; }

</style>
</head>
<body>
  <div id="wrap">
    <div class="bar">
      <h1>GIF‑OS Prototype</h1>
      <div class="hint">Tile/PPU‑style renderer • delta updates • optional GIF recorder</div>
      <button id="btnHelp" class="btnSmall">?</button>
    </div>

    <div id="main">
      <div id="screenCard" class="card">
        <div class="row">
          <button id="btnBoot">Boot</button>
          <button id="btnReset" class="btnSmall">Reset</button>
          <button id="btnLoadApps" class="btnSmall">Load Apps</button>
          <div class="pill"><span>FPS</span><span id="fps">—</span></div>
          <div class="pill"><span>Dirty tiles</span><span id="dirty">—</span></div>
          <div class="pill"><span>Recorder</span><span id="rec">idle</span></div>
          <button id="btnRec" class="btnSmall">Record</button>
          <button id="btnStop" class="btnSmall">Stop</button>
          <button id="btnExport" class="btnSmall">Export GIF</button>
        </div>
        <div id="screenWrap">
          <canvas id="screen" width="256" height="144" aria-label="GIF OS screen"></canvas>
        </div>
        <div style="font-size:12px; opacity:0.74; line-height:1.35;">
          Tip: open this file directly in Chrome (not a “content:// viewer”), then tap the screen to interact.
          Start button is bottom-left inside the pixel screen (menu includes Load Apps). Drag the window bar to move.
        </div>
      </div>

      <div id="panel" class="card">
        <div class="row">
          <div class="pill">Build from scratch: PPU tile engine → paletted framebuffer → GIF frames</div>
        </div>
        <div class="row">
          <button id="btnDemo" class="btnSmall">Demo: animate</button>
          <button id="btnAQC" class="btnSmall">Open AQC Lab</button>
          <button id="btnNotepad" class="btnSmall">Open Notepad</button>
          <button id="btnAbout" class="btnSmall">About</button>
        </div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="webWindows" aria-label="Web app windows"></div>

<script>
(() => {
  // ============================================================
  // 0) Utilities
  // ============================================================
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const toastEl = $("toast");
  function log(msg) {
    const t = new Date().toLocaleTimeString();
    const div = document.createElement("div");
    div.textContent = `[${t}] ${msg}`;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function toast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(() => toastEl.classList.remove("show"), 1100);
  }

  // Built-in: BAZ AQC Lab (base64 to keep the OS script syntax-safe)
  const AQC_LAB_HTML_B64 = "PCFkb2N0eXBlIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CjxtZXRhIGNoYXJzZXQ9InV0Zi04Ii8+CjxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgdmlld3BvcnQtZml0PWNvdmVyIi8+CjxtZXRhIG5hbWU9InRoZW1lLWNvbG9yIiBjb250ZW50PSIjMGIwYjBiIi8+Cjx0aXRsZT5CQVogQVFDIExhYjwvdGl0bGU+CjxzdHlsZT4KICA6cm9vdHsgY29sb3Itc2NoZW1lOiBkYXJrOyB9CiAgaHRtbCxib2R5eyBtYXJnaW46MDsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQ6IzA3MDcwNzsgY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwwLjkyKTsKICAgIGZvbnQtZmFtaWx5OiBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIFNlZ29lIFVJLCBSb2JvdG8sIEFyaWFsLCBzYW5zLXNlcmlmOyBvdmVyZmxvdzpoaWRkZW47IH0KICAqeyBib3gtc2l6aW5nOmJvcmRlci1ib3g7IH0KICAjd3JhcHsgcG9zaXRpb246Zml4ZWQ7IGluc2V0OjA7IGRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDsgcGFkZGluZzoxMnB4OyB9CiAgLmJhcnsgZGlzcGxheTpmbGV4OyBnYXA6MTBweDsgYWxpZ24taXRlbXM6Y2VudGVyOyBmbGV4LXdyYXA6d3JhcDsKICAgIHBhZGRpbmc6MTBweCAxMnB4OyBib3JkZXItcmFkaXVzOjE4cHg7IGJvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEyKTsKICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC41NSk7IGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTsgfQogIC50aXRsZXsgZm9udC13ZWlnaHQ6OTUwOyBsZXR0ZXItc3BhY2luZzowLjJweDsgfQogIHNlbGVjdCwgYnV0dG9uLCBpbnB1dFt0eXBlPSJyYW5nZSJdLCBpbnB1dFt0eXBlPSJudW1iZXIiXXsKICAgIGFwcGVhcmFuY2U6bm9uZTsgYm9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMTQpOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuNDApOwogICAgY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC45Mik7IHBhZGRpbmc6IDEwcHggMTBweDsgYm9yZGVyLXJhZGl1czogMTZweDsKICAgIGZvbnQtd2VpZ2h0OiA4NTA7IGZvbnQtc2l6ZTogMTNweDsgb3V0bGluZTpub25lOyB9CiAgYnV0dG9ueyBjdXJzb3I6cG9pbnRlcjsgfQogIGJ1dHRvbjphY3RpdmV7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpOyBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuMDgpOyB9CiAgLnBpbGx7IHBhZGRpbmc6OHB4IDEwcHg7IGJvcmRlci1yYWRpdXM6OTk5cHg7IGJvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEwKTsKICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC4wNSk7IGZvbnQtc2l6ZToxMnB4OyBvcGFjaXR5OjAuODY7IGRpc3BsYXk6ZmxleDsgZ2FwOjhweDsgYWxpZ24taXRlbXM6Y2VudGVyOyB9CiAgI21haW57IGZsZXg6MTsgbWluLWhlaWdodDowOyBkaXNwbGF5OmdyaWQ7IGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDM2MHB4OyBnYXA6MTBweDsgfQogICNjYW52YXNDYXJkeyBib3JkZXItcmFkaXVzOjIycHg7IGJvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEyKTsgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjQ2KTsKICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMnB4KTsgcGFkZGluZzoxMnB4OyBkaXNwbGF5OmZsZXg7IGZsZXgtZGlyZWN0aW9uOmNvbHVtbjsgZ2FwOjEwcHg7IG1pbi1oZWlnaHQ6MDsgfQogICNjdldyYXB7IGZsZXg6MTsgbWluLWhlaWdodDowOyBib3JkZXItcmFkaXVzOjE4cHg7IGJvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEwKTsKICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4zNSk7IGRpc3BsYXk6Z3JpZDsgcGxhY2UtaXRlbXM6Y2VudGVyOyBvdmVyZmxvdzpoaWRkZW47IH0KICBjYW52YXN7IHdpZHRoOiBtaW4oOTJ2dywgOTgwcHgpOyBoZWlnaHQ6YXV0bzsgaW1hZ2UtcmVuZGVyaW5nOiBwaXhlbGF0ZWQ7IGJvcmRlci1yYWRpdXM6MTZweDsgYmFja2dyb3VuZDojMDAwOyB0b3VjaC1hY3Rpb246bm9uZTsgfQogICNzaWRleyBib3JkZXItcmFkaXVzOjIycHg7IGJvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEyKTsgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjQ2KTsKICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMnB4KTsgcGFkZGluZzoxMnB4OyBtaW4taGVpZ2h0OjA7IGRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDsgb3ZlcmZsb3c6aGlkZGVuOyB9CiAgI2xvZ3sgZmxleDoxOyBtaW4taGVpZ2h0OjA7IGJvcmRlci1yYWRpdXM6MTZweDsgYm9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMDgpOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMzApOwogICAgcGFkZGluZzoxMHB4OyBvdmVyZmxvdzphdXRvOyBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsICJMaWJlcmF0aW9uIE1vbm8iLCBtb25vc3BhY2U7CiAgICBmb250LXNpemU6IDEycHg7IGxpbmUtaGVpZ2h0OjEuMzU7IG9wYWNpdHk6MC45MjsgfQogIC5ncmlkeyBkaXNwbGF5OmdyaWQ7IGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjsgZ2FwOjEwcHg7IH0KICAubGFieyBmb250LXNpemU6MTJweDsgb3BhY2l0eTowLjc4OyB9CiAgQG1lZGlhIChtYXgtd2lkdGg6IDk4MHB4KXsgI21haW57IGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyOyB9IGNhbnZhc3sgd2lkdGg6IG1pbig5NHZ3LCA3MjBweCk7IH0gfQo8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5Pgo8ZGl2IGlkPSJ3cmFwIj4KICA8ZGl2IGNsYXNzPSJiYXIiPgogICAgPGRpdiBjbGFzcz0idGl0bGUiPkJBWiDigKIgR0lG4oCRTGlmZSBLZXJuZWwg4oaSIEFuYWxvZ3VlIFF1YW50dW0gQ29tcHV0aW5nIChicm93c2VyIGVtdWxhdG9yKTwvZGl2PgogICAgPGRpdiBjbGFzcz0icGlsbCI+PHNwYW4+TW9kZTwvc3Bhbj4KICAgICAgPHNlbGVjdCBpZD0ibW9kZSI+CiAgICAgICAgPG9wdGlvbiB2YWx1ZT0ibGlmZSI+TGlmZSAoYmluYXJ5KTwvb3B0aW9uPgogICAgICAgIDxvcHRpb24gdmFsdWU9InBpeGVsbGlmZSI+UGl4ZWzigJFMaWZlIChSR0IgcmVhY3Rpb27igJNkaWZmdXNpb24pPC9vcHRpb24+CiAgICAgICAgPG9wdGlvbiB2YWx1ZT0iYXFjIiBzZWxlY3RlZD5CQVrigJFBUUMgKGNvbXBsZXggZmllbGQpPC9vcHRpb24+CiAgICAgIDwvc2VsZWN0PgogICAgPC9kaXY+CiAgICA8YnV0dG9uIGlkPSJidG5SdW4iPlJ1bjwvYnV0dG9uPgogICAgPGJ1dHRvbiBpZD0iYnRuU3RlcCI+U3RlcDwvYnV0dG9uPgogICAgPGJ1dHRvbiBpZD0iYnRuQ2xlYXIiPkNsZWFyPC9idXR0b24+CiAgICA8YnV0dG9uIGlkPSJidG5TZWVkIj5TZWVkPC9idXR0b24+CiAgICA8ZGl2IGNsYXNzPSJwaWxsIj48c3Bhbj5GUFM8L3NwYW4+PHNwYW4gaWQ9ImZwcyI+4oCUPC9zcGFuPjwvZGl2PgogIDwvZGl2PgoKICA8ZGl2IGlkPSJtYWluIj4KICAgIDxkaXYgaWQ9ImNhbnZhc0NhcmQiPgogICAgICA8ZGl2IGNsYXNzPSJsYWIiPgogICAgICAgIFRhcC9kcmFnIHRvIHBhaW50LiBTaGlmdC10YXAgPSBtZWFzdXJlL3NhbXBsZS4gU2hpZnQgZG91YmxlLXRhcCA9IGNvbGxhcHNlIChBUUMpLgogICAgICAgIE11bHRpLXRvdWNoIGNyZWF0ZXMgRU0tbm9kZSDigJxCQVogcG9sZXPigJ0gdXNpbmcgYSBjYXBhY2l0YW5jZSBwcm94eSAocHJlc3N1cmUgw5cgY29udGFjdCBhcmVhKS4KICAgICAgPC9kaXY+CiAgICAgIDxkaXYgaWQ9ImN2V3JhcCI+PGNhbnZhcyBpZD0iY3YiIHdpZHRoPSIyNTYiIGhlaWdodD0iMTQ0Ij48L2NhbnZhcz48L2Rpdj4KCiAgICAgIDxkaXYgY2xhc3M9ImJhciIgc3R5bGU9Imp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuIj4KICAgICAgICA8ZGl2IGNsYXNzPSJwaWxsIj48c3Bhbj5y4oKCPC9zcGFuPjxzcGFuIGlkPSJyMnYiPjEuMDA8L3NwYW4+PC9kaXY+CiAgICAgICAgPGlucHV0IGlkPSJyMiIgdHlwZT0icmFuZ2UiIG1pbj0iMC4yNSIgbWF4PSI2IiBzdGVwPSIwLjAxIiB2YWx1ZT0iMS4wMCIgc3R5bGU9ImZsZXg6MTsgbWluLXdpZHRoOiAyMjBweDsiLz4KCiAgICAgICAgPGRpdiBjbGFzcz0icGlsbCI+PHNwYW4+UHJpbWXigJFrZXJuZWw8L3NwYW4+PHNwYW4gaWQ9InBraW5mbyI+4oCUPC9zcGFuPjwvZGl2PgoKICAgICAgICA8ZGl2IGNsYXNzPSJwaWxsIj48c3Bhbj5DYXDigJFQb2xlczwvc3Bhbj4KICAgICAgICAgIDxzZWxlY3QgaWQ9ImNhcE9uIj4KICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0ib24iIHNlbGVjdGVkPk9OPC9vcHRpb24+CiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Im9mZiI+T0ZGPC9vcHRpb24+CiAgICAgICAgICA8L3NlbGVjdD4KICAgICAgICA8L2Rpdj4KCiAgICAgICAgPGRpdiBjbGFzcz0icGlsbCI+PHNwYW4+z4M8L3NwYW4+PHNwYW4gaWQ9InNpZ3YiPjEwPC9zcGFuPjwvZGl2PgogICAgICAgIDxpbnB1dCBpZD0ic2lnbWEiIHR5cGU9InJhbmdlIiBtaW49IjMiIG1heD0iNDAiIHN0ZXA9IjEiIHZhbHVlPSIxMCIgc3R5bGU9ImZsZXg6MTsgbWluLXdpZHRoOiAxNDBweDsiLz4KCiAgICAgICAgPGRpdiBjbGFzcz0icGlsbCI+PHNwYW4+R2Fpbjwvc3Bhbj48c3BhbiBpZD0iZ2FpbnYiPjEuMDA8L3NwYW4+PC9kaXY+CiAgICAgICAgPGlucHV0IGlkPSJnYWluIiB0eXBlPSJyYW5nZSIgbWluPSIwLjEwIiBtYXg9IjYuMDAiIHN0ZXA9IjAuMDUiIHZhbHVlPSIxLjAwIiBzdHlsZT0iZmxleDoxOyBtaW4td2lkdGg6IDE0MHB4OyIvPgogICAgICA8L2Rpdj4KICAgIDwvZGl2PgoKICAgIDxkaXYgaWQ9InNpZGUiPgogICAgICA8ZGl2IGNsYXNzPSJiYXIiPgogICAgICAgIDxidXR0b24gaWQ9ImJ0blByaW1lcyI+R2VuZXJhdGUgcHJpbWVzPC9idXR0b24+CiAgICAgICAgPGlucHV0IGlkPSJwcmltZU4iIHR5cGU9Im51bWJlciIgbWluPSI4IiBtYXg9IjI1NiIgc3RlcD0iMSIgdmFsdWU9IjY0IiBzdHlsZT0id2lkdGg6MTEwcHgiLz4KICAgICAgICA8YnV0dG9uIGlkPSJidG5Ccm9hZGNhc3QiPkJyb2FkY2FzdDwvYnV0dG9uPgogICAgICAgIDxidXR0b24gaWQ9ImJ0bkxpc3RlbiI+TGlzdGVuPC9idXR0b24+CiAgICAgIDwvZGl2PgoKICAgICAgPGRpdiBjbGFzcz0iZ3JpZCI+CiAgICAgICAgPGRpdiBjbGFzcz0icGlsbCI+PHNwYW4+ZHQ8L3NwYW4+PGlucHV0IGlkPSJkdCIgdHlwZT0ibnVtYmVyIiB2YWx1ZT0iMC4wOCIgc3RlcD0iMC4wMSIgbWluPSIwLjAwMSIgbWF4PSIxIiBzdHlsZT0id2lkdGg6MTEwcHgiPjwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InBpbGwiPjxzcGFuPs6xPC9zcGFuPjxpbnB1dCBpZD0iYWxwaGEiIHR5cGU9Im51bWJlciIgdmFsdWU9IjAuMzUiIHN0ZXA9IjAuMDEiIG1pbj0iMCIgbWF4PSIyIiBzdHlsZT0id2lkdGg6MTEwcHgiPjwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InBpbGwiPjxzcGFuPlY8L3NwYW4+PGlucHV0IGlkPSJWayIgdHlwZT0ibnVtYmVyIiB2YWx1ZT0iMC44MCIgc3RlcD0iMC4wMSIgbWluPSItNiIgbWF4PSI2IiBzdHlsZT0id2lkdGg6MTEwcHgiPjwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InBpbGwiPjxzcGFuPs6zPC9zcGFuPjxpbnB1dCBpZD0iZ2FtbWEiIHR5cGU9Im51bWJlciIgdmFsdWU9IjAuMTgiIHN0ZXA9IjAuMDEiIG1pbj0iMCIgbWF4PSIyIiBzdHlsZT0id2lkdGg6MTEwcHgiPjwvZGl2PgogICAgICA8L2Rpdj4KCiAgICAgIDxkaXYgY2xhc3M9ImJhciI+CiAgICAgICAgPGJ1dHRvbiBpZD0iYnRuR2F0ZUgiPkg8L2J1dHRvbj4KICAgICAgICA8YnV0dG9uIGlkPSJidG5HYXRlWCI+WDwvYnV0dG9uPgogICAgICAgIDxidXR0b24gaWQ9ImJ0bkdhdGVaIj5aPC9idXR0b24+CiAgICAgICAgPGJ1dHRvbiBpZD0iYnRuS2ljayI+UGhhc2XigJFraWNrPC9idXR0b24+CiAgICAgICAgPGJ1dHRvbiBpZD0iYnRuTm9ybWFsaXplIj5Ob3JtYWxpemU8L2J1dHRvbj4KICAgICAgPC9kaXY+CgogICAgICA8ZGl2IGNsYXNzPSJsYWIiPgogICAgICAgIE5vdGU6IHJhdyBjYXBhY2l0YW5jZSBpcyBub3QgZXhwb3NlZCBpbiB3ZWIgQVBJcy4gVGhpcyB1c2VzIGEgYmVzdC1lZmZvcnQgcHJveHkgZnJvbSB0b3VjaCBnZW9tZXRyeS9wcmVzc3VyZS4KICAgICAgICBNdWx0aS10YWIgRDJEIHVzZXMgQnJvYWRjYXN0Q2hhbm5lbCAoc2FtZSBvcmlnaW4pIHRvIHN5bmMga2VybmVscyArIHBhcmFtZXRlcnMuCiAgICAgIDwvZGl2PgoKICAgICAgPGRpdiBpZD0ibG9nIj48L2Rpdj4KICAgIDwvZGl2PgogIDwvZGl2Pgo8L2Rpdj4KCjxzY3JpcHQ+CigoKSA9PiB7CiAgY29uc3QgJCA9IChpZCk9PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTsKICBjb25zdCBjdiA9ICQoImN2IiksIGN0eCA9IGN2LmdldENvbnRleHQoIjJkIiwge2FscGhhOmZhbHNlfSk7CiAgY29uc3QgVz1jdi53aWR0aCwgSD1jdi5oZWlnaHQsIE49VypIOwoKICAvLyAtLS0tLS0tLS0tIFN0YXRlIGJ1ZmZlcnMgLS0tLS0tLS0tLQogIGxldCBsaWZlID0gbmV3IFVpbnQ4QXJyYXkoTiksIGxpZmUyID0gbmV3IFVpbnQ4QXJyYXkoTik7CiAgbGV0IFIgPSBuZXcgRmxvYXQzMkFycmF5KE4pLCBHID0gbmV3IEZsb2F0MzJBcnJheShOKSwgQiA9IG5ldyBGbG9hdDMyQXJyYXkoTik7CiAgbGV0IFIyID0gbmV3IEZsb2F0MzJBcnJheShOKSwgRzIgPSBuZXcgRmxvYXQzMkFycmF5KE4pLCBCMiA9IG5ldyBGbG9hdDMyQXJyYXkoTik7CiAgbGV0IHJlID0gbmV3IEZsb2F0MzJBcnJheShOKSwgaW0gPSBuZXcgRmxvYXQzMkFycmF5KE4pOwogIGxldCByZTIgPSBuZXcgRmxvYXQzMkFycmF5KE4pLCBpbTIgPSBuZXcgRmxvYXQzMkFycmF5KE4pOwoKICAvLyBQcmltZSBrZXJuZWwKICBsZXQgcHJpbWVzID0gW107CiAgbGV0IHcgPSBbXTsgLy8gcHJpbWUgZ2FwcwogIGxldCB3UGhhc2UgPSAwOwoKICAvLyBEMkQKICBsZXQgYmMgPSBudWxsOwoKICAvLyAtLS0tLS0tLS0tIFVJIC0tLS0tLS0tLS0KICBjb25zdCBtb2RlRWwgPSAkKCJtb2RlIik7CiAgY29uc3QgZnBzRWwgPSAkKCJmcHMiKTsKICBjb25zdCByMkVsID0gJCgicjIiKSwgcjJ2ID0gJCgicjJ2Iik7CiAgY29uc3QgcGtpbmZvID0gJCgicGtpbmZvIik7CiAgY29uc3QgbG9nRWwgPSAkKCJsb2ciKTsKICBjb25zdCBkdEVsID0gJCgiZHQiKSwgYWxwaGFFbCA9ICQoImFscGhhIiksIFZrRWwgPSAkKCJWayIpLCBnYW1tYUVsID0gJCgiZ2FtbWEiKTsKICBjb25zdCBwcmltZU5FbCA9ICQoInByaW1lTiIpOwoKICBjb25zdCBjYXBPbkVsID0gJCgiY2FwT24iKTsKICBjb25zdCBzaWdtYUVsID0gJCgic2lnbWEiKSwgc2lndiA9ICQoInNpZ3YiKTsKICBjb25zdCBnYWluRWwgPSAkKCJnYWluIiksIGdhaW52ID0gJCgiZ2FpbnYiKTsKCiAgZnVuY3Rpb24gbG9nKG1zZyl7CiAgICBjb25zdCB0ID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTsKICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKICAgIGQudGV4dENvbnRlbnQgPSAiWyIgKyB0ICsgIl0gIiArIG1zZzsKICAgIGxvZ0VsLmFwcGVuZENoaWxkKGQpOwogICAgbG9nRWwuc2Nyb2xsVG9wID0gbG9nRWwuc2Nyb2xsSGVpZ2h0OwogIH0KCiAgZnVuY3Rpb24gY2xhbXAwMSh4KXsgcmV0dXJuIHg8MD8wOih4PjE/MTp4KTsgfQogIGZ1bmN0aW9uIGlkeCh4LHkpeyByZXR1cm4gKHkqVyt4KTsgfQogIGZ1bmN0aW9uIHdyYXBYKHgpeyByZXR1cm4gKHgrVyklVzsgfQogIGZ1bmN0aW9uIHdyYXBZKHkpeyByZXR1cm4gKHkrSCklSDsgfQoKICBmdW5jdGlvbiBiYXNPZlBpeGVsKHgseSl7CiAgICBjb25zdCBjeCA9ICh4IC0gKFctMSkvMik7CiAgICBjb25zdCBjeSA9ICh5IC0gKEgtMSkvMik7CiAgICBjb25zdCByMSA9IE1hdGguaHlwb3QoY3gsIGN5KSAvIChNYXRoLm1pbihXLEgpLzIpOwogICAgbGV0IHBoaSA9IE1hdGguYXRhbjIoY3ksIGN4KTsKICAgIGlmIChwaGkgPCAwKSBwaGkgKz0gTWF0aC5QSSoyOwogICAgY29uc3QgcjIgPSBwYXJzZUZsb2F0KHIyRWwudmFsdWUpOwogICAgY29uc3QgdGggPSByMiAqIHBoaTsKICAgIHJldHVybiB7cjEsIHBoaSwgdGgsIHIyfTsKICB9CgogIGZ1bmN0aW9uIGdlblByaW1lcyhuKXsKICAgIGNvbnN0IG91dCA9IFtdOwogICAgbGV0IHggPSAyOwogICAgd2hpbGUob3V0Lmxlbmd0aCA8IG4pewogICAgICBsZXQgb2sgPSB0cnVlOwogICAgICBmb3IgKGxldCBwIG9mIG91dCl7CiAgICAgICAgaWYgKHAqcCA+IHgpIGJyZWFrOwogICAgICAgIGlmICh4ICUgcCA9PT0gMCl7IG9rPWZhbHNlOyBicmVhazsgfQogICAgICB9CiAgICAgIGlmIChvaykgb3V0LnB1c2goeCk7CiAgICAgIHgrKzsKICAgIH0KICAgIHJldHVybiBvdXQ7CiAgfQoKICBmdW5jdGlvbiBidWlsZFByaW1lS2VybmVsKG4pewogICAgcHJpbWVzID0gZ2VuUHJpbWVzKG4pOwogICAgdyA9IFtdOwogICAgZm9yIChsZXQgaT0wO2k8cHJpbWVzLmxlbmd0aC0xO2krKykgdy5wdXNoKHByaW1lc1tpKzFdLXByaW1lc1tpXSk7CiAgICBpZiAoIXcubGVuZ3RoKSB3PVsxXTsKICAgIHBraW5mby50ZXh0Q29udGVudCA9IHByaW1lcy5sZW5ndGggKyAiIHByaW1lcyI7CiAgICBsZXQgbW4gPSB3WzBdLCBteCA9IHdbMF07CiAgICBmb3IgKGNvbnN0IGEgb2Ygdyl7IGlmIChhPG1uKSBtbj1hOyBpZiAoYT5teCkgbXg9YTsgfQogICAgbG9nKCJQcmltZSBrZXJuZWw6IG49IiArIHByaW1lcy5sZW5ndGggKyAiIGdhcCByYW5nZT1bIiArIG1uICsgIiwiICsgbXggKyAiXSIpOwogIH0KCiAgZnVuY3Rpb24gVm9mUGhpKHBoaSl7CiAgICBpZiAoIXcubGVuZ3RoKSByZXR1cm4gMDsKICAgIGNvbnN0IG0gPSBNYXRoLm1pbig0OCwgdy5sZW5ndGgpOwogICAgbGV0IHMgPSAwOwogICAgZm9yIChsZXQgaz0wO2s8bTtrKyspewogICAgICBjb25zdCB3ayA9IHdba107CiAgICAgIHMgKz0gd2sgKiBNYXRoLmNvcygoaysxKSpwaGkgKyB3UGhhc2UpOwogICAgfQogICAgcmV0dXJuIHMgLyAobSo2KTsKICB9CgogIGZ1bmN0aW9uIGxhcDQoYXJyLCB4LCB5KXsKICAgIGNvbnN0IHhtID0gd3JhcFgoeC0xKSwgeHAgPSB3cmFwWCh4KzEpOwogICAgY29uc3QgeW0gPSB3cmFwWSh5LTEpLCB5cCA9IHdyYXBZKHkrMSk7CiAgICBjb25zdCBjID0gYXJyW2lkeCh4LHkpXTsKICAgIHJldHVybiAoYXJyW2lkeCh4bSx5KV0gKyBhcnJbaWR4KHhwLHkpXSArIGFycltpZHgoeCx5bSldICsgYXJyW2lkeCh4LHlwKV0gLSA0KmMpOwogIH0KCiAgZnVuY3Rpb24gc3RlcExpZmUoKXsKICAgIGZvciAobGV0IHk9MDt5PEg7eSsrKXsKICAgICAgZm9yIChsZXQgeD0wO3g8Vzt4KyspewogICAgICAgIGxldCBuPTA7CiAgICAgICAgZm9yIChsZXQgb3k9LTE7IG95PD0xOyBveSsrKXsKICAgICAgICAgIGZvciAobGV0IG94PS0xOyBveDw9MTsgb3grKyl7CiAgICAgICAgICAgIGlmICghb3ggJiYgIW95KSBjb250aW51ZTsKICAgICAgICAgICAgbiArPSBsaWZlW2lkeCh3cmFwWCh4K294KSwgd3JhcFkoeStveSkpXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgaSA9IGlkeCh4LHkpOwogICAgICAgIGNvbnN0IGEgPSBsaWZlW2ldOwogICAgICAgIGxpZmUyW2ldID0gKGEgPyAobj09PTIgfHwgbj09PTMpIDogKG49PT0zKSkgPyAxIDogMDsKICAgICAgfQogICAgfQogICAgY29uc3QgdD1saWZlOyBsaWZlPWxpZmUyOyBsaWZlMj10OwogIH0KCiAgZnVuY3Rpb24gc3RlcFBpeGVsTGlmZSgpewogICAgY29uc3QgZ2FtbWEgPSBwYXJzZUZsb2F0KGdhbW1hRWwudmFsdWUpOwogICAgY29uc3QgZHQgPSBwYXJzZUZsb2F0KGR0RWwudmFsdWUpOwogICAgY29uc3QgazE9MS4wLCBrMj0xLjIsIGszPTAuOTsKICAgIGZvciAobGV0IHk9MDt5PEg7eSsrKXsKICAgICAgZm9yIChsZXQgeD0wO3g8Vzt4KyspewogICAgICAgIGNvbnN0IGkgPSBpZHgoeCx5KTsKICAgICAgICBjb25zdCByPVJbaV0sIGc9R1tpXSwgYj1CW2ldOwogICAgICAgIGNvbnN0IGRSID0gKC1rMSpyICsgazMqYik7CiAgICAgICAgY29uc3QgZEcgPSAoIGsxKnIgLSBrMipnKTsKICAgICAgICBjb25zdCBkQiA9ICggazIqZyAtIGszKmIpOwogICAgICAgIGNvbnN0IGxSID0gbGFwNChSLHgseSksIGxHID0gbGFwNChHLHgseSksIGxCID0gbGFwNChCLHgseSk7CiAgICAgICAgUjJbaV0gPSBjbGFtcDAxKHIgKyBkdCooZFIgKyBnYW1tYSpsUikpOwogICAgICAgIEcyW2ldID0gY2xhbXAwMShnICsgZHQqKGRHICsgZ2FtbWEqbEcpKTsKICAgICAgICBCMltpXSA9IGNsYW1wMDEoYiArIGR0KihkQiArIGdhbW1hKmxCKSk7CiAgICAgIH0KICAgIH0KICAgIGxldCB0PVI7IFI9UjI7IFIyPXQ7IHQ9RzsgRz1HMjsgRzI9dDsgdD1COyBCPUIyOyBCMj10OwogIH0KCiAgLy8gLS0tLS0gQ2FwYWNpdGFuY2UgcG9sZXMgKHByb3h5KSAtLS0tLQogIGZ1bmN0aW9uIGNsYW1wKHYsYSxiKXsgcmV0dXJuIHY8YT9hOih2PmI/Yjp2KTsgfQogIGNvbnN0IHBvaW50ZXJzID0gbmV3IE1hcCgpOyAvLyBpZCAtPiB7eCx5LHByZXNzdXJlLGFyZWF9CiAgY29uc3QgbGFzdFRhcEJ5SWQgPSBuZXcgTWFwKCk7CgogIGZ1bmN0aW9uIGdldExvY2FsWFkoZSl7CiAgICBjb25zdCByZWN0PWN2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgY29uc3QgeCA9IE1hdGguZmxvb3IoKGUuY2xpZW50WC1yZWN0LmxlZnQpL3JlY3Qud2lkdGgqVyk7CiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcigoZS5jbGllbnRZLXJlY3QudG9wKS9yZWN0LmhlaWdodCpIKTsKICAgIHJldHVybiB7eDogY2xhbXAoeCwwLFctMSksIHk6IGNsYW1wKHksMCxILTEpfTsKICB9CgogIGZ1bmN0aW9uIGVzdGltYXRlQXJlYUZyb21FdmVudChlKXsKICAgIGNvbnN0IHcgPSAodHlwZW9mIGUud2lkdGggPT09ICJudW1iZXIiICYmIGUud2lkdGg+MCkgPyBlLndpZHRoIDogMTI7CiAgICBjb25zdCBoID0gKHR5cGVvZiBlLmhlaWdodCA9PT0gIm51bWJlciIgJiYgZS5oZWlnaHQ+MCkgPyBlLmhlaWdodCA6IDEyOwogICAgcmV0dXJuIE1hdGguUEkgKiAodyowLjUpICogKGgqMC41KTsKICB9CgogIGZ1bmN0aW9uIGVzdGltYXRlUHJlc3N1cmUoZSl7CiAgICBjb25zdCBwID0gKHR5cGVvZiBlLnByZXNzdXJlID09PSAibnVtYmVyIiAmJiBlLnByZXNzdXJlPjApID8gZS5wcmVzc3VyZSA6IDAuNTsKICAgIHJldHVybiBjbGFtcChwLCAwLjA1LCAxLjApOwogIH0KCiAgZnVuY3Rpb24gZ2V0UG9sZXMoKXsKICAgIGlmIChjYXBPbkVsLnZhbHVlICE9PSAib24iKSByZXR1cm4gW107CiAgICBjb25zdCBnYWluID0gcGFyc2VGbG9hdChnYWluRWwudmFsdWUpOwogICAgY29uc3QgcG9sZXMgPSBbXTsKICAgIGZvciAoY29uc3QgW2lkLHBdIG9mIHBvaW50ZXJzLmVudHJpZXMoKSl7CiAgICAgIGNvbnN0IENwcm94eSA9IHAucHJlc3N1cmUgKiBwLmFyZWE7CiAgICAgIGNvbnN0IHMgPSBnYWluICogKENwcm94eSAvIDQwMC4wKTsKICAgICAgY29uc3Qgc2lnbiA9IChpZCAlIDIgPT09IDApID8gLTEgOiArMTsKICAgICAgcG9sZXMucHVzaCh7eDpwLngsIHk6cC55LCBzOiBzKnNpZ259KTsKICAgIH0KICAgIHJldHVybiBwb2xlczsKICB9CgogIGZ1bmN0aW9uIHBvbGVQb3RlbnRpYWxBdCh4LHkpewogICAgY29uc3QgcG9sZXMgPSBnZXRQb2xlcygpOwogICAgaWYgKCFwb2xlcy5sZW5ndGgpIHJldHVybiAwOwogICAgY29uc3Qgc2lnID0gcGFyc2VGbG9hdChzaWdtYUVsLnZhbHVlKTsKICAgIGNvbnN0IGludjJzMiA9IDEuMCAvICgyLjAqc2lnKnNpZyk7CiAgICBsZXQgVnAgPSAwOwogICAgZm9yIChjb25zdCBwbCBvZiBwb2xlcyl7CiAgICAgIGNvbnN0IGR4ID0geCAtIHBsLngsIGR5ID0geSAtIHBsLnk7CiAgICAgIFZwICs9IHBsLnMgKiBNYXRoLmV4cCgtKGR4KmR4K2R5KmR5KSAqIGludjJzMik7CiAgICB9CiAgICByZXR1cm4gVnA7CiAgfQoKICBmdW5jdGlvbiBzdGVwQVFDKCl7CiAgICBjb25zdCBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGFFbC52YWx1ZSk7CiAgICBjb25zdCBkdCA9IHBhcnNlRmxvYXQoZHRFbC52YWx1ZSk7CiAgICBmb3IgKGxldCB5PTA7eTxIO3krKyl7CiAgICAgIGZvciAobGV0IHg9MDt4PFc7eCsrKXsKICAgICAgICBjb25zdCBpID0gaWR4KHgseSk7CiAgICAgICAgY29uc3QgcGhpID0gYmFzT2ZQaXhlbCh4LHkpLnBoaTsKICAgICAgICBjb25zdCBsYXBSZSA9IGxhcDQocmUseCx5KTsKICAgICAgICBjb25zdCBsYXBJbSA9IGxhcDQoaW0seCx5KTsKICAgICAgICBjb25zdCBWID0gVm9mUGhpKHBoaSkgKyBwb2xlUG90ZW50aWFsQXQoeCx5KTsKCiAgICAgICAgY29uc3QgZFJlID0gKC1hbHBoYSpsYXBJbSkgKyAoVippbVtpXSk7CiAgICAgICAgY29uc3QgZEltID0gKCBhbHBoYSpsYXBSZSkgLSAoVipyZVtpXSk7CgogICAgICAgIHJlMltpXSA9IHJlW2ldICsgZHQqZFJlOwogICAgICAgIGltMltpXSA9IGltW2ldICsgZHQqZEltOwogICAgICB9CiAgICB9CiAgICBsZXQgdD1yZTsgcmU9cmUyOyByZTI9dDsgdD1pbTsgaW09aW0yOyBpbTI9dDsKICAgIHdQaGFzZSArPSAwLjAyOwogIH0KCiAgZnVuY3Rpb24gbm9ybWFsaXplQVFDKCl7CiAgICBsZXQgcyA9IDA7CiAgICBmb3IgKGxldCBpPTA7aTxOO2krKykgcyArPSByZVtpXSpyZVtpXSArIGltW2ldKmltW2ldOwogICAgaWYgKHMgPD0gMWUtMTIpIHJldHVybjsKICAgIGNvbnN0IGludiA9IDEvTWF0aC5zcXJ0KHMpOwogICAgZm9yIChsZXQgaT0wO2k8TjtpKyspeyByZVtpXSo9aW52OyBpbVtpXSo9aW52OyB9CiAgfQoKICBmdW5jdGlvbiBhcHBseUdhdGUoa2luZCl7CiAgICBmb3IgKGxldCB5PTA7eTxIO3krKyl7CiAgICAgIGZvciAobGV0IHg9MDt4PFc7eCsrKXsKICAgICAgICBjb25zdCBpID0gaWR4KHgseSk7CiAgICAgICAgY29uc3QgaXMxID0geCA+PSAoVz4+MSk7CiAgICAgICAgY29uc3QgYTByID0gaXMxID8gMCA6IHJlW2ldLCBhMGkgPSBpczEgPyAwIDogaW1baV07CiAgICAgICAgY29uc3QgYTFyID0gaXMxID8gcmVbaV0gOiAwLCBhMWkgPSBpczEgPyBpbVtpXSA6IDA7CgogICAgICAgIGxldCBiMHI9YTByLCBiMGk9YTBpLCBiMXI9YTFyLCBiMWk9YTFpOwogICAgICAgIGlmIChraW5kPT09IlgiKXsKICAgICAgICAgIGIwcj1hMXI7IGIwaT1hMWk7IGIxcj1hMHI7IGIxaT1hMGk7CiAgICAgICAgfSBlbHNlIGlmIChraW5kPT09IloiKXsKICAgICAgICAgIGIxcj0tYTFyOyBiMWk9LWExaTsKICAgICAgICB9IGVsc2UgaWYgKGtpbmQ9PT0iSCIpewogICAgICAgICAgY29uc3QgcyA9IE1hdGguU1FSVDFfMjsKICAgICAgICAgIGIwciA9IChhMHIgKyBhMXIpKnM7IGIwaSA9IChhMGkgKyBhMWkpKnM7CiAgICAgICAgICBiMXIgPSAoYTByIC0gYTFyKSpzOyBiMWkgPSAoYTBpIC0gYTFpKSpzOwogICAgICAgIH0KICAgICAgICBpZiAoIWlzMSl7IHJlW2ldPWIwcjsgaW1baV09YjBpOyB9IGVsc2UgeyByZVtpXT1iMXI7IGltW2ldPWIxaTsgfQogICAgICB9CiAgICB9CiAgICBub3JtYWxpemVBUUMoKTsKICAgIGxvZygiR2F0ZSAiICsga2luZCArICIgYXBwbGllZC4iKTsKICB9CgogIGZ1bmN0aW9uIHBoYXNlS2ljaygpewogICAgY29uc3QgVmsgPSBwYXJzZUZsb2F0KFZrRWwudmFsdWUpOwogICAgZm9yIChsZXQgeT0wO3k8SDt5KyspewogICAgICBmb3IgKGxldCB4PTA7eDxXO3grKyl7CiAgICAgICAgY29uc3QgaSA9IGlkeCh4LHkpOwogICAgICAgIGNvbnN0IHBoaSA9IGJhc09mUGl4ZWwoeCx5KS5waGk7CiAgICAgICAgY29uc3QgViA9IFZvZlBoaShwaGkpICsgcG9sZVBvdGVudGlhbEF0KHgseSk7CiAgICAgICAgY29uc3QgdGggPSAtVmsgKiBWOwogICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyh0aCksIHMgPSBNYXRoLnNpbih0aCk7CiAgICAgICAgY29uc3QgYXIgPSByZVtpXSwgYWkgPSBpbVtpXTsKICAgICAgICByZVtpXSA9IGFyKmMgLSBhaSpzOwogICAgICAgIGltW2ldID0gYXIqcyArIGFpKmM7CiAgICAgIH0KICAgIH0KICAgIG5vcm1hbGl6ZUFRQygpOwogICAgbG9nKCJQaGFzZSBraWNrIFZrPSIgKyBWay50b0ZpeGVkKDIpKTsKICB9CgogIC8vIC0tLS0tLS0tLS0gUmVuZGVyaW5nIC0tLS0tLS0tLS0KICBjb25zdCBpbWcgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKFcsSCk7CiAgY29uc3QgZGF0YSA9IGltZy5kYXRhOwoKICBmdW5jdGlvbiBkcmF3KCl7CiAgICBjb25zdCBtb2RlID0gbW9kZUVsLnZhbHVlOwogICAgaWYgKG1vZGUgPT09ICJsaWZlIil7CiAgICAgIGZvciAobGV0IGk9MDtpPE47aSsrKXsKICAgICAgICBjb25zdCB2ID0gbGlmZVtpXSA/IDI1NSA6IDA7CiAgICAgICAgZGF0YVtpKjQrMF09djsgZGF0YVtpKjQrMV09djsgZGF0YVtpKjQrMl09djsgZGF0YVtpKjQrM109MjU1OwogICAgICB9CiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICJwaXhlbGxpZmUiKXsKICAgICAgZm9yIChsZXQgaT0wO2k8TjtpKyspewogICAgICAgIGRhdGFbaSo0KzBdPShSW2ldKjI1NSl8MDsKICAgICAgICBkYXRhW2kqNCsxXT0oR1tpXSoyNTUpfDA7CiAgICAgICAgZGF0YVtpKjQrMl09KEJbaV0qMjU1KXwwOwogICAgICAgIGRhdGFbaSo0KzNdPTI1NTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgZm9yIChsZXQgeT0wO3k8SDt5KyspewogICAgICAgIGZvciAobGV0IHg9MDt4PFc7eCsrKXsKICAgICAgICAgIGNvbnN0IGkgPSBpZHgoeCx5KTsKICAgICAgICAgIGNvbnN0IGFyPXJlW2ldLCBhaT1pbVtpXTsKICAgICAgICAgIGNvbnN0IG1hZyA9IE1hdGgubWluKDEsIE1hdGguc3FydChhciphcithaSphaSkqMy4wKTsKICAgICAgICAgIGNvbnN0IHBoID0gTWF0aC5hdGFuMihhaSwgYXIpOwogICAgICAgICAgY29uc3QgaHVlID0gKHBoICsgTWF0aC5QSSkgLyAoMipNYXRoLlBJKTsKICAgICAgICAgIGNvbnN0IHM9MC45NSwgdj1tYWc7CiAgICAgICAgICBjb25zdCBoNiA9IGh1ZSo2OwogICAgICAgICAgY29uc3QgYz12KnM7CiAgICAgICAgICBjb25zdCB4Y29sPWMqKDEtTWF0aC5hYnMoaDYlMi0xKSk7CiAgICAgICAgICBsZXQgcnI9MCxnZz0wLGJiPTA7CiAgICAgICAgICBpZiAoaDY8MSl7IHJyPWM7IGdnPXhjb2w7IGJiPTA7IH0KICAgICAgICAgIGVsc2UgaWYgKGg2PDIpeyBycj14Y29sOyBnZz1jOyBiYj0wOyB9CiAgICAgICAgICBlbHNlIGlmIChoNjwzKXsgcnI9MDsgZ2c9YzsgYmI9eGNvbDsgfQogICAgICAgICAgZWxzZSBpZiAoaDY8NCl7IHJyPTA7IGdnPXhjb2w7IGJiPWM7IH0KICAgICAgICAgIGVsc2UgaWYgKGg2PDUpeyBycj14Y29sOyBnZz0wOyBiYj1jOyB9CiAgICAgICAgICBlbHNlIHsgcnI9YzsgZ2c9MDsgYmI9eGNvbDsgfQogICAgICAgICAgY29uc3QgbT12LWM7CiAgICAgICAgICBkYXRhW2kqNCswXT0oKHJyK20pKjI1NSl8MDsKICAgICAgICAgIGRhdGFbaSo0KzFdPSgoZ2crbSkqMjU1KXwwOwogICAgICAgICAgZGF0YVtpKjQrMl09KChiYittKSoyNTUpfDA7CiAgICAgICAgICBkYXRhW2kqNCszXT0yNTU7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZywwLDApOwogICAgcjJ2LnRleHRDb250ZW50ID0gcGFyc2VGbG9hdChyMkVsLnZhbHVlKS50b0ZpeGVkKDIpOwogICAgc2lndi50ZXh0Q29udGVudCA9IFN0cmluZyhwYXJzZUludChzaWdtYUVsLnZhbHVlLDEwKSk7CiAgICBnYWludi50ZXh0Q29udGVudCA9IHBhcnNlRmxvYXQoZ2FpbkVsLnZhbHVlKS50b0ZpeGVkKDIpOwogIH0KCiAgLy8gLS0tLS0tLS0tLSBDb250cm9scyAtLS0tLS0tLS0tCiAgbGV0IHJ1bm5pbmc9ZmFsc2U7CiAgJCgiYnRuUnVuIikub25jbGljayA9ICgpID0+IHsgcnVubmluZz0hcnVubmluZzsgJCgiYnRuUnVuIikudGV4dENvbnRlbnQgPSBydW5uaW5nPyJQYXVzZSI6IlJ1biI7IH07CiAgJCgiYnRuU3RlcCIpLm9uY2xpY2sgPSAoKSA9PiB7IHRpY2soKTsgZHJhdygpOyB9OwogICQoImJ0bkNsZWFyIikub25jbGljayA9ICgpID0+IHsgY2xlYXJBbGwoKTsgZHJhdygpOyB9OwogICQoImJ0blNlZWQiKS5vbmNsaWNrID0gKCkgPT4geyBzZWVkKCk7IGRyYXcoKTsgfTsKCiAgJCgiYnRuUHJpbWVzIikub25jbGljayA9ICgpID0+IGJ1aWxkUHJpbWVLZXJuZWwoTWF0aC5tYXgoOCwgTWF0aC5taW4oMjU2LCBwYXJzZUludChwcmltZU5FbC52YWx1ZXx8IjY0IiwxMCkpKSk7CiAgJCgiYnRuQnJvYWRjYXN0Iikub25jbGljayA9ICgpID0+IGJyb2FkY2FzdCgpOwogICQoImJ0bkxpc3RlbiIpLm9uY2xpY2sgPSAoKSA9PiBsaXN0ZW4oKTsKCiAgJCgiYnRuR2F0ZUgiKS5vbmNsaWNrID0gKCkgPT4geyBpZihtb2RlRWwudmFsdWU9PT0iYXFjIikgYXBwbHlHYXRlKCJIIik7IGRyYXcoKTsgfTsKICAkKCJidG5HYXRlWCIpLm9uY2xpY2sgPSAoKSA9PiB7IGlmKG1vZGVFbC52YWx1ZT09PSJhcWMiKSBhcHBseUdhdGUoIlgiKTsgZHJhdygpOyB9OwogICQoImJ0bkdhdGVaIikub25jbGljayA9ICgpID0+IHsgaWYobW9kZUVsLnZhbHVlPT09ImFxYyIpIGFwcGx5R2F0ZSgiWiIpOyBkcmF3KCk7IH07CiAgJCgiYnRuS2ljayIpLm9uY2xpY2sgID0gKCkgPT4geyBpZihtb2RlRWwudmFsdWU9PT0iYXFjIikgcGhhc2VLaWNrKCk7IGRyYXcoKTsgfTsKICAkKCJidG5Ob3JtYWxpemUiKS5vbmNsaWNrID0gKCkgPT4geyBpZihtb2RlRWwudmFsdWU9PT0iYXFjIikgeyBub3JtYWxpemVBUUMoKTsgbG9nKCJOb3JtYWxpemVkLiIpOyBkcmF3KCk7IH0gfTsKCiAgZnVuY3Rpb24gY2xlYXJBbGwoKXsKICAgIGxpZmUuZmlsbCgwKTsKICAgIFIuZmlsbCgwKTsgRy5maWxsKDApOyBCLmZpbGwoMCk7CiAgICByZS5maWxsKDApOyBpbS5maWxsKDApOwogIH0KCiAgZnVuY3Rpb24gc2VlZCgpewogICAgY29uc3QgbW9kZT1tb2RlRWwudmFsdWU7CiAgICBpZiAobW9kZT09PSJsaWZlIil7CiAgICAgIGZvciAobGV0IGk9MDtpPE47aSsrKSBsaWZlW2ldID0gKE1hdGgucmFuZG9tKCk8MC4xNik/MTowOwogICAgICBsb2coIlNlZWRlZCBMaWZlLiIpOwogICAgfSBlbHNlIGlmIChtb2RlPT09InBpeGVsbGlmZSIpewogICAgICBmb3IgKGxldCBpPTA7aTxOO2krKyl7CiAgICAgICAgUltpXT1NYXRoLnJhbmRvbSgpKjAuMjU7IEdbaV09TWF0aC5yYW5kb20oKSowLjI1OyBCW2ldPU1hdGgucmFuZG9tKCkqMC4yNTsKICAgICAgICBpZiAoTWF0aC5yYW5kb20oKTwwLjAyKXsgUltpXT0xOyBHW2ldPTA7IEJbaV09MDsgfQogICAgICB9CiAgICAgIGxvZygiU2VlZGVkIFBpeGVsLUxpZmUuIik7CiAgICB9IGVsc2UgewogICAgICBjb25zdCBjeD1XKjAuMzUsIGN5PUgqMC41NTsKICAgICAgZm9yIChsZXQgeT0wO3k8SDt5KyspewogICAgICAgIGZvciAobGV0IHg9MDt4PFc7eCsrKXsKICAgICAgICAgIGNvbnN0IGk9aWR4KHgseSk7CiAgICAgICAgICBjb25zdCBkeD14LWN4LCBkeT15LWN5OwogICAgICAgICAgY29uc3QgZz1NYXRoLmV4cCgtKGR4KmR4K2R5KmR5KS8oMioxODApKTsKICAgICAgICAgIHJlW2ldPWc7IGltW2ldPTA7CiAgICAgICAgfQogICAgICB9CiAgICAgIG5vcm1hbGl6ZUFRQygpOwogICAgICBsb2coIlNlZWRlZCBBUUMgZmllbGQuIik7CiAgICB9CiAgfQoKICBmdW5jdGlvbiB0aWNrKCl7CiAgICBjb25zdCBtb2RlID0gbW9kZUVsLnZhbHVlOwogICAgaWYgKG1vZGU9PT0ibGlmZSIpIHN0ZXBMaWZlKCk7CiAgICBlbHNlIGlmIChtb2RlPT09InBpeGVsbGlmZSIpIHN0ZXBQaXhlbExpZmUoKTsKICAgIGVsc2Ugc3RlcEFRQygpOwogIH0KCiAgLy8gcG9pbnRlciBpbnRlcmFjdGlvbgogIGN2LmFkZEV2ZW50TGlzdGVuZXIoInBvaW50ZXJkb3duIiwoZSk9PnsKICAgIGN2LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTsKICAgIGNvbnN0IHt4LHl9ID0gZ2V0TG9jYWxYWShlKTsKICAgIHBvaW50ZXJzLnNldChlLnBvaW50ZXJJZCwge3gseSwgYXJlYTogZXN0aW1hdGVBcmVhRnJvbUV2ZW50KGUpLCBwcmVzc3VyZTogZXN0aW1hdGVQcmVzc3VyZShlKX0pOwogICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICBjb25zdCBsYXN0ID0gbGFzdFRhcEJ5SWQuZ2V0KGUucG9pbnRlcklkKSB8fCAwOwogICAgY29uc3QgZGJsID0gKG5vdyAtIGxhc3QpIDwgMzIwOwogICAgbGFzdFRhcEJ5SWQuc2V0KGUucG9pbnRlcklkLCBub3cpOwoKICAgIGNvbnN0IG1vZGU9bW9kZUVsLnZhbHVlOwogICAgY29uc3QgbWVhc3VyZSA9IGUuc2hpZnRLZXk7CgogICAgaWYgKG1vZGU9PT0ibGlmZSIpewogICAgICBpZiAobWVhc3VyZSl7CiAgICAgICAgbGV0IG49MDsKICAgICAgICBmb3IgKGxldCBveT0tMTsgb3k8PTE7IG95KyspewogICAgICAgICAgZm9yIChsZXQgb3g9LTE7IG94PD0xOyBveCsrKXsKICAgICAgICAgICAgaWYgKCFveCAmJiAhb3kpIGNvbnRpbnVlOwogICAgICAgICAgICBuICs9IGxpZmVbaWR4KHdyYXBYKHgrb3gpLCB3cmFwWSh5K295KSldOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsb2coIlNhbXBsZSBMaWZlIEAoIiArIHggKyAiLCIgKyB5ICsgIik6IGFsaXZlPSIgKyBsaWZlW2lkeCh4LHkpXSArICIgbj0iICsgbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGlmZVtpZHgoeCx5KV0gPSAxOwogICAgICB9CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAobW9kZT09PSJwaXhlbGxpZmUiKXsKICAgICAgaWYgKG1lYXN1cmUpewogICAgICAgIGNvbnN0IGk9aWR4KHgseSk7CiAgICAgICAgbG9nKCJTYW1wbGUgUkdCIEAoIiArIHggKyAiLCIgKyB5ICsgIik6IFI9IiArIFJbaV0udG9GaXhlZCgyKSArICIgRz0iICsgR1tpXS50b0ZpeGVkKDIpICsgIiBCPSIgKyBCW2ldLnRvRml4ZWQoMikpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGk9aWR4KHgseSk7CiAgICAgICAgUltpXT0xOyBHW2ldPTAuMTU7IEJbaV09MC4wNTsKICAgICAgfQogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gQVFDCiAgICBjb25zdCBpPWlkeCh4LHkpOwogICAgaWYgKG1lYXN1cmUpewogICAgICBjb25zdCBwID0gcmVbaV0qcmVbaV0gKyBpbVtpXSppbVtpXTsKICAgICAgY29uc3QgYnAgPSBiYXNPZlBpeGVsKHgseSk7CiAgICAgIGNvbnN0IFZwID0gcG9sZVBvdGVudGlhbEF0KHgseSk7CiAgICAgIGxvZygiTWVhc3VyZSDPiCBAKCIgKyB4ICsgIiwiICsgeSArICIpIHDiiYgiICsgcC50b0ZpeGVkKDQpICsgIiByMeKJiCIgKyBicC5yMS50b0ZpeGVkKDIpICsgIiDPhuKJiCIgKyBicC5waGkudG9GaXhlZCgyKSArICIgVnBvbGXiiYgiICsgVnAudG9GaXhlZCgzKSk7CiAgICAgIGlmIChkYmwpewogICAgICAgIGNvbnN0IHJhZCA9IDEwOwogICAgICAgIGZvciAobGV0IHl5PTA7IHl5PEg7IHl5KyspewogICAgICAgICAgZm9yIChsZXQgeHg9MDsgeHg8VzsgeHgrKyl7CiAgICAgICAgICAgIGNvbnN0IGlpPWlkeCh4eCx5eSk7CiAgICAgICAgICAgIGNvbnN0IGR4PXh4LXgsIGR5PXl5LXk7CiAgICAgICAgICAgIGlmIChkeCpkeCtkeSpkeSA+IHJhZCpyYWQpeyByZVtpaV09MDsgaW1baWldPTA7IH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbm9ybWFsaXplQVFDKCk7CiAgICAgICAgbG9nKCJDb2xsYXBzZToga2VwdCBzbWFsbCBkaXNrOyByZW5vcm1hbGl6ZWQuIik7CiAgICAgIH0KICAgICAgZHJhdygpOwogICAgICByZXR1cm47CiAgICB9IGVsc2UgewogICAgICBjb25zdCBiYXNlID0gVm9mUGhpKGJhc09mUGl4ZWwoeCx5KS5waGkpOwogICAgICBjb25zdCBWcCA9IHBvbGVQb3RlbnRpYWxBdCh4LHkpOwogICAgICBjb25zdCB0aCA9IChiYXNlICsgVnApICogMy4wOwogICAgICByZVtpXSArPSBNYXRoLmNvcyh0aCkqMC44OwogICAgICBpbVtpXSArPSBNYXRoLnNpbih0aCkqMC44OwogICAgICBub3JtYWxpemVBUUMoKTsKICAgIH0KICB9KTsKCiAgY3YuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcm1vdmUiLChlKT0+ewogICAgaWYgKCFwb2ludGVycy5oYXMoZS5wb2ludGVySWQpKSByZXR1cm47CiAgICBjb25zdCB7eCx5fSA9IGdldExvY2FsWFkoZSk7CiAgICBwb2ludGVycy5zZXQoZS5wb2ludGVySWQsIHt4LHksIGFyZWE6IGVzdGltYXRlQXJlYUZyb21FdmVudChlKSwgcHJlc3N1cmU6IGVzdGltYXRlUHJlc3N1cmUoZSl9KTsKICAgIGlmICghZS5idXR0b25zKSByZXR1cm47CgogICAgY29uc3QgbW9kZT1tb2RlRWwudmFsdWU7CiAgICBpZiAobW9kZT09PSJsaWZlIil7IGxpZmVbaWR4KHgseSldID0gMTsgcmV0dXJuOyB9CiAgICBpZiAobW9kZT09PSJwaXhlbGxpZmUiKXsgY29uc3QgaT1pZHgoeCx5KTsgUltpXT0xOyBHW2ldPTAuMTU7IEJbaV09MC4wNTsgcmV0dXJuOyB9CiAgICBpZiAobW9kZT09PSJhcWMiICYmICFlLnNoaWZ0S2V5KXsKICAgICAgY29uc3QgaT1pZHgoeCx5KTsKICAgICAgY29uc3QgYmFzZSA9IFZvZlBoaShiYXNPZlBpeGVsKHgseSkucGhpKTsKICAgICAgY29uc3QgVnAgPSBwb2xlUG90ZW50aWFsQXQoeCx5KTsKICAgICAgY29uc3QgdGggPSAoYmFzZSArIFZwKSAqIDMuMDsKICAgICAgcmVbaV0gKz0gTWF0aC5jb3ModGgpKjAuMTU7CiAgICAgIGltW2ldICs9IE1hdGguc2luKHRoKSowLjE1OwogICAgfQogIH0pOwoKICBmdW5jdGlvbiBjbGVhclB0cihlKXsgcG9pbnRlcnMuZGVsZXRlKGUucG9pbnRlcklkKTsgfQogIGN2LmFkZEV2ZW50TGlzdGVuZXIoInBvaW50ZXJ1cCIsIGNsZWFyUHRyKTsKICBjdi5hZGRFdmVudExpc3RlbmVyKCJwb2ludGVyY2FuY2VsIiwgY2xlYXJQdHIpOwoKICAvLyAtLS0tLS0tLS0tIEQyRCAtLS0tLS0tLS0tCiAgZnVuY3Rpb24gbGlzdGVuKCl7CiAgICBpZiAoYmMpIHsgbG9nKCJBbHJlYWR5IGxpc3RlbmluZy4iKTsgcmV0dXJuOyB9CiAgICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKCJiYXpfYXFjX2QyZCIpOwogICAgYmMub25tZXNzYWdlID0gKGV2KT0+ewogICAgICB0cnl7CiAgICAgICAgY29uc3QgbXNnID0gZXYuZGF0YSB8fCB7fTsKICAgICAgICBpZiAobXNnLnR5cGU9PT0icHJpbWVfa2VybmVsIiAmJiBBcnJheS5pc0FycmF5KG1zZy5wcmltZXMpICYmIEFycmF5LmlzQXJyYXkobXNnLncpKXsKICAgICAgICAgIHByaW1lcyA9IG1zZy5wcmltZXMuc2xpY2UoKTsKICAgICAgICAgIHcgPSBtc2cudy5zbGljZSgpOwogICAgICAgICAgd1BoYXNlID0gbXNnLndQaGFzZSB8fCAwOwogICAgICAgICAgcGtpbmZvLnRleHRDb250ZW50ID0gcHJpbWVzLmxlbmd0aCArICIgcHJpbWVzIChyeCkiOwogICAgICAgICAgbG9nKCJSZWNlaXZlZCBwcmltZSBrZXJuZWwuIHByaW1lcz0iICsgcHJpbWVzLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmIChtc2cudHlwZT09PSJwYXJhbXMiKXsKICAgICAgICAgIGlmICh0eXBlb2YgbXNnLnIyID09PSAibnVtYmVyIikgcjJFbC52YWx1ZSA9IFN0cmluZyhtc2cucjIpOwogICAgICAgICAgaWYgKHR5cGVvZiBtc2cuZHQgPT09ICJudW1iZXIiKSBkdEVsLnZhbHVlID0gU3RyaW5nKG1zZy5kdCk7CiAgICAgICAgICBpZiAodHlwZW9mIG1zZy5hbHBoYSA9PT0gIm51bWJlciIpIGFscGhhRWwudmFsdWUgPSBTdHJpbmcobXNnLmFscGhhKTsKICAgICAgICAgIGlmICh0eXBlb2YgbXNnLmdhbW1hID09PSAibnVtYmVyIikgZ2FtbWFFbC52YWx1ZSA9IFN0cmluZyhtc2cuZ2FtbWEpOwogICAgICAgICAgaWYgKHR5cGVvZiBtc2cuVmsgPT09ICJudW1iZXIiKSBWa0VsLnZhbHVlID0gU3RyaW5nKG1zZy5Wayk7CiAgICAgICAgICBpZiAodHlwZW9mIG1zZy5zaWdtYSA9PT0gIm51bWJlciIpIHNpZ21hRWwudmFsdWUgPSBTdHJpbmcobXNnLnNpZ21hKTsKICAgICAgICAgIGlmICh0eXBlb2YgbXNnLmdhaW4gPT09ICJudW1iZXIiKSBnYWluRWwudmFsdWUgPSBTdHJpbmcobXNnLmdhaW4pOwogICAgICAgICAgaWYgKHR5cGVvZiBtc2cuY2FwT24gPT09ICJzdHJpbmciKSBjYXBPbkVsLnZhbHVlID0gbXNnLmNhcE9uOwogICAgICAgICAgbG9nKCJSZWNlaXZlZCBwYXJhbXMuIik7CiAgICAgICAgfQogICAgICB9Y2F0Y2goZSl7IGxvZygiQkMgZXJyb3I6ICIgKyAoZT8ubWVzc2FnZXx8ZSkpOyB9CiAgICB9OwogICAgbG9nKCJMaXN0ZW5pbmcgb24gYmF6X2FxY19kMmQgKHNhbWUtb3JpZ2luIHRhYnMpLiIpOwogIH0KCiAgZnVuY3Rpb24gYnJvYWRjYXN0KCl7CiAgICBpZiAoIWJjKSBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKCJiYXpfYXFjX2QyZCIpOwogICAgYmMucG9zdE1lc3NhZ2UoeyB0eXBlOiJwcmltZV9rZXJuZWwiLCBwcmltZXMsIHcsIHdQaGFzZSB9KTsKICAgIGJjLnBvc3RNZXNzYWdlKHsKICAgICAgdHlwZToicGFyYW1zIiwKICAgICAgcjI6IHBhcnNlRmxvYXQocjJFbC52YWx1ZSksCiAgICAgIGR0OiBwYXJzZUZsb2F0KGR0RWwudmFsdWUpLAogICAgICBhbHBoYTogcGFyc2VGbG9hdChhbHBoYUVsLnZhbHVlKSwKICAgICAgZ2FtbWE6IHBhcnNlRmxvYXQoZ2FtbWFFbC52YWx1ZSksCiAgICAgIFZrOiBwYXJzZUZsb2F0KFZrRWwudmFsdWUpLAogICAgICBzaWdtYTogcGFyc2VGbG9hdChzaWdtYUVsLnZhbHVlKSwKICAgICAgZ2FpbjogcGFyc2VGbG9hdChnYWluRWwudmFsdWUpLAogICAgICBjYXBPbjogY2FwT25FbC52YWx1ZQogICAgfSk7CiAgICBsb2coIkJyb2FkY2FzdCBzZW50LiIpOwogIH0KCiAgLy8gLS0tLS0tLS0tLSBNYWluIGxvb3AgLS0tLS0tLS0tLQogIGxldCBmcmFtZXM9MCwgbGFzdEY9cGVyZm9ybWFuY2Uubm93KCk7CiAgZnVuY3Rpb24gbG9vcCgpewogICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICBpZiAocnVubmluZykgdGljaygpOwogICAgZHJhdygpOwogICAgZnJhbWVzKys7CiAgICBpZiAobm93LWxhc3RGPjUwMCl7CiAgICAgIGNvbnN0IGZwcyA9IGZyYW1lcyoxMDAwLyhub3ctbGFzdEYpOwogICAgICBmcHNFbC50ZXh0Q29udGVudCA9IGZwcy50b0ZpeGVkKDEpOwogICAgICBmcmFtZXM9MDsgbGFzdEY9bm93OwogICAgfQogICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApOwogIH0KCiAgZnVuY3Rpb24gdWlTeW5jKCl7CiAgICByMnYudGV4dENvbnRlbnQgPSBwYXJzZUZsb2F0KHIyRWwudmFsdWUpLnRvRml4ZWQoMik7CiAgICBzaWd2LnRleHRDb250ZW50ID0gU3RyaW5nKHBhcnNlSW50KHNpZ21hRWwudmFsdWUsMTApKTsKICAgIGdhaW52LnRleHRDb250ZW50ID0gcGFyc2VGbG9hdChnYWluRWwudmFsdWUpLnRvRml4ZWQoMik7CiAgfQogIHIyRWwuYWRkRXZlbnRMaXN0ZW5lcigiaW5wdXQiLCB1aVN5bmMpOwogIHNpZ21hRWwuYWRkRXZlbnRMaXN0ZW5lcigiaW5wdXQiLCB1aVN5bmMpOwogIGdhaW5FbC5hZGRFdmVudExpc3RlbmVyKCJpbnB1dCIsIHVpU3luYyk7CiAgdWlTeW5jKCk7CgogIGJ1aWxkUHJpbWVLZXJuZWwocGFyc2VJbnQocHJpbWVORWwudmFsdWUsMTApKTsKICBzZWVkKCk7CiAgZHJhdygpOwogIGxvb3AoKTsKfSkoKTsKPC9zY3JpcHQ+CjwvYm9keT4KPC9odG1sPgo=";
  const AQC_LAB_HTML = atob(AQC_LAB_HTML_B64);



  // ============================================================
  // 0.5) Local App Loader (Directory / File pick)
  //     - Loads .html single-file apps from a chosen folder (or file picker fallback)
  //     - Launches them in draggable overlay iframes (DOM windows above the pixel OS)
  // ============================================================
  const webWindows = $("webWindows");
  const LoadedApps = {
    list: [], // {name, handle}
    async pick() {
      this.list = [];
      // Prefer directory picker when available
      try {
        if (window.showDirectoryPicker) {
          const dir = await window.showDirectoryPicker({ mode: "read" });
          for await (const [name, handle] of dir.entries()) {
            if (handle.kind === "file" && /\.(html?|HTML?)$/.test(name)) {
              this.list.push({ name, handle });
            }
          }
          this.list.sort((a,b) => a.name.localeCompare(b.name));
          log(`Loaded ${this.list.length} app(s) from folder.`);
          toast(`Loaded ${this.list.length} app(s)`);
          return this.list.length;
        }
      } catch (e) {
        log("Directory picker cancelled/blocked: " + (e?.message || e));
      }
      // Fallback: multi-file picker
      try {
        if (window.showOpenFilePicker) {
          const handles = await window.showOpenFilePicker({
            multiple: true,
            types: [{ description: "HTML apps", accept: { "text/html": [".html",".htm"] } }]
          });
          for (const h of handles) this.list.push({ name: h.name, handle: h });
          this.list.sort((a,b) => a.name.localeCompare(b.name));
          log(`Loaded ${this.list.length} app(s) from file picker.`);
          toast(`Loaded ${this.list.length} app(s)`);
          return this.list.length;
        }
      } catch (e) {
        log("File picker cancelled/blocked: " + (e?.message || e));
      }
      toast("App loading not available here");
      log("App loading not available: needs Chrome with File System Access API.");
      return 0;
    },
    // name shown in OS: strip extension and trim
    label(name) {
      return String(name).replace(/\.(html?|HTML?)$/,"").slice(0,7).toUpperCase();
    }
  };

  // DOM web window manager (simple)
  let webZ = 10000;
    function openWebApp(app) {
    // app: {name, handle} OR {name, text}
    const win = document.createElement("div");
    win.className = "webwin";
    win.style.zIndex = String(++webZ);

    // Cascade placement
    const left = 12 + (webZ % 7) * 10;
    const top  = 12 + (webZ % 9) * 10;
    win.style.left = left + "px";
    win.style.top  = top  + "px";

    const header = document.createElement("div");
    header.className = "webwinHeader";
    header.innerHTML = `
      <div class="webwinTitle">${escapeHtml(app?.name || "App")}</div>
      <div class="webwinBtns">
        <button class="webbtn" data-act="reload">↻</button>
        <button class="webbtn" data-act="close">✕</button>
      </div>
    `;

    const body = document.createElement("div");
    body.className = "webwinBody";

    const iframe = document.createElement("iframe");
    iframe.setAttribute("referrerpolicy","no-referrer");
    iframe.setAttribute(
      "sandbox",
      "allow-scripts allow-forms allow-modals allow-downloads allow-popups allow-popups-to-escape-sandbox allow-same-origin"
    );
    body.appendChild(iframe);

    win.appendChild(header);
    win.appendChild(body);
    webWindows.appendChild(win);

    async function load() {
      try {
        let text = "";
        if (app && typeof app.text === "string") {
          text = app.text;
        } else if (app && app.handle && app.handle.getFile) {
          const file = await app.handle.getFile();
          text = await file.text();
        } else {
          throw new Error("App has no content (no .text and no .handle).");
        }
        iframe.srcdoc = text;
        toast("Opened: " + (app?.name || "App"));
      } catch (e) {
        toast("Failed to open app");
        log("Open app failed: " + (e?.message || e));
      }
    }

    load();

    header.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const act = btn.dataset.act;
        if (act === "close") win.remove();
        if (act === "reload") load();
      });
    });

    // bring to front
    win.addEventListener("pointerdown", () => win.style.zIndex = String(++webZ));

    // drag
    makeDomDraggable(header, win);
  }

  function makeDomDraggable(handle, el) {
    let dragging = false, sx=0, sy=0, ox=0, oy=0;

    handle.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;
      dragging = true;
      el.style.zIndex = String(++webZ);
      try { handle.setPointerCapture(e.pointerId); } catch {}
      sx = e.clientX; sy = e.clientY;
      const r = el.getBoundingClientRect();
      ox = r.left; oy = r.top;
    });

    handle.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - sx, dy = e.clientY - sy;
      const nx = Math.max(6, Math.min(window.innerWidth  - el.offsetWidth  - 6, ox + dx));
      const ny = Math.max(6, Math.min(window.innerHeight - el.offsetHeight - 6, oy + dy));
      el.style.left = nx + "px";
      el.style.top  = ny + "px";
    });

    function stop(e){
      dragging = false;
      try { handle.releasePointerCapture(e.pointerId); } catch {}
    }
    handle.addEventListener("pointerup", stop);
    handle.addEventListener("pointercancel", stop);
  }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }


  // ============================================================
  // 1) PPU-ish tile engine (paletted)
  //    - Screen: W x H
  //    - Tile grid: (W/T) x (H/T), T=8
  //    - Tile registry: unique 8x8 tiles stored once
  //    - Framebuffer: paletted indices (Uint8Array), plus RGBA ImageData for display
  //    - Dirty tiles: only changed tiles are blitted into framebuffer
  // ============================================================
  const canvas = $("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  const W = canvas.width, H = canvas.height;
  const T = 8;
  const TX = Math.floor(W / T), TY = Math.floor(H / T);

  // Palette: 256 entries (GIF-friendly). We'll use first ~24.
  const palette = new Uint8Array(256 * 3);
  function setPal(i, r, g, b){ palette[i*3]=r; palette[i*3+1]=g; palette[i*3+2]=b; }
  // A compact dark UI palette
  setPal(0, 0,0,0);
  setPal(1, 15,15,18);
  setPal(2, 30,30,36);
  setPal(3, 52,52,64);
  setPal(4, 90,90,110);
  setPal(5, 140,140,165);
  setPal(6, 220,220,235);
  setPal(7, 255,255,255);
  setPal(8, 40,160,255);   // blue
  setPal(9, 255,160,60);   // orange
  setPal(10, 120,255,170); // mint
  setPal(11, 255,90,120);  // pink
  setPal(12, 180,120,255); // purple
  setPal(13, 120,200,255); // sky
  setPal(14, 255,220,120); // sand
  setPal(15, 90,255,120);  // green
  // fill rest with a grayscale ramp (optional)
  for (let i=16;i<256;i++){
    const v = Math.max(0, Math.min(255, Math.round((i-16) / (256-16) * 255)));
    setPal(i, v, v, v);
  }

  // Framebuffers
  const fbIdx = new Uint8Array(W * H);            // palette indices
  const img = ctx.createImageData(W, H);          // RGBA for display
  const rgba = img.data;

  // Tile map (screen = indices into tile registry)
  const tileMap = new Uint16Array(TX * TY);
  const dirty = new Uint8Array(TX * TY); // 0/1
  let dirtyCount = 0;

  // Tile registry: each tile is 64 bytes of palette indices.
  // Dedup by key (string). For speed: key = bytes joined with ',' (fine at this scale).
  const tiles = [];           // Array<Uint8Array(64)>
  const tileKeyToId = new Map();

  function tileKey(bytes) {
    // small & fast key: base64 of bytes
    let s = "";
    for (let i=0;i<64;i++) s += String.fromCharCode(bytes[i]);
    return btoa(s);
  }

  function registerTile(bytes) {
    const k = tileKey(bytes);
    const hit = tileKeyToId.get(k);
    if (hit !== undefined) return hit;
    const id = tiles.length;
    tiles.push(bytes);
    tileKeyToId.set(k, id);
    return id;
  }

  function markDirty(tx, ty) {
    if (tx<0||ty<0||tx>=TX||ty>=TY) return;
    const i = ty*TX + tx;
    if (dirty[i] === 0) { dirty[i] = 1; dirtyCount++; }
  }

  function setTile(tx, ty, tileId) {
    if (tx<0||ty<0||tx>=TX||ty>=TY) return;
    const i = ty*TX + tx;
    if (tileMap[i] !== tileId) {
      tileMap[i] = tileId;
      markDirty(tx, ty);
    }
  }

  function clearDirtyAll() {
    dirty.fill(1);
    dirtyCount = TX*TY;
  }

  function blitDirtyTiles() {
    if (dirtyCount === 0) return 0;
    let updated = 0;

    for (let ty=0; ty<TY; ty++) {
      for (let tx=0; tx<TX; tx++) {
        const di = ty*TX + tx;
        if (!dirty[di]) continue;

        const tileId = tileMap[di];
        const tile = tiles[tileId] || tiles[0];
        // write paletted pixels to fbIdx and rgba
        const x0 = tx*T, y0 = ty*T;

        let p = 0;
        for (let y=0; y<T; y++) {
          const row = (y0+y)*W + x0;
          const rowRGBA = (row)*4;
          for (let x=0; x<T; x++) {
            const idx = tile[p++];
            fbIdx[row + x] = idx;
            const off = rowRGBA + x*4;
            rgba[off]   = palette[idx*3];
            rgba[off+1] = palette[idx*3+1];
            rgba[off+2] = palette[idx*3+2];
            rgba[off+3] = 255;
          }
        }
        dirty[di] = 0;
        updated++;
      }
    }

    dirtyCount = 0;
    return updated;
  }

  function present() {
    ctx.putImageData(img, 0, 0);
  }

  // ============================================================
  // 2) Tiny bitmap font (5x7) -> tiles/sprites
  // ============================================================
  const FONT = {
    " ": [0,0,0,0,0,0,0],
    "A": [0x0E,0x11,0x11,0x1F,0x11,0x11,0x11],
    "B": [0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E],
    "C": [0x0E,0x11,0x10,0x10,0x10,0x11,0x0E],
    "D": [0x1C,0x12,0x11,0x11,0x11,0x12,0x1C],
    "E": [0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F],
    "F": [0x1F,0x10,0x10,0x1E,0x10,0x10,0x10],
    "G": [0x0E,0x11,0x10,0x17,0x11,0x11,0x0F],
    "H": [0x11,0x11,0x11,0x1F,0x11,0x11,0x11],
    "I": [0x0E,0x04,0x04,0x04,0x04,0x04,0x0E],
    "J": [0x07,0x02,0x02,0x02,0x12,0x12,0x0C],
    "K": [0x11,0x12,0x14,0x18,0x14,0x12,0x11],
    "L": [0x10,0x10,0x10,0x10,0x10,0x10,0x1F],
    "M": [0x11,0x1B,0x15,0x11,0x11,0x11,0x11],
    "N": [0x11,0x19,0x15,0x13,0x11,0x11,0x11],
    "O": [0x0E,0x11,0x11,0x11,0x11,0x11,0x0E],
    "P": [0x1E,0x11,0x11,0x1E,0x10,0x10,0x10],
    "Q": [0x0E,0x11,0x11,0x11,0x15,0x12,0x0D],
    "R": [0x1E,0x11,0x11,0x1E,0x14,0x12,0x11],
    "S": [0x0F,0x10,0x10,0x0E,0x01,0x01,0x1E],
    "T": [0x1F,0x04,0x04,0x04,0x04,0x04,0x04],
    "U": [0x11,0x11,0x11,0x11,0x11,0x11,0x0E],
    "V": [0x11,0x11,0x11,0x11,0x11,0x0A,0x04],
    "W": [0x11,0x11,0x11,0x11,0x15,0x1B,0x11],
    "X": [0x11,0x11,0x0A,0x04,0x0A,0x11,0x11],
    "Y": [0x11,0x11,0x0A,0x04,0x04,0x04,0x04],
    "Z": [0x1F,0x01,0x02,0x04,0x08,0x10,0x1F],
    "0": [0x0E,0x11,0x13,0x15,0x19,0x11,0x0E],
    "1": [0x04,0x0C,0x04,0x04,0x04,0x04,0x0E],
    "2": [0x0E,0x11,0x01,0x02,0x04,0x08,0x1F],
    "3": [0x1F,0x02,0x04,0x02,0x01,0x11,0x0E],
    "4": [0x02,0x06,0x0A,0x12,0x1F,0x02,0x02],
    "5": [0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E],
    "6": [0x06,0x08,0x10,0x1E,0x11,0x11,0x0E],
    "7": [0x1F,0x01,0x02,0x04,0x08,0x08,0x08],
    "8": [0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E],
    "9": [0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C],
    ".": [0x00,0x00,0x00,0x00,0x00,0x06,0x06],
    ":": [0x00,0x06,0x06,0x00,0x06,0x06,0x00],
    "-": [0x00,0x00,0x00,0x1F,0x00,0x00,0x00],
    "_": [0x00,0x00,0x00,0x00,0x00,0x00,0x1F],
    "/": [0x01,0x02,0x04,0x08,0x10,0x00,0x00],
    "[": [0x0E,0x08,0x08,0x08,0x08,0x08,0x0E],
    "]": [0x0E,0x02,0x02,0x02,0x02,0x02,0x0E],
    "(": [0x06,0x08,0x10,0x10,0x10,0x08,0x06],
    ")": [0x0C,0x02,0x01,0x01,0x01,0x02,0x0C],
    "!": [0x04,0x04,0x04,0x04,0x04,0x00,0x04],
    "?": [0x0E,0x11,0x01,0x02,0x04,0x00,0x04],
  };

  function drawCharToTileBytes(ch, fg=7, bg=1) {
    const bytes = new Uint8Array(64);
    const rows = FONT[ch] || FONT["?"];
    // tile background
    bytes.fill(bg);
    // render 5x7 at (1,0) with 1px left pad and 1px bottom pad
    for (let y=0; y<7; y++) {
      const row = rows[y] || 0;
      for (let x=0; x<5; x++) {
        const on = (row >> (4-x)) & 1;
        if (on) {
          const tx = 1 + x;
          const ty = 0 + y;
          bytes[ty*8 + tx] = fg;
        }
      }
    }
    return bytes;
  }

  // Cache char tiles (fg/bg combos we use)
  const charTileCache = new Map(); // key: ch|fg|bg -> tileId
  function getCharTile(ch, fg=7, bg=1) {
    const k = `${ch}|${fg}|${bg}`;
    const hit = charTileCache.get(k);
    if (hit !== undefined) return hit;
    const id = registerTile(drawCharToTileBytes(ch, fg, bg));
    charTileCache.set(k, id);
    return id;
  }

  // ============================================================
  // 3) OS primitives: rect fills, text, panels, buttons
  //    Everything maps to tiles.
  // ============================================================
  function solidTile(colorIdx) {
    const b = new Uint8Array(64);
    b.fill(colorIdx);
    return registerTile(b);
  }
  const TILE_BG = solidTile(1);
  const TILE_BG2 = solidTile(2);
  const TILE_PANEL = solidTile(2);
  const TILE_PANEL2 = solidTile(3);
  const TILE_WHITE = solidTile(7);

  function drawRectTiles(x, y, w, h, tileId) {
    // coords in tiles
    for (let ty=y; ty<y+h; ty++) for (let tx=x; tx<x+w; tx++) setTile(tx, ty, tileId);
  }

  function drawText(tx, ty, text, fg=7, bg=1) {
    const s = String(text || "");
    for (let i=0;i<s.length;i++) {
      const ch = s[i].toUpperCase();
      setTile(tx+i, ty, getCharTile(ch, fg, bg));
    }
  }

  // A simple beveled button 2 tiles tall
  function buttonTilePair(label, fg=7, bg=3) {
    // return [topRowTileId, bottomRowTileId] for a 1x2 tile "button cell"
    // We'll draw label separately; these are background with bevel lines.
    const top = new Uint8Array(64); top.fill(bg);
    const bot = new Uint8Array(64); bot.fill(bg);
    // bevel
    for (let x=0;x<8;x++){ top[x]=4; }                // top highlight
    for (let y=0;y<8;y++){ top[y*8]=4; bot[y*8]=4; } // left highlight
    for (let x=0;x<8;x++){ bot[(7)*8 + x]=1; }        // bottom shadow
    for (let y=0;y<8;y++){ top[y*8+7]=1; bot[y*8+7]=1; } // right shadow
    return [registerTile(top), registerTile(bot)];
  }
  const [BTN_TOP, BTN_BOT] = buttonTilePair("");

  // ============================================================
  // 4) GIF-OS state machine
  // ============================================================
  const OS = {
    booted: false,
    demo: false,
    time: 0,
    cursor: { x: 120, y: 80, down: false },
    startOpen: false,
    icons: [
      { id:"NOTEPAD", x: 2, y: 2, glyph:"N", label:"NOTEPAD" },
      { id:"DEMO", x: 2, y: 6, glyph:"D", label:"DEMO" },
    ],
    loadedApps: [], // populated via Load Apps button/menu
    menuItems: [],
    windows: [], // {id,title,x,y,w,h,drag,bodyLines[],scroll}
    focusWin: null,
  };

  function resetOS() {
    OS.booted = false;
    OS.demo = false;
    OS.time = 0;
    OS.startOpen = false;
    OS.windows = [];
    OS.focusWin = null;
    OS.cursor = { x: 120, y: 80, down: false };
    tiles.length = 0;
    tileKeyToId.clear();
    charTileCache.clear();

    // Re-register essential tiles after clearing registry
    // (solidTile uses registerTile, so we recreate constants)
    // Easiest: reload page? Instead: we just re-run solid tiles now.
    // We'll just store ids in a fresh object and reference it via closures.
  }

  // Because we cleared tiles on reset, we need to rebuild the solid tiles and button tiles too.
  // We'll do that in boot() which reconstructs palette-backed tiles.

  let TILE = {}; // updated in boot

  function boot() {
    // ensure base tiles exist
    TILE = {
      BG: solidTile(1),
      BG2: solidTile(2),
      PANEL: solidTile(2),
      PANEL2: solidTile(3),
      WHITE: solidTile(7),
      CURSOR: (() => {
        const b = new Uint8Array(64); b.fill(0);
        // crosshair
        for (let i=0;i<8;i++) { b[3*8+i]=7; b[i*8+3]=7; }
        b[3*8+3]=11;
        return registerTile(b);
      })(),
      ICON: (() => {
        const b = new Uint8Array(64); b.fill(2);
        // border
        for (let x=0;x<8;x++){ b[x]=4; b[7*8+x]=1; }
        for (let y=0;y<8;y++){ b[y*8]=4; b[y*8+7]=1; }
        return registerTile(b);
      })(),
      TASKBAR: solidTile(2),
      BTN_TOP: (() => {
        const top = new Uint8Array(64); top.fill(3);
        for (let x=0;x<8;x++){ top[x]=4; }
        for (let y=0;y<8;y++){ top[y*8]=4; top[y*8+7]=1; }
        return registerTile(top);
      })(),
      BTN_BOT: (() => {
        const bot = new Uint8Array(64); bot.fill(3);
        for (let x=0;x<8;x++){ bot[7*8+x]=1; }
        for (let y=0;y<8;y++){ bot[y*8]=4; bot[y*8+7]=1; }
        return registerTile(bot);
      })(),
      WIN_BG: solidTile(1),
      WIN_BAR: solidTile(3),
      WIN_BODY: solidTile(2),
    };

    OS.booted = true;
    OS.demo = false;
    OS.startOpen = false;
    OS.windows = [];
    OS.focusWin = null;

    // Clear screen
    for (let i=0;i<TX*TY;i++) tileMap[i] = TILE.BG;
    clearDirtyAll();

    drawDesktop();
    presentTick(true);

    log("Boot complete. Tap Start (bottom-left in screen).");
    toast("Booted");
  }

  function drawDesktop() {
    // background
    drawRectTiles(0,0,TX,TY, TILE.BG);
    // subtle vignette by swapping some edges
    for (let x=0;x<TX;x++){ setTile(x,0,TILE.BG2); setTile(x,TY-1,TILE.BG2); }
    for (let y=0;y<TY;y++){ setTile(0,y,TILE.BG2); setTile(TX-1,y,TILE.BG2); }

    // icons
    for (const ic of OS.icons) {
      // (fixed icons first)

      setTile(ic.x, ic.y, TILE.ICON);
      drawText(ic.x, ic.y, ic.glyph, 10, 2);
      drawText(ic.x+2, ic.y, ic.glyph, 10, 2); // bolder-ish
      drawText(ic.x, ic.y+1, ic.label.slice(0,7), 6, 1);

    }

    // dynamic app icons (loaded from folder)
    // place in a simple grid on the left
    if (OS.loadedApps && OS.loadedApps.length) {
      const startX = 8, startY = 2;
      const cols = Math.max(1, Math.floor((TX - startX - 1) / 2));
      for (let i=0;i<OS.loadedApps.length;i++) {
        const app = OS.loadedApps[i];
        const gx = startX + (i % cols) * 2;
        const gy = startY + Math.floor(i / cols) * 3;
        if (gy >= TY-5) break;
        setTile(gx, gy, TILE.ICON);
        drawText(gx, gy, app.glyph, 13, 2);
        drawText(gx, gy+1, app.label.slice(0,7), 6, 1);
      }
    }

    // taskbar (2 tiles tall)
    const tbY = TY-2;
    drawRectTiles(0, tbY, TX, 2, TILE.TASKBAR);

    // Start button: 6 tiles wide x 2 tall, at (0,tbY)
    for (let x=0;x<6;x++){ setTile(x, tbY, TILE.BTN_TOP); setTile(x, tbY+1, TILE.BTN_BOT); }
    drawText(1, tbY, "START", 7, 3);

    // clock on right
    const time = new Date();
    const hh = String(time.getHours()).padStart(2,"0");
    const mm = String(time.getMinutes()).padStart(2,"0");
    const clock = `${hh}:${mm}`;
    drawText(TX - clock.length - 2, tbY, clock, 6, 2);

    // start menu (if open)
    if (OS.startOpen) drawStartMenu();
  }

  function drawStartMenu() {
    const tbY = TY-2;

    // Build menu items dynamically
    const items = [];
    items.push({ type:"action", id:"LOADAPPS", label:"LOAD APPS" });
    items.push({ type:"action", id:"NOTEPAD",  label:"NOTEPAD" });
    items.push({ type:"action", id:"DEMO",     label:"DEMO" });

    // Add loaded apps (up to 6 visible slots after header)
    if (OS.loadedApps && OS.loadedApps.length) {
      for (const a of OS.loadedApps) {
        items.push({ type:"app", id:a.id, label:a.label, app:a });
      }
    }

    items.push({ type:"action", id:"CLOSE", label:"CLOSE" });

    // Keep a copy for hit-testing
    OS.menuItems = items;

    // Menu geometry: header 2 tiles + N items (2 tiles each), cap to fit
    const maxItems = Math.min(items.length, 6); // visible rows
    const menuW = 18;
    const menuH = 2 + maxItems*2;
    const mx = 0, my = tbY - menuH;

    drawRectTiles(mx, my, menuW, menuH, TILE.PANEL);
    drawRectTiles(mx, my, menuW, 2, TILE.PANEL2);
    drawText(mx+1, my, "START MENU", 7, 3);

    for (let i=0;i<maxItems;i++) {
      const it = items[i];
      const yy = my + 2 + i*2;
      drawText(mx+1, yy, (it.label || "").padEnd(menuW-2," ").slice(0,menuW-2), 6, 2);
      const hint = (it.type === "app") ? "OPEN HTML APP" : "TAP";
      drawText(mx+1, yy+1, hint.padEnd(menuW-2," ").slice(0,menuW-2), 4, 1);
    }
  }

  function openNotepad() {
    const win = {
      id: "NOTEPAD",
      title: "NOTEPAD",
      x: 6, y: 3, w: 20, h: 10, // in tiles
      dragging: false, dragOffX:0, dragOffY:0,
      bodyLines: [
        "GIF-OS NOTEPAD",
        "",
        "This OS is tiles + deltas.",
        "Next: filesystem vault, apps.",
        "",
        "Tap title bar and drag.",
      ],
      scroll: 0
    };
    OS.windows.push(win);
    OS.focusWin = win.id;
    OS.startOpen = false;
    redrawAll();
    toast("Notepad opened");
  }

  function toggleDemo() {
    OS.demo = !OS.demo;
    toast(OS.demo ? "Demo animation on" : "Demo animation off");
    log("Demo: " + (OS.demo ? "ON" : "OFF"));
  }

  function redrawAll() {
    drawDesktop();
    drawWindows();
    drawCursor();
    clearDirtyAll();
    presentTick(true);
  }

  function drawWindows() {
    for (const win of OS.windows) {
      const {x,y,w,h} = win;
      // window background
      drawRectTiles(x,y,w,h, TILE.WIN_BG);
      // title bar (2 tiles)
      drawRectTiles(x,y,w,2, TILE.WIN_BAR);
      drawText(x+1, y, win.title.padEnd(w-2," ").slice(0,w-2), 7, 3);
      // close button at right
      setTile(x+w-2, y, getCharTile("X", 11, 3));
      // body
      drawRectTiles(x,y+2,w,h-2, TILE.WIN_BODY);
      // body text
      const maxLines = h-3;
      for (let i=0;i<maxLines;i++) {
        const line = win.bodyLines[win.scroll + i] || "";
        drawText(x+1, y+2+i, line.padEnd(w-2," ").slice(0,w-2), 6, 2);
      }
    }
  }

  function drawCursor() {
    // cursor is drawn as tile overlay at its tile position (simple)
    const tx = Math.floor(OS.cursor.x / T);
    const ty = Math.floor(OS.cursor.y / T);
    setTile(tx, ty, TILE.CURSOR);
    markDirty(tx, ty);
  }

  // ============================================================
  // 5) Input mapping (touch/mouse) -> tile-space hit tests
  // ============================================================
  function screenToPx(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (W / rect.width);
    const y = (clientY - rect.top) * (H / rect.height);
    return { x: Math.max(0, Math.min(W-1, x)), y: Math.max(0, Math.min(H-1, y)) };
  }

  function hitStartButton(px, py) {
    const tbY = TY-2;
    const tx = Math.floor(px / T);
    const ty = Math.floor(py / T);
    return (ty === tbY || ty === tbY+1) && tx >= 0 && tx < 6;
  }

  function hitStartMenuItem(px, py) {
    if (!OS.startOpen) return null;
    const tbY = TY-2;

    const items = OS.menuItems || [];
    const maxItems = Math.min(items.length, 6);
    const menuW = 18;
    const menuH = 2 + maxItems*2;
    const mx = 0, my = tbY - menuH;

    const tx = Math.floor(px / T);
    const ty = Math.floor(py / T);
    if (tx < mx || tx >= mx+menuW || ty < my || ty >= my+menuH) return null;

    const relY = ty - (my + 2);
    if (relY < 0) return null;
    const idx = Math.floor(relY / 2);
    if (idx < 0 || idx >= maxItems) return null;
    return items[idx] || null;
  }

  function hitIcon(px, py) {
    const tx = Math.floor(px / T);
    const ty = Math.floor(py / T);

    // fixed icons
    for (const ic of OS.icons) {
      if (tx === ic.x && ty === ic.y) return { type:"action", id: ic.id };
    }

    // dynamic icons grid
    if (OS.loadedApps && OS.loadedApps.length) {
      const startX = 8, startY = 2;
      const cols = Math.max(1, Math.floor((TX - startX - 1) / 2));
      for (let i=0;i<OS.loadedApps.length;i++) {
        const app = OS.loadedApps[i];
        const gx = startX + (i % cols) * 2;
        const gy = startY + Math.floor(i / cols) * 3;
        if (gy >= TY-5) break;
        if (tx === gx && ty === gy) return { type:"app", app };
      }
    }
    return null;
  }

  function hitWindowTitle(px, py) {
    const tx = Math.floor(px / T);
    const ty = Math.floor(py / T);
    // check topmost last
    for (let i=OS.windows.length-1;i>=0;i--) {
      const w = OS.windows[i];
      if (tx >= w.x && tx < w.x+w.w && (ty === w.y || ty === w.y+1)) {
        // close hit?
        if (tx === w.x+w.w-2 && ty === w.y) return { type:"close", win:w };
        return { type:"drag", win:w, offX: tx - w.x, offY: ty - w.y };
      }
    }
    return null;
  }

  function bringToFront(win) {
    const idx = OS.windows.indexOf(win);
    if (idx >= 0 && idx !== OS.windows.length-1) {
      OS.windows.splice(idx, 1);
      OS.windows.push(win);
    }
    OS.focusWin = win.id;
  }

  function closeWin(win) {
    const idx = OS.windows.indexOf(win);
    if (idx >= 0) OS.windows.splice(idx, 1);
    OS.focusWin = OS.windows.length ? OS.windows[OS.windows.length-1].id : null;
    redrawAll();
    toast("Window closed");
  }

  let activeDrag = null; // { win, offX, offY }
  function onDown(px, py) {
    OS.cursor.down = true;

    // Start
    if (hitStartButton(px, py)) {
      OS.startOpen = !OS.startOpen;
      redrawAll();
      toast(OS.startOpen ? "Menu open" : "Menu closed");
      return;
    }

    // Start menu item
    const item = hitStartMenuItem(px, py);
    if (item) {
      if (item.type === "action" && item.id === "NOTEPAD") openNotepad();
      if (item.type === "action" && item.id === "DEMO") toggleDemo();
      if (item.type === "action" && item.id === "CLOSE") { OS.startOpen = false; redrawAll(); }
      if (item.type === "action" && item.id === "LOADAPPS") {
        OS.startOpen = false;
        redrawAll();
        (async () => {
          const n = await LoadedApps.pick();
          if (n > 0) {
            // Add to OS registry list
            OS.loadedApps = LoadedApps.list.map((a, idx) => ({
              id: "APP_" + idx,
              name: a.name,
              handle: a.handle,
              label: LoadedApps.label(a.name),
              glyph: LoadedApps.label(a.name).slice(0,1) || "A"
            }));
            log("Apps available in Start menu and desktop grid.");
            redrawAll();
          }
        })();
      }
      if (item.type === "app" && item.app) {
        OS.startOpen = false;
        redrawAll();
        openWebApp(item.app);
      }
      return;
    }

    // Window title drag/close
    const hitW = hitWindowTitle(px, py);
    if (hitW) {
      bringToFront(hitW.win);
      if (hitW.type === "close") {
        closeWin(hitW.win);
        return;
      }
      activeDrag = { win: hitW.win, offX: hitW.offX, offY: hitW.offY };
      hitW.win.dragging = true;
      redrawAll();
      return;
    }

    // Icon click
    const icon = hitIcon(px, py);
    if (icon) {
      if (icon.type === "action" && icon.id === "NOTEPAD") openNotepad();
      if (icon.type === "action" && icon.id === "DEMO") toggleDemo();
      if (icon.type === "app" && icon.app) openWebApp(icon.app);
      return;
    }

    // click outside closes menu
    if (OS.startOpen) {
      OS.startOpen = false;
      redrawAll();
    }
  }

  function onMove(px, py) {
    OS.cursor.x = px; OS.cursor.y = py;

    if (activeDrag && activeDrag.win) {
      const tx = Math.floor(px / T);
      const ty = Math.floor(py / T);
      const nx = Math.max(1, Math.min(TX - activeDrag.win.w - 1, tx - activeDrag.offX));
      const ny = Math.max(1, Math.min(TY - activeDrag.win.h - 3, ty - activeDrag.offY)); // keep above taskbar
      if (nx !== activeDrag.win.x || ny !== activeDrag.win.y) {
        activeDrag.win.x = nx;
        activeDrag.win.y = ny;
        redrawAll();
      } else {
        // just cursor redraw
        drawDesktop(); drawWindows(); drawCursor();
        clearDirtyAll();
      }
    } else {
      // cursor only
      drawDesktop();
      drawWindows();
      drawCursor();
      clearDirtyAll();
    }
  }

  function onUp() {
    OS.cursor.down = false;
    if (activeDrag?.win) activeDrag.win.dragging = false;
    activeDrag = null;
  }

  // Canvas event wiring
  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    const p = screenToPx(e.clientX, e.clientY);
    onDown(p.x, p.y);
  });
  canvas.addEventListener("pointermove", (e) => {
    e.preventDefault();
    const p = screenToPx(e.clientX, e.clientY);
    onMove(p.x, p.y);
  });
  canvas.addEventListener("pointerup", (e) => {
    e.preventDefault();
    onUp();
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });
  canvas.addEventListener("pointercancel", (e) => { onUp(); });

  // ============================================================
  // 6) Main loop: delta redraw + optional demo animation
  // ============================================================
  let lastTS = performance.now();
  let fpsEMA = 0;
  let anim = false;
  let bounce = { x: 12, y: 6, vx: 1, vy: 1 }; // tile coords for demo icon

  function tick(ts) {
    if (!anim) return;
    const dt = Math.max(0.001, (ts - lastTS) / 1000);
    lastTS = ts;
    const fps = 1/dt;
    fpsEMA = fpsEMA ? (0.85*fpsEMA + 0.15*fps) : fps;
    $("fps").textContent = fpsEMA.toFixed(1);

    // If not booted, just present idle
    if (!OS.booted) {
      requestAnimationFrame(tick);
      return;
    }

    OS.time += dt;

    // Demo: move an icon around (tile-space), only dirty tiles affected via redrawAll (simple)
    if (OS.demo) {
      // erase old by redrawing desktop each frame is expensive; but with tile engine it's okay.
      // We'll do a proper delta: change only two tiles (old and new).
      const oldX = bounce.x, oldY = bounce.y;

      bounce.x += bounce.vx;
      bounce.y += bounce.vy;
      if (bounce.x <= 1 || bounce.x >= TX-2) bounce.vx *= -1;
      if (bounce.y <= 1 || bounce.y >= TY-4) bounce.vy *= -1;

      // Restore old tile from background (approx: use BG; better: re-render desktop tile there)
      // For correctness, redraw desktop once when demo toggled on/off; then do local overwrite.
      // We'll overwrite the moving glyph tile only.
      setTile(oldX, oldY, TILE.BG);
      setTile(bounce.x, bounce.y, TILE.ICON);
      // draw letter
      drawText(bounce.x, bounce.y, "D", 14, 2);

      // cursor + taskbar clock refresh occasionally
      if (Math.floor(OS.time*2) % 2 === 0) {
        drawDesktop(); // updates clock + menu if open
        drawWindows();
      }
      drawCursor();
    } else {
      // update clock every second
      if (Math.floor(OS.time) !== Math.floor(OS.time - dt)) {
        drawDesktop();
        drawWindows();
        drawCursor();
        clearDirtyAll();
      }
    }

    // Blit dirty tiles and present
    const updatedTiles = blitDirtyTiles();
    $("dirty").textContent = String(updatedTiles);
    present();

    // Recorder capture
    if (REC.active) REC.captureFrame();

    requestAnimationFrame(tick);
  }

  function presentTick(forceAll=false) {
    if (forceAll) clearDirtyAll();
    const updated = blitDirtyTiles();
    $("dirty").textContent = String(updated);
    present();
  }

  function startLoop() {
    if (anim) return;
    anim = true;
    lastTS = performance.now();
    requestAnimationFrame(tick);
  }

  function stopLoop() {
    anim = false;
  }

  // ============================================================
  // 7) GIF Recorder (paletted, local-only)
  //    Format: GIF89a, global color table, frames via LZW
  // ============================================================
  const REC = {
    active: false,
    frames: [], // { idx: Uint8Array(W*H), delayCs }
    lastCap: 0,
    fps: 12,
    maxFrames: 180, // safety (15s at 12fps)
    captureFrame() {
      const now = performance.now();
      const interval = 1000 / this.fps;
      if (now - this.lastCap < interval) return;
      this.lastCap = now;
      if (this.frames.length >= this.maxFrames) { this.stop(); toast("Recorder max frames"); return; }
      // Copy current framebuffer indices
      const snap = new Uint8Array(fbIdx); // clone
      this.frames.push({ idx: snap, delayCs: Math.round(100/this.fps) }); // centiseconds
      $("rec").textContent = `rec ${this.frames.length}`;
    },
    start() {
      if (!OS.booted) { toast("Boot first"); return; }
      this.frames = [];
      this.lastCap = 0;
      this.active = true;
      $("rec").textContent = "rec 0";
      toast("Recording…");
      log("Recorder started at " + this.fps + " fps.");
    },
    stop() {
      this.active = false;
      $("rec").textContent = `stopped (${this.frames.length})`;
      toast("Recording stopped");
      log("Recorder stopped. Frames: " + this.frames.length);
    },
    exportGIF() {
      if (!this.frames.length) { toast("No frames"); return; }
      const bytes = buildGIF(this.frames, W, H, palette);
      const blob = new Blob([bytes], { type: "image/gif" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "gif-os.gif";
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 2000);
      toast("GIF exported");
      log("GIF exported: " + bytes.length + " bytes.");
    }
  };

  // --- GIF encoding helpers ---
  function u16le(n){ return [n & 255, (n>>8) & 255]; }

  function buildGIF(frames, w, h, palRGB) {
    // Use 256-color global table (768 bytes) already provided.
    // LZW min code size = 8 (since indices are 0..255).
    const out = [];
    // Header
    pushStr(out, "GIF89a");
    out.push(...u16le(w), ...u16le(h));
    // Logical Screen Descriptor:
    // packed: GlobalColorTableFlag=1, ColorRes=7 (8 bits), Sort=0, GCTSize=7 (2^(7+1)=256)
    out.push(0b11110111);
    out.push(0); // background color index
    out.push(0); // pixel aspect ratio
    // Global Color Table
    for (let i=0;i<256*3;i++) out.push(palRGB[i] ?? 0);

    // Looping (NETSCAPE2.0)
    out.push(0x21, 0xFF, 0x0B);
    pushStr(out, "NETSCAPE2.0");
    out.push(0x03, 0x01, 0x00, 0x00, 0x00); // loop forever

    // Frames
    for (const fr of frames) {
      // Graphics Control Extension
      out.push(0x21, 0xF9, 0x04);
      const packed = 0b00000000; // no transparency, no disposal
      out.push(packed);
      out.push(...u16le(fr.delayCs)); // delay in cs
      out.push(0); // transparent index
      out.push(0); // block terminator

      // Image Descriptor
      out.push(0x2C);
      out.push(...u16le(0), ...u16le(0), ...u16le(w), ...u16le(h));
      out.push(0x00); // no local color table

      // Image Data
      out.push(8); // LZW min code size
      const lzw = gifLZW(fr.idx, 8);
      // sub-blocks (max 255)
      let i=0;
      while (i < lzw.length) {
        const n = Math.min(255, lzw.length - i);
        out.push(n);
        for (let j=0;j<n;j++) out.push(lzw[i+j]);
        i += n;
      }
      out.push(0); // terminator
    }

    // Trailer
    out.push(0x3B);
    return new Uint8Array(out);
  }

  function pushStr(arr, s){ for (let i=0;i<s.length;i++) arr.push(s.charCodeAt(i)); }

  // LZW encoder for GIF (byte stream)
  // This is a standard dictionary-based LZW for GIF with clear/end codes.
  function gifLZW(indexStream, minCodeSize) {
    const CLEAR = 1 << minCodeSize;   // 256
    const END   = CLEAR + 1;          // 257
    let codeSize = minCodeSize + 1;   // 9
    let dictSize = END + 1;           // 258

    // dictionary: map string -> code
    // We'll represent strings as "a,b,c" keys. It's not ultra-fast but fine at 256x144 and short clips.
    const dict = new Map();
    function resetDict() {
      dict.clear();
      for (let i=0;i<CLEAR;i++) dict.set(String.fromCharCode(i), i);
      dictSize = END + 1;
      codeSize = minCodeSize + 1;
    }
    resetDict();

    const outBits = [];
    function pushCode(code) {
      for (let i=0;i<codeSize;i++) outBits.push((code >> i) & 1); // LSB first
    }

    pushCode(CLEAR);

    // Build codes
    let w = String.fromCharCode(indexStream[0]);
    for (let i=1;i<indexStream.length;i++) {
      const k = String.fromCharCode(indexStream[i]);
      const wk = w + k;
      if (dict.has(wk)) {
        w = wk;
      } else {
        pushCode(dict.get(w));
        dict.set(wk, dictSize++);

        // grow code size as dict grows
        if (dictSize === (1 << codeSize) && codeSize < 12) codeSize++;

        // GIF requires clear when dict full (4096)
        if (dictSize >= 4096) {
          pushCode(CLEAR);
          resetDict();
        }
        w = k;
      }
    }
    pushCode(dict.get(w));
    pushCode(END);

    // Pack bits into bytes
    const out = [];
    let b = 0, bit = 0;
    for (let i=0;i<outBits.length;i++) {
      b |= (outBits[i] & 1) << bit;
      bit++;
      if (bit === 8) { out.push(b); b=0; bit=0; }
    }
    if (bit > 0) out.push(b);

    return new Uint8Array(out);
  }

  // ============================================================
  // 8) Controls
  // ============================================================
  $("btnBoot").addEventListener("click", () => { boot(); startLoop(); });
  $("btnLoadApps").addEventListener("click", async () => {
    const n = await LoadedApps.pick();
    if (n > 0) {
      OS.loadedApps = LoadedApps.list.map((a, idx) => ({
        id: "APP_" + idx,
        name: a.name,
        handle: a.handle,
        label: LoadedApps.label(a.name),
        glyph: LoadedApps.label(a.name).slice(0,1) || "A"
      }));
      if (!OS.booted) boot();
      redrawAll();
    }
  });

  $("btnReset").addEventListener("click", () => { location.reload(); });
  $("btnDemo").addEventListener("click", () => { if (!OS.booted) boot(); toggleDemo(); });

  $("btnAQC")?.addEventListener("click", () => { if (!OS.booted) boot(); openWebApp({ name: "BAZ AQC Lab", text: AQC_LAB_HTML }); });

  $("btnNotepad").addEventListener("click", () => { if (!OS.booted) boot(); openNotepad(); });
  $("btnAbout").addEventListener("click", () => {
    alert(
`GIF‑OS Prototype (single-file)

This is a “GIF‑architecture OS” skeleton:
• Screen = paletted framebuffer
• Renderer = 8x8 tiles + dedup registry
• Updates = dirty-tile delta blits
• Optional recorder exports a real animated GIF (GIF89a) locally

Next steps:
1) filesystem-backed “vault” directory
2) app packaging as tile sprites + delta scripts
3) stronger PPU model: prime-coded tile IDs + CAM-like registry`
    );
  });

  $("btnRec").addEventListener("click", () => { REC.start(); });
  $("btnStop").addEventListener("click", () => { REC.stop(); });
  $("btnExport").addEventListener("click", () => { REC.exportGIF(); });

  $("btnHelp").addEventListener("click", () => {
    alert(
`Controls:
• Tap Start (bottom-left) to open Menu
• Tap Notepad or Demo
• Drag window by title bar
• Record/Stop/Export to get an animated GIF of the OS

If Start doesn’t respond, you’re probably opening via a content:// viewer.
Open the HTML directly in Chrome or “Open with Chrome” from Downloads.`
    );
  });

  // Boot minimal to show something even before pressing Boot
  (function coldSplash(){
    // init with a simple splash in tiles
    // Ensure at least one tile exists
    const splashBG = solidTile(1);
    for (let i=0;i<TX*TY;i++) tileMap[i] = splashBG;
    clearDirtyAll();
    drawText(6, 7, "GIF-OS", 7, 1);
    drawText(3, 9, "PRESS BOOT", 6, 1);
    blitDirtyTiles();
    present();
    $("fps").textContent = "—";
    $("dirty").textContent = "—";
    $("rec").textContent = "idle";
    log("Loaded. Press Boot to initialize the OS state machine.");
  })();

})();
</script>
</body>
</html>
